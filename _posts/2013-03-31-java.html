---
layout: post
title: Java的内存回收机制
date: '2013-03-31T20:13:00.001+08:00'
author: Wenh Q
tags: 
modified_time: '2013-03-31T20:13:54.075+08:00'
blogger_id: tag:blogger.com,1999:blog-4961947611491238191.post-7395013572631362959
blogger_orig_url: http://binaryware.blogspot.com/2013/03/java.html
---

<div style="margin: 0px 2px; padding-top: 1px;    background-color: #c3d9ff; font-size: 1px !important;    line-height: 0px !important;">&nbsp;</div> <div style="margin: 0px 1px; padding-top: 1px;    background-color: #c3d9ff; font-size: 1px !important;    line-height: 0px !important;">&nbsp;</div> <div style="padding: 4px; background-color: #c3d9ff;"><h3 style="margin:0px 3px;font-family:sans-serif">Quantum 通过 Google 阅读器发送给您的内容：</h3></div> <div style="margin: 0px 1px; padding-top: 1px;    background-color: #c3d9ff; font-size: 1px !important;    line-height: 0px !important;">&nbsp;</div> <div style="margin: 0px 2px; padding-top: 1px;    background-color: #c3d9ff; font-size: 1px !important;    line-height: 0px !important;">&nbsp;</div> <div style="font-family:sans-serif;overflow:auto;width:100%;margin: 0px 10px"><h2 style="margin: 0.25em 0 0 0"><div class=""><a href="http://blog.jobbole.com/37273/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=java%25e7%259a%2584%25e5%2586%2585%25e5%25ad%2598%25e5%259b%259e%25e6%2594%25b6%25e6%259c%25ba%25e5%2588%25b6">Java&#30340;&#20869;&#23384;&#22238;&#25910;&#26426;&#21046;</a></div></h2> <div style="margin-bottom: 0.5em">于 13-3-31 通过 <a href="http://blog.jobbole.com" class="f">&#21338;&#23458; - &#20271;&#20048;&#22312;&#32447;</a> &#20316;&#32773;&#65306;&#31461;&#28023;&#27874;</div><br style="display:none"> <p>来源 <a href="http://www.cnblogs.com/xiaoxuetu/archive/2013/03/29/2987805.html">小学徒的成长历程</a></p> <p>在Java中，它的内存管理包括两方面：内存分配（创建Java对象的时候）和内存回收，这两方面工作都是由JVM自动完成的，降低了Java<span><a href="http://blog.jobbole.com/821/" title="程序员的本质">程序员</a></span>的学习难度，避免了像C/C++直接操作内存的危险。但是，也正因为内存管理完全由JVM负责，所以也使Java很多程序员不再关心内存分配，导致很多程序低效，耗内存。因此就有了Java程序员到最后应该去了解JVM，才能写出更高效，充分利用有限的内存的程序。</p> <p><strong>1.Java在内存中的状态</strong></p> <p>首先我们先写一个代码为例子：</p> <p>Person.java</p> <pre>package test;    import java.io.Serializable;    public class Person implements Serializable {        static final long serialVersionUID = 1L;        String name; // 姓名            Person friend;    //朋友        public Person() {}            public Person(String name) {          super();          this.name = name;      }  }</pre> <p>Test.java</p> <pre>package test;      public class Test{        public static void main(String[] args) {          Person p1 = new Person(&quot;Kevin&quot;);          Person p2 = new Person(&quot;Rain&quot;);          Person p3 = new Person(&quot;Sunny&quot;);                    p1.friend = p2;          p3 = p2;          p2 = null;      }  }</pre> <p>把上面Test.java中main方面里面的对象引用画成一个从main方法开始的对象引用图的话就是这样的（顶点是对象和引用，有向边是引用关系）：</p> <p><a href="http://blog.jobbole.com/wp-content/uploads/2013/03/download.png" rel="lightbox[37273]" title="Java的内存回收机制"><img title="Java的内存回收机制" src="http://blog.jobbole.com/wp-content/uploads/2013/03/download.png" alt="Java的内存回收机制"></a></p> <p>当程序运行起来之后，把它在内存中的状态看成是有向图后，可以分为三种：</p> <p>1）<strong>可达状态</strong>：在一个对象创建后，有一个以上的引用变量引用它。在有向图中可以从起始顶点导航到该对象，那它就处于可达状态。</p> <p>2）<strong>可恢复状态</strong>：如果程序中某个对象不再有任何的引用变量引用它，它将先进入可恢复状态，此时从有向图的起始顶点不能再导航到该对象。在这个状态下，系统的垃圾回收机制准备回收该对象的所占用的内存，在回收之前，系统会调用finalize()方法进行资源清理，如果资源整理后重新让一个以上引用变量引用该对象，则这个对象会再次变为可达状态；否则就会进入不可达状态。</p> <p>3）<strong>不可达状态</strong>：当对象的所有关联都被切断，且系统调用finalize()方法进行资源清理后依旧没有使该对象变为可达状态，则这个对象将永久性失去引用并且变成不可达状态，系统才会真正的去回收该对象所占用的资源。</p> <p>上述三种状态的转换图如下：</p> <p><a href="http://blog.jobbole.com/wp-content/uploads/2013/03/download-1.png" rel="lightbox[37273]" title="Java的内存回收机制"><img title="Java的内存回收机制" src="http://blog.jobbole.com/wp-content/uploads/2013/03/download-1.png" alt="Java的内存回收机制"></a></p> <p><strong>2.Java对对象的4种引用</strong></p> <p>1）<strong>强引用</strong> ：创建一个对象并把这个对象直接赋给一个变量，eg ：Person person = new Person("sunny"); 不管系统资源有么的紧张，强引用的对象都绝对不会被回收，即使他以后不会再用到<strong>。</strong></p> <p>2）<strong>软引用</strong> ：通过SoftReference类实现，eg : SoftReference&lt;Person&gt; p = new SoftReference&lt;Person&gt;(new Person("Rain"));,内存非常紧张的时候会被回收，其他时候不会被回收，所以在使用之前要判断是否为null从而判断他是否已经被回收了。</p> <p>3）<strong>弱引用 </strong>：通过WeakReference类实现，eg : WeakReference&lt;Person&gt; p = new WeakReference&lt;Person&gt;(new Person("Rain"));不管内存是否足够，系统垃圾回收时必定会回收。</p> <p>4）<strong>虚引用 </strong>：不能单独使用，主要是用于追踪对象被垃圾回收的状态。通过PhantomReference类和引用队列ReferenceQueue类联合使用实现，eg ：</p> <pre>package test;    import java.lang.ref.PhantomReference;  import java.lang.ref.ReferenceQueue;      public class Test{        public static void main(String[] args) {          //创建一个对象          Person person = new Person(&quot;Sunny&quot;);              //创建一个引用队列              ReferenceQueue&lt;Person&gt; rq = new ReferenceQueue&lt;Person&gt;();          //创建一个虚引用，让此虚引用引用到person对象          PhantomReference&lt;Person&gt; pr = new PhantomReference&lt;Person&gt;(person, rq);          //切断person引用变量和对象的引用          person = null;          //试图取出虚引用所引用的对象          //发现程序并不能通过虚引用访问被引用对象，所以此处输出为null          System.out.println(pr.get());          //强制垃圾回收          System.gc();          System.runFinalization();          //因为一旦虚引用中的对象被回收后，该虚引用就会进入引用队列中          //所以用队列中最先进入队列中引用与pr进行比较，输出true          System.out.println(rq.poll() == pr);      }  }</pre> <p>运行结果：</p> <p><a href="http://blog.jobbole.com/wp-content/uploads/2013/03/download-2.png" rel="lightbox[37273]" title="Java的内存回收机制"><img title="Java的内存回收机制" src="http://blog.jobbole.com/wp-content/uploads/2013/03/download-2.png" alt="Java的内存回收机制"></a></p> <p><strong>3.Java垃圾回收机制</strong></p> <p>其实Java垃圾回收主要做的是两件事：1）内存回收 2）碎片整理</p> <p><strong>3.1垃圾回收算法</strong></p> <p>1）<strong>串行回收（只用一个CPU）和并行回收（多个CPU才有用）</strong>：串行回收是不管系统有多少个CPU，始终只用一个CPU来执行垃圾回收操作，而并行回收就是把整个回收工作拆分成多个部分，每个部分由一个CPU负责，从而让多个CPU并行回收。并行回收的执行效率很高，但复杂度增加，另外也有一些副作用，如内存随便增加。</p> <p>2）<strong>并发执行和应用程序停止 </strong>：应用程序停止（Stop-the-world）顾名思义，其垃圾回收方式在执行垃圾回收的同时会导致应用程序的暂停。并发执行的垃圾回收虽然不会导致应用程序的暂停，但由于并发执行垃圾需要解决和应用程序的执行冲突（应用程序可能在垃圾回收的过程修改对象），因此并发执行垃圾回收的系统开销比Stop-the-world高，而且执行时需要更多的堆内存。</p> <p>3）<strong>压缩和不压缩和复制 ：</strong></p> <p>①支持压缩的垃圾回收器<strong>（标记-压缩 = 标记清除+压缩）</strong>会把所有的可达对象搬迁到一起，然后将之前占用的内存全部回收，减少了内存碎片。</p> <p>②不压缩的垃圾回收器<strong>（标记-清除）</strong>要遍历两次，第一次先从跟开始访问所有可达对象，并将他们标记为可达状态，第二次便利整个内存区域，对未标记可达状态的对象进行回收处理。这种回收方式不压缩，不需要额外内存，但要两次遍历，会产生碎片</p> <p>③<strong>复制</strong>式的垃圾回收器：将堆内存分成两个相同空间，从根（类似于前面的有向图起始顶点）开始访问每一个关联的可达对象，将空间A的全部可达对象复制到空间B，然后一次性回收空间A。对于该算法而言，因为只需访问所有的可达对象，将所有的可达对象复制走之后就直接回收整个空间，完全不用理会不可达对象，所以遍历空间的成本较小，但需要巨大的复制成本和较多的内存。</p> <p><a href="http://blog.jobbole.com/wp-content/uploads/2013/03/download-3.png" rel="lightbox[37273]" title="Java的内存回收机制"><img title="Java的内存回收机制" src="http://blog.jobbole.com/wp-content/uploads/2013/03/download-3.png" alt="Java的内存回收机制"></a></p> <p><strong>3.2堆内存的分代回收</strong></p> <p><strong>1）分代回收的依据：</strong></p> <p><strong>①对象生存时间的长短：</strong>大部分对象在Young期间就被回收</p> <p><strong>②不同代采取不同的垃圾回收策略：</strong>新（生存时间短）老（生存时间长）对象之间很少存在引用</p> <p><strong>2) 堆内存的分代：</strong></p> <p><strong>①Young代 ：</strong></p> <p>Ⅰ回收机制 ：因为对象数量少，所以采用复制回收。</p> <p>Ⅱ组成区域 ：由1个Eden区和2个Survivor区构成，同一时间的两个Survivor区，一个用来保存对象，另一个是空的；每次进行Young代垃圾回收的时候，就把Eden，From中的可达对象复制到To区域中，一些生存时间长的就复制到了老年代，接着清除Eden，From空间，最后原来的To空间变为From空间，原来的From空间变为To空间。</p> <p>Ⅲ对象来源 ：绝大多数对象先分配到Eden区，一些大的对象会直接被分配到Old代中。</p> <p>Ⅳ回收频率 ：因为Young代对象大部分很快进入不可达状态，因此回收频率高且回收速度快</p> <p><a href="http://blog.jobbole.com/wp-content/uploads/2013/03/download-4.png" rel="lightbox[37273]" title="Java的内存回收机制"><img title="Java的内存回收机制" src="http://blog.jobbole.com/wp-content/uploads/2013/03/download-4.png" alt="Java的内存回收机制"></a>           <a href="http://blog.jobbole.com/wp-content/uploads/2013/03/download-5.png" rel="lightbox[37273]" title="Java的内存回收机制"><img title="Java的内存回收机制" src="http://blog.jobbole.com/wp-content/uploads/2013/03/download-5.png" alt="Java的内存回收机制"></a></p> <p><strong>②Old代 ：</strong></p> <p>Ⅰ回收机制 ：采用标记压缩算法回收。</p> <p>Ⅱ对象来源 ：1.对象大直接进入老年代。</p> <p>2.Young代中生存时间长的可达对象</p> <p>Ⅲ回收频率 ：因为很少对象会死掉，所以执行频率不高，而且需要较长时间来完成。</p> <p><strong>③Permanent代 ：</strong></p> <p>Ⅰ用      途 ：用来装载Class，方法等信息，默认为64M，不会被回收</p> <p>Ⅱ对象来源 ：eg：对于像Hibernate，Spring这类喜欢AOP动态生成类的框架，往往会生成大量的动态代理类，因此需要更多的Permanent代内存。所以我们经常在调试Hibernate，Spring的时候经常遇到java.lang.OutOfMemoryError:PermGen space的错误，这就是Permanent代内存耗尽所导致的错误。</p> <p>Ⅲ回收频率 ：不会被回收</p> <p><strong>3.3常见的垃圾回收器</strong></p> <p><strong>1）串行回收器</strong>（只使用一个CPU）：Young代采用串行复制算法；Old代使用串行标记压缩算法（三个阶段：标记mark—清除sweep—压缩compact），回收期间程序会产生暂停，</p> <p><strong>2）并行回收器</strong>：对Young代采用的算法和串行回收器一样，只是增加了多CPU并行处理； 对Old代的处理和串行回收器完全一样，依旧是单线程。</p> <p><strong>3）并行压缩回收器</strong>：对Young代处理采用与并行回收器完全一样的算法；只是对Old代采用了不同的算法，其实就是划分不同的区域，然后进行标记压缩算法：</p> <p>① 将Old代划分成几个固定区域；</p> <p>② mark阶段（多线程并行），标记可达对象；</p> <p>③ summary阶段（串行执行），从最左边开始检验知道找到某个达到数值（可达对象密度小）的区域时，此区域及其右边区域进行压缩回收，其左端为密集区域</p> <p>④ compact阶段（多线程并行），识别出需要装填的区域，多线程并行的把数据复制到这些区域中。经此过程后，Old代一端密集存在大量活动对象，另一端则存在大块空间。</p> <p><strong>4）并发标识—清理回收（CMS）</strong>：对Young代处理采用与并行回收器完全一样的算法；只是对Old代采用了不同的算法，但归根待地还是标记清理算法：</p> <p>① 初始标识（程序暂停）：标记被直接引用的对象(一级对象)；</p> <p>② 并发标识（程序运行）：通过一级对象寻找其他可达对象；</p> <p>③ 再标记（程序暂停）：多线程并行的重新标记之前可能因为并发而漏掉的对象（简单的说就是防遗漏）</p> <p>④ 并发清理（程序运行）</p> <p><strong>4.内存管理小技巧</strong></p> <p>1）尽量使用直接量，eg：String javaStr = "小学徒的成长历程";</p> <p>2）使用StringBuilder和StringBuffer进行字符串连接等操作;</p> <p>3）尽早释放无用对象;</p> <p>4）尽量少使用静态变量;</p> <p>5）缓存常用的对象:可以使用开源的开源缓存实现，eg：OSCache，Ehcache;</p> <p>6）尽量不使用finalize()方法;</p> <p>7）在必要的时候可以考虑使用软引用SoftReference。</p> <h4>相关文章</h4> <ul> <li><a href="http://blog.jobbole.com/22909/"><img src="http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg" alt="深度解析Java内存原型"></a><a href="http://blog.jobbole.com/22909/">深度解析Java内存原型</a></li> <li><a href="http://blog.jobbole.com/31860/"><img src="http://blog.jobbole.com/wp-content/uploads/2013/02/Java-programming-language-logo3-150x150.jpg" alt="探索Java语言与JVM中的Lambda表达式"></a><a href="http://blog.jobbole.com/31860/">探索Java语言与JVM中的Lambda表达式</a></li> <li><a href="http://blog.jobbole.com/30257/"><img width="150" height="150" src="http://blog.jobbole.com/wp-content/uploads/2012/11/deep_into_JVM_001-150x150.jpg" alt="《深入理解JAVA虚拟机》笔记"></a><a href="http://blog.jobbole.com/30257/">《深入理解JAVA虚拟机》笔记</a></li> <li><a href="http://blog.jobbole.com/15342/"><img src="http://blog.jobbole.com/wp-content/uploads/2011/11/book-logo.jpg" alt="JVM程序员的阅读清单"></a><a href="http://blog.jobbole.com/15342/">JVM程序员的阅读清单</a></li> <li><a href="http://blog.jobbole.com/1178/"><img width="150" height="150" src="http://blog.jobbole.com/wp-content/uploads/2011/08/Time-changes-in-year-1927-for-China-%E2%80%93-ShanghaiS-150x150.png" alt="Time changes in year 1927 for China"></a><a href="http://blog.jobbole.com/1178/">陈皓：你确信你了解时间吗？</a></li> <li><a href="http://blog.jobbole.com/23939/"><img src="http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg" alt="Java对象初始化详解"></a><a href="http://blog.jobbole.com/23939/">Java对象初始化详解</a></li> <li><a href="http://blog.jobbole.com/28297/"><img width="150" height="150" src="http://blog.jobbole.com/wp-content/uploads/2012/09/image_thumb10-150x150.png" alt="Java多线程发展简史"></a><a href="http://blog.jobbole.com/28297/">Java多线程发展简史</a></li> <li><a href="http://blog.jobbole.com/29195/"><img src="http://blog.jobbole.com/wp-content/uploads/2011/11/software-development-logo.jpg" alt="Web Service入门"></a><a href="http://blog.jobbole.com/29195/">Web Service入门</a></li> <li><a href="http://blog.jobbole.com/844/"><img src="http://blog.jobbole.com/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/14.jpg" alt="异常的代价"></a><a href="http://blog.jobbole.com/844/">异常的代价</a></li> <li><a href="http://blog.jobbole.com/22433/"><img src="http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg" alt="Java 8 中的 lambda 表达式"></a><a href="http://blog.jobbole.com/22433/">Java 8 中的 lambda 表达式</a></li> </ul> <p><a href="http://blog.jobbole.com/37273/">Java的内存回收机制</a>，首发于<a href="http://blog.jobbole.com">博客 - 伯乐在线</a>。</p></div> <br> <div style="margin: 0px 2px; padding-top: 1px;    background-color: #c3d9ff; font-size: 1px !important;    line-height: 0px !important;">&nbsp;</div> <div style="margin: 0px 1px; padding-top: 1px;    background-color: #c3d9ff; font-size: 1px !important;    line-height: 0px !important;">&nbsp;</div> <div style="padding: 4px; background-color: #c3d9ff;"><h3 style="margin:0px 3px;font-family:sans-serif">可从此处完成的操作：</h3> <ul style="font-family:sans-serif"><li>使用 <b>Google 阅读器</b><a href="http://www.google.com/reader/view/feed%2Fhttp%3A%2F%2Fblog.jobbole.com%2Ffeed%2F?source=email">订阅&#21338;&#23458; - &#20271;&#20048;&#22312;&#32447;</a></li> <li><a href="http://www.google.com/reader/?source=email">开始使用 Google 阅读器</a>，轻松地与<b>您喜爱的所有网站</b>保持同步更新</li></ul></div> <div style="margin: 0px 1px; padding-top: 1px;    background-color: #c3d9ff; font-size: 1px !important;    line-height: 0px !important;">&nbsp;</div> <div style="margin: 0px 2px; padding-top: 1px;    background-color: #c3d9ff; font-size: 1px !important;    line-height: 0px !important;">&nbsp;</div>