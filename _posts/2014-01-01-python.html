---
layout: post
title: "像老大一样优化 Python"
date: '2014-01-01T12:39:00.003+08:00'
author: Wenh Q
tags:
- tech
modified_time: '2014-01-01T12:39:28.690+08:00'
blogger_id: tag:blogger.com,1999:blog-4961947611491238191.post-5378188935321574388
blogger_orig_url: http://binaryware.blogspot.com/2014/01/python.html
---

<div style="margin-top: 15px;">通过 <a href="http://www.oschina.net/?from=rss" style="font-size: 13px;" target="_blank">开源中国社区最新新闻</a>              </div><div dir="ltr" style="font-size: 14px; line-height: 20px; margin-top: 15px;"><span style="color: #888888;">我们应该忘掉一些小的效率问题，在 97% 的情况下是这么说的：过早优化是万恶之源。—— Donald Knuth</span><br />如果不首先想想这句Knuth的名言，就开始进行优化工作是不明智的。可是，你很快写出来加入一些特性的代码，可能会很丑陋，你需要注意了。这篇文章就是为这时候准备的。<br />那么接下来就是一些很有用的工具和模式来快速优化<span style="font-family: Times New Roman;">Python</span><span style="font-family: 宋体;">。它的主要目的很简单：尽快发现瓶颈，修复它们并且确认你修复了它们。</span><br /><h3>写一个测试</h3>在你开始优化前，写一个高级测试来证明原来代码很慢。你可能需要采用一些最小值数据集来复现它足够慢。通常一两个显示运行时秒的程序就足够处理一些改进的地方了。<br />有一些基础测试来保证你的优化没有改变原有代码的行为也是很必要的。你也能够在很多次运行测试来优化代码的时候稍微修改这些测试的基准。<br />那么现在，我们来来看看优化工具把。<br /><h3>简单的计时器</h3>计时器很简单，这是一个最灵活的记录执行时间的方法。你可以把它放到任何地方并且副作用很小。运行你自己的计时器非常简单，并且你可以将其定制，使它以你期望的方式工作。例如，你个简单的计时器如下：<br /><pre>import&nbsp;time    def&nbsp;timefunc(f):  &nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;f_timer(*args,&nbsp;**kwargs):  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;start&nbsp;=&nbsp;time.time()  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;f(*args,&nbsp;**kwargs)  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;end&nbsp;=&nbsp;time.time()  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;f.__name__,&nbsp;'took',&nbsp;end&nbsp;-&nbsp;start,&nbsp;'time'  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result  &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;f_timer    def&nbsp;get_number():  &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;xrange(5000000):  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;x    @timefunc  def&nbsp;expensive_function():  &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;get_number():  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;x&nbsp;^&nbsp;x&nbsp;^&nbsp;x  &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;'some&nbsp;result!'    #&nbsp;prints&nbsp;"expensive_function&nbsp;took&nbsp;0.72583088875&nbsp;seconds"  result&nbsp;=&nbsp;expensive_function()</pre>当然，你可以用上下文管理来让它功能更加强大，添加一些检查点或者一些其他的功能：<br /><pre>import&nbsp;time    class&nbsp;timewith():  &nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__init__(self,&nbsp;name=''):  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;<a href="http://self.name/" target="_blank">self.name</a>&nbsp;=&nbsp;name  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.start&nbsp;=&nbsp;time.time()    &nbsp;&nbsp;&nbsp;&nbsp;@property  &nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;elapsed(self):  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;time.time()&nbsp;-&nbsp;self.start    &nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;checkpoint(self,&nbsp;name=''):  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;print&nbsp;'{timer}&nbsp;{checkpoint}&nbsp;took&nbsp;{elapsed}&nbsp;seconds'.format(  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;timer=<a href="http://self.name/" target="_blank">self.name</a>,  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;checkpoint=name,  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;elapsed=self.elapsed,  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;).strip()    &nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__enter__(self):  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;self    &nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;__exit__(self,&nbsp;type,&nbsp;value,&nbsp;traceback):  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;self.checkpoint('finished')  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;pass    def&nbsp;get_number():  &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;xrange(5000000):  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;x    def&nbsp;expensive_function():  &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;get_number():  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;x&nbsp;^&nbsp;x&nbsp;^&nbsp;x  &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;'some&nbsp;result!'    #&nbsp;prints&nbsp;something&nbsp;like:  #&nbsp;fancy&nbsp;thing&nbsp;done&nbsp;with&nbsp;something&nbsp;took&nbsp;0.582462072372&nbsp;seconds  #&nbsp;fancy&nbsp;thing&nbsp;done&nbsp;with&nbsp;something&nbsp;else&nbsp;took&nbsp;1.75355315208&nbsp;seconds  #&nbsp;fancy&nbsp;thing&nbsp;finished&nbsp;took&nbsp;1.7535982132&nbsp;seconds  with&nbsp;timewith('fancy&nbsp;thing')&nbsp;as&nbsp;timer:  &nbsp;&nbsp;&nbsp;&nbsp;expensive_function()  &nbsp;&nbsp;&nbsp;&nbsp;timer.checkpoint('done&nbsp;with&nbsp;something')  &nbsp;&nbsp;&nbsp;&nbsp;expensive_function()  &nbsp;&nbsp;&nbsp;&nbsp;expensive_function()  &nbsp;&nbsp;&nbsp;&nbsp;timer.checkpoint('done&nbsp;with&nbsp;something&nbsp;else')    #&nbsp;or&nbsp;directly  timer&nbsp;=&nbsp;timewith('fancy&nbsp;thing')  expensive_function()  timer.checkpoint('done&nbsp;with&nbsp;something')</pre>计时器还需要你做一些挖掘。包装一些更高级的函数，并且确定瓶颈在哪，然后深入的函数里，能够不停的重现。当你发现一些不合适的代码，修复它，然后测试一遍以确认它被修复了。<br />一些小技巧：不要忘了好用的<span style="font-family: Times New Roman;">timeit</span><span style="font-family: 宋体;">模块！它对小块代码做基准测试而不是实际调查更加有用。</span><br /><ul><li>Timer <span style="font-family: 宋体;">优点：很容易理解和实现。也非常容易在修改后进行比较。对于很多语言都适用。</span></li></ul><ul><li>Timer <span style="font-family: 宋体;">缺点：有时候对于非常复杂的代码有点过于简单，你可能会花更多时间放置或移动引用代码而不是修复问题！</span></li></ul><h3>内建优化器</h3>启用内建的优化器就像是用一门大炮。它非常强大，但是有点不太好用，使用和解释起来比较复杂。<br />你可以了解更多关于<span style="font-family: Times New Roman;">profile</span><span style="font-family: 宋体;">模块的东西，但是它的基础是非常简单的：你能够启用和禁用优化器，而且它能打印所有的函数调用和执行时间。它能给你编译和打印出输出。一个简单的装饰器如下：</span><br /><pre>import&nbsp;cProfile    def&nbsp;do_cprofile(func):  &nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;profiled_func(*args,&nbsp;**kwargs):  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;profile&nbsp;=&nbsp;cProfile.Profile()  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;profile.enable()  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;result&nbsp;=&nbsp;func(*args,&nbsp;**kwargs)  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;profile.disable()  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;result  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally:  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;profile.print_stats()  &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;profiled_func    def&nbsp;get_number():  &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;xrange(5000000):  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;x    @do_cprofile  def&nbsp;expensive_function():  &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;get_number():  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;x&nbsp;^&nbsp;x&nbsp;^&nbsp;x  &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;'some&nbsp;result!'    #&nbsp;perform&nbsp;profiling  result&nbsp;=&nbsp;expensive_function()</pre>在上面代码的情况下，你应该看到有些东西在终端打印出来，打印的内容如下：<br /><pre>5000003&nbsp;function&nbsp;calls&nbsp;in&nbsp;1.626&nbsp;seconds    &nbsp;&nbsp;&nbsp;Ordered&nbsp;by:&nbsp;standard&nbsp;name    &nbsp;&nbsp;&nbsp;ncalls&nbsp;&nbsp;tottime&nbsp;&nbsp;percall&nbsp;&nbsp;cumtime&nbsp;&nbsp;percall&nbsp;filename:lineno(function)  &nbsp;&nbsp;5000001&nbsp;&nbsp;&nbsp;&nbsp;0.571&nbsp;&nbsp;&nbsp;&nbsp;0.000&nbsp;&nbsp;&nbsp;&nbsp;0.571&nbsp;&nbsp;&nbsp;&nbsp;0.000&nbsp;timers.py:92(get_number)  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;1.055&nbsp;&nbsp;&nbsp;&nbsp;1.055&nbsp;&nbsp;&nbsp;&nbsp;1.626&nbsp;&nbsp;&nbsp;&nbsp;1.626&nbsp;timers.py:96(expensive_function)  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;0.000&nbsp;&nbsp;&nbsp;&nbsp;0.000&nbsp;&nbsp;&nbsp;&nbsp;0.000&nbsp;&nbsp;&nbsp;&nbsp;0.000&nbsp;{method&nbsp;'disable'&nbsp;of&nbsp;'_lsprof.Profiler'&nbsp;objects}</pre>你可以看到，它给出了不同函数的调用次数，但它遗漏了一些关键的信息：是哪个函数让运行这么慢？<br />可是，这对于基础优化来说是个好的开始。有时候甚至能用更少的精力找到解决方案。我经常用它来在深入挖掘究竟是哪个函数慢或者调用次数过多之前来调试程序。<br /><ul><li>内建优点：没有额外的依赖并且非常快。对于快速的高等级检查非常有用。</li></ul><ul><li>内建缺点：信息相对有限，需要进一步的调试；报告有点不太直接，尤其是对于复杂的代码。</li></ul><h3>Line Profiler</h3>如果内建的优化器是一门大炮，那么<span style="font-family: Times New Roman;">line profiler</span><span style="font-family: 宋体;">可以看作是一门离子加农炮。它非常的重量级和强大。</span><br />在这个例子里，我们会用非常棒的<span style="font-family: Times New Roman;">line_profiler</span><span style="font-family: 宋体;">库。为了容易使用，我们会再次用装饰器包装一下，这种简单的方法也可以防止把它放在生产代码里。</span><br /><pre>try:  &nbsp;&nbsp;&nbsp;&nbsp;from&nbsp;line_profiler&nbsp;import&nbsp;LineProfiler    &nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;do_profile(follow=[]):  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;inner(func):  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;profiled_func(*args,&nbsp;**kwargs):  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;try:  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;profiler&nbsp;=&nbsp;LineProfiler()  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;profiler.add_function(func)  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;f&nbsp;in&nbsp;follow:  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;profiler.add_function(f)  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;profiler.enable_by_count()  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;func(*args,&nbsp;**kwargs)  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;finally:  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;profiler.print_stats()  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;profiled_func  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;inner    except&nbsp;ImportError:  &nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;do_profile(follow=[]):  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;"Helpful&nbsp;if&nbsp;you&nbsp;accidentally&nbsp;leave&nbsp;in&nbsp;production!"  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;inner(func):  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;nothing(*args,&nbsp;**kwargs):  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;func(*args,&nbsp;**kwargs)  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;nothing  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;inner    def&nbsp;get_number():  &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;xrange(5000000):  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;x    @do_profile(follow=[get_number])  def&nbsp;expensive_function():  &nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;get_number():  &nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;x&nbsp;^&nbsp;x&nbsp;^&nbsp;x  &nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;'some&nbsp;result!'    result&nbsp;=&nbsp;expensive_function()</pre>如果你运行上面的代码，你就可以看到一下的报告：<br /><pre>Timer&nbsp;unit:&nbsp;1e-06&nbsp;s    File:&nbsp;test.py  Function:&nbsp;get_number&nbsp;at&nbsp;line&nbsp;43  Total&nbsp;time:&nbsp;4.44195&nbsp;s    Line&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hits&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Time&nbsp;&nbsp;Per&nbsp;Hit&nbsp;&nbsp;&nbsp;%&nbsp;Time&nbsp;&nbsp;Line&nbsp;Contents  ==============================================================  &nbsp;&nbsp;&nbsp;&nbsp;43&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;get_number():  &nbsp;&nbsp;&nbsp;&nbsp;44&nbsp;&nbsp;&nbsp;5000001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2223313&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;50.1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;xrange(5000000):  &nbsp;&nbsp;&nbsp;&nbsp;45&nbsp;&nbsp;&nbsp;5000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2218638&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.4&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;49.9&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;yield&nbsp;x    File:&nbsp;test.py  Function:&nbsp;expensive_function&nbsp;at&nbsp;line&nbsp;47  Total&nbsp;time:&nbsp;16.828&nbsp;s    Line&nbsp;#&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Hits&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;Time&nbsp;&nbsp;Per&nbsp;Hit&nbsp;&nbsp;&nbsp;%&nbsp;Time&nbsp;&nbsp;Line&nbsp;Contents  ==============================================================  &nbsp;&nbsp;&nbsp;&nbsp;47&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;def&nbsp;expensive_function():  &nbsp;&nbsp;&nbsp;&nbsp;48&nbsp;&nbsp;&nbsp;5000001&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;14090530&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2.8&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;83.7&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;for&nbsp;x&nbsp;in&nbsp;get_number():  &nbsp;&nbsp;&nbsp;&nbsp;49&nbsp;&nbsp;&nbsp;5000000&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;2737480&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.5&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;16.3&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;i&nbsp;=&nbsp;x&nbsp;^&nbsp;x&nbsp;^&nbsp;x  &nbsp;&nbsp;&nbsp;&nbsp;50&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;1&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;0.0&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;return&nbsp;'some&nbsp;result!'</pre>你可以看到，有一个非常详细的报告，能让你完全洞悉代码运行的情况。不想内建的<span style="font-family: Times New Roman;">cProfiler</span><span style="font-family: 宋体;">，它能计算话在语言核心特性的时间，比如循环和导入并且给出在不同的行花费的时间。</span><br />这些细节能让我们更容易理解函数内部。如果你在研究某个第三方库，你可以直接将其导入并加上装饰器来分析它。<br />一些小技巧：只装饰你的测试函数并将问题函数作为接下来的参数。<br /><ul><li>Line Profiler <span style="font-family: 宋体;">优点：有非常直接和详细的报告。能够追踪第三方库里的函数。</span></li></ul><ul><li>Line Profiler <span style="font-family: 宋体;">缺点：因为它会让代码比真正运行时慢很多，所以不要用它来做基准测试。这是额外的需求。</span></li></ul><h3>总结和最佳实践</h3>你应该用更简单的工具来对测试用例进行根本的检查，并且用更慢但能显示更多细节的<span style="font-family: Times New Roman;">line_profiler</span><span style="font-family: 宋体;">来深入到函数内部。</span><br />九成情况下，你可能会发现在一个函数里循环调用或一个错误的数据结构消耗了<span style="font-family: Times New Roman;">90%</span><span style="font-family: 宋体;">的时间。一些调整工具是非常适合你的。</span><br />如果你仍然觉得这太慢，而是用一些你自己的秘密武器，如比较属性访问技术或调整平衡检查技术。你也可以用如下的方法：<br />1．忍受缓慢或者缓存它们<br />2．重新思考整个实现<br />3．更多使用优化的数据结构<br />4．写一个<span style="font-family: Times New Roman;">C</span><span style="font-family: 宋体;">扩展</span><br />注意了，优化代码是种罪恶的快感！用合适的方法来为你的<span style="font-family: Times New Roman;">Python</span><span style="font-family: 宋体;">代码加速很有意思，但是注意不要破坏了本身的逻辑。可读的代码比运行速度更重要。先把它缓存起来再进行优化其实更好。</span><br /><span style="font-family: 宋体;">原文链接： <a href="https://zapier.com/engineering/profiling-python-boss/" target="_blank">Bryan Helmig</a>&nbsp;&nbsp;&nbsp;翻译： <a href="http://blog.jobbole.com/" target="_blank"> 伯乐在线 </a> - <a href="http://blog.jobbole.com/author/fwg1989/" target="_blank">贱圣OMG</a><br />    译文链接： <a href="http://blog.jobbole.com/54057/" target="_blank">http://blog.jobbole.com/54057/</a></span></div>