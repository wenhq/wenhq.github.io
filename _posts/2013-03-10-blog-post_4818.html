---
layout: post
title: "前端模块化开发那点历史"
date: '2013-03-10T22:51:00.001+08:00'
author: Wenh Q
tags: 
modified_time: '2013-03-10T22:51:16.872+08:00'
blogger_id: tag:blogger.com,1999:blog-4961947611491238191.post-5120783015556982057
blogger_orig_url: http://binaryware.blogspot.com/2013/03/blog-post_4818.html
---

<a href="http://blog.jobbole.com/35528/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=%25e5%2589%258d%25e7%25ab%25af%25e6%25a8%25a1%25e5%259d%2597%25e5%258c%2596%25e5%25bc%2580%25e5%258f%2591%25e9%2582%25a3%25e7%2582%25b9%25e5%258e%2586%25e5%258f%25b2">前端模块化开发那点历史</a>: <br />来源：<a href="https://github.com/seajs/seajs/issues/588" rel="nofollow">玉伯也叫射雕</a><br />最近不断有人问及，想起前些天跟&nbsp;<a href="https://github.com/dexteryy">@dexteryy</a>&nbsp;等人的讨论：<a href="https://github.com/dexteryy/OzJS/issues/10" title="对 OzJS 的一些疑惑、建议与探讨">dexteryy/OzJS#10</a>&nbsp;当时有过简单总结，重新梳理如下。<br /><h2>写在前面</h2><ol><li><b>不谈什么</b>：传统的模块化开发方式，比如文件拆分、全局变量、命名空间，以及 YUI3 式的模块化开发方式。有兴趣的可阅读：<a href="https://github.com/seajs/seajs/issues/547" title="前端模块化开发的价值">#547</a></li><li><b>谈什么</b>： 关于 CommonJS、AMD、<a href="http://blog.jobbole.com/1254/" title="Node.js 究竟是什么？">Node.js</a>、CMD 等相关的故事与未来趋势，很有意思。</li><li><b>不一定精准</b>：本文是基于史实的扯淡，因此部分文字特别是时间都是模糊记忆，不一定精准。关于流派、趋势则是个人在社区的感受，不代表客观看法。（看法都是主观的，呵呵）</li></ol><h2>CommonJS 社区</h2>大概 09 年 – 10 年期间，<a href="http://wiki.commonjs.org/wiki/CommonJS">CommonJS</a>&nbsp;社区大牛云集。CommonJS 原来叫 ServerJS，推出&nbsp;<a href="http://wiki.commonjs.org/wiki/Modules">Modules/1.0</a>&nbsp;规范后，在 Node.js 等环境下取得了很不错的实践。<br />09年下半年这帮充满干劲的小伙子们想把 ServerJS 的成功经验进一步推广到<a href="http://blog.jobbole.com/12749/" title="浏览器">浏览器</a>端，于是将社区改名叫 CommonJS，同时激烈争论 Modules 的下一版规范。分歧和冲突由此诞生，逐步形成了三大流派：<br /><ol><li><b>Modules/1.x 流派</b>。这个观点觉得 1.x 规范已经够用，只要移植到浏览器端就好。要做的是新增&nbsp;<a href="http://wiki.commonjs.org/wiki/Modules/Transport">Modules/Transport</a>&nbsp;规范，即在浏览器上运行前，先通过转换工具将模块转换为符合 Transport 规范的代码。主流代表是服务端的开发人员。现在值得关注的有两个实现：越来越火的&nbsp;<a href="https://github.com/component/component">component</a>&nbsp;和走在前沿的&nbsp;<a href="https://github.com/square/es6-module-transpiler">es6 module transpiler</a>。</li><li><b>Modules/Async 流派</b>。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范。这个观点下的典型代表是&nbsp;<a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition">AMD</a>&nbsp;规范及其实现&nbsp;<a href="http://requirejs.org/">RequireJS</a>。这个稍后再细说。</li><li><b>Modules/2.0 流派</b>。这个观点觉得浏览器有自身的特征，不应该直接用 Modules/1.x 规范，但应该尽可能与 Modules/1.x 规范保持一致。这个观点下的典型代表是&nbsp;<a href="https://code.google.com/p/bravojs/">BravoJS</a>&nbsp;和 FlyScript 的作者。BravoJS 作者对 CommonJS 的社区的贡献很大，这份&nbsp;<a href="http://www.page.ca/~wes/CommonJS/modules-2.0-7/">Modules/2.0-draft</a>&nbsp;规范花了很多心思。FlyScript 的作者提出了&nbsp;<a href="http://wiki.commonjs.org/wiki/Modules/Wrappings">Modules/Wrappings</a>&nbsp;规范，这规范是 CMD 规范的前身。可惜的是 BravoJS 太学院派，FlyScript 后来做了自我阉割，将整个网站（flyscript.org）下线了。这个故事有点悲壮，下文细说。</li></ol><h2>AMD 与 RequireJS</h2>再来说 AMD 规范。真正的 AMD 规范在这里：<a href="http://wiki.commonjs.org/wiki/Modules/AsynchronousDefinition">Modules/AsynchronousDefinition</a>。AMD 规范一直没有被 CommonJS 社区认同，核心争议点如下：<br /><h3>执行时机有异议</h3>看代码<br />Modules/1.0:<br /><div><pre>var a = require("./a") // 执行到此处时，a.js 才同步下载并执行</pre></div>AMD:<br /><div><pre>define(["require"], function(require) {<br />  // 在这里，模块 a 已经下载并执行好<br />  // ...<br />  var a = require("./a") // 此处仅仅是取模块 a 的 exports<br /><br />})</pre></div>AMD 里提前下载 a.js 是浏览器的限制，没办法做到同步下载，这个社区都认可。<br />但执行，AMD 里是 Early Executing，Modules/1.0 里是第一次 require 时才执行。这个差异很多人不能接受，包括持 Modules/2.0 观点的也不能接受。<br />这个差异，也导致实质上 Node 的模块与 AMD 模块是无法共享的，存在潜在冲突。<br /><h3>模块书写风格有争议</h3>AMD 风格下，通过参数传入依赖模块，破坏了&nbsp;<b>就近声明</b>&nbsp;原则。比如：<br /><div><pre>define(["a", "b", "c", "d", "e", "f"], function(a, b, c, d, e, f) {<br /><br />    // 等于在最前面申明并初始化了要用到的所有模块<br /><br />   if (false) {<br />       // 即便压根儿没用到某个模块 b，但 b 还是提前执行了<br />       b.foo()<br />   }<br /><br />})</pre></div>还有就是 AMD 下 require 的用法，以及增加了全局变量 define 等细节，当时在社区被很多人不认可。<br />最后，AMD 从 CommonJS 社区独立了出去，单独成为了 AMD 社区。有阵子，CommonJS 社区还要求 RequireJS 的文档里，不能再打 CommonJS 的旗帜（这个 CommonJS 社区做得有点小气）。<br />脱离了 CommonJS 社区的 AMD 规范，实质上演化成了 RequireJS 的附属品。比如<br /><ol><li>AMD 规范里增加了对&nbsp;<a href="http://requirejs.org/docs/api.html#cjsmodule">Simplified CommonJS Wrapper</a>&nbsp;格式的支持。这个背后是因为 RequireJS 社区有很多人反馈想用 require 的方式，最后 RequireJS 作者妥协，才有了这个半残的 CJS 格式支持。（注意这个是伪支持，背后依旧是 AMD 的运行逻辑，比如提前执行。）</li><li>AMD 规范的演进，离不开 RequireJS。这有点像 IE…… 可能是我的偏见。</li></ol>AMD 的流行，很大程度上取决于 RequireJS 作者的推广，这有点像&nbsp;<a href="http://lesscss.org/">less</a>&nbsp;因 Bootstrap 而火起来一样。但火起来的东西未必好，比如个人觉得&nbsp;<a href="http://learnboost.github.com/stylus/">stylus</a>&nbsp;就比 less 更优雅好用。<br />关于 AMD 和 RequireJS，暂且按下不表。来看另一条暗流：Modules/2.0 流派。<br /><h2>Modules/2.0</h2>BravoJS 的作者 Wes Garland 有很深厚的程序功底，在 CommonJS 社区也非常受人尊敬。但 BravoJS 本身非常学院派，是为了论证 Modules/2.0-draft 规范而写的一个项目。学院派的 BravoJS 在实用派的 RequireJS 面前不堪一击，现在基本上只留存了一些美好的回忆。<br />这时，Modules/2.0 阵营也有一个实战派：FlyScript。FlyScript 抛去了 Modules/2.0 中的学究气，提出了非常简洁的<a href="http://wiki.commonjs.org/wiki/Modules/Wrappings">Modules/Wrappings</a>&nbsp;规范：<br /><div><pre>module.declare(function(require, exports, module)<br />{<br />   var a = require("a"); <br />   exports.foo = a.name; <br />});</pre></div>这个简洁的规范考虑了浏览器的特殊性，同时也尽可能兼容了 Modules/1.0 规范。悲催的是，FlyScript 在推出正式版和官网之后，RequireJS 当时正直红火。期间 FlyScript 作者 khs4473 和 RequireJS 作者 James Burke 有过一些争论。再后来，FlyScript 作者做了自我阉割，将 <a href="http://blog.jobbole.com/6492/" title="GitHub如何运作：时间并不决定一切">GitHub</a> 上的项目和官网都清空了，官网上当时留了一句话，模糊中记得是<br /><i><b>我会回来的，带着更好的东西。</b></i><br />这中间究竟发生了什么，不得而知。后来我有发邮件给 @khs4473 询问，khs 给了两点挺让我尊重的理由，大意是<br /><ol><li>我并非前端出身，RequireJS 的作者 James Burke 比我更懂浏览器。</li><li>我们应该协同起来推动一个社区的发展，即便它不是你喜欢的。</li></ol>这两句话对我影响很大。也是那之后，开始仔细研究 RequireJS，并通过邮件等方式给 RequireJS 提出过不少建议。<br />再后来，在实际使用 RequireJS 的过程中，遇到了很多坑。那时 RequireJS 虽然很火，但真不够完善。期间也在寻思着 FlyScript 离开时的那句话：“我会回来的，带着更好的东西”<br />我没 FlyScript 的作者那么伟大，在不断给 RequireJS 提建议，但不断不被采纳后，开始萌生了自己写一个 loader 的念头。<br />这就是 SeaJS。<br />SeaJS 借鉴了 RequireJS 的不少东西，比如将 FlyScript 中的&nbsp;<code>module.declare</code>&nbsp;改名为&nbsp;<code>define</code>&nbsp;等。SeaJS 更多地来自 Modules/2.0 的观点，但尽可能去掉了学院派的东西，加入了不少实战派的理念。<br /><h2>最后</h2>写着写着，有点沧桑感，不想写了。<br />历史不是过去，历史正在上演。随着 W3C 等规范、以及浏览器的飞速发展，前端的模块化开发会逐步成为基础设施。一切终究都会成为历史，未来会更好。<br /><h4>相关文章</h4><ul><li><a href="http://blog.jobbole.com/28904/"><img alt="使用 node.js 开发前端打包程序" height="150" src="http://blog.jobbole.com/wp-content/uploads/2012/09/NodeJS-150x150.jpg" width="150" /></a><a href="http://blog.jobbole.com/28904/">使用 node.js 开发前端打包程序</a></li><li><a href="http://blog.jobbole.com/8481/"><img alt="JavaScript初学者应注意的七个细节" src="http://blog.jobbole.com/wp-content/uploads/2011/06/javascript-logo.png" /></a><a href="http://blog.jobbole.com/8481/">JavaScript初学者应注意的七个细节</a></li><li><a href="http://blog.jobbole.com/8524/"><img alt="浏览器开发工具的25个秘密" height="150" src="http://blog.jobbole.com/wp-content/uploads/2011/11/25-Secrets-of-the-Browser-Developer-Tools1-150x150.png" width="150" /></a><a href="http://blog.jobbole.com/8524/">浏览器开发工具的25个秘密</a></li><li><a href="http://blog.jobbole.com/19203/"><img alt="网易邮箱前端Javascript编码规范：类规范" src="http://blog.jobbole.com/wp-content/uploads/2011/06/javascript-logo.png" /></a><a href="http://blog.jobbole.com/19203/">网易邮箱前端Javascript编码规范：类规范</a></li><li><a href="http://blog.jobbole.com/31178/"><img alt="sorter" height="150" src="http://blog.jobbole.com/wp-content/uploads/2012/12/sorter-150x150.png" width="150" /></a><a href="http://blog.jobbole.com/31178/">用Chrome开发者工具做JavaScript性能分析</a></li><li><a href="http://blog.jobbole.com/8087/"><img alt="Limu：JavaScript的那些书" src="http://blog.jobbole.com/wp-content/uploads/2011/11/book-logo.jpg" /></a><a href="http://blog.jobbole.com/8087/">Limu：JavaScript的那些书</a></li><li><a href="http://blog.jobbole.com/24424/"><img alt="日常工作与新技术" src="http://blog.jobbole.com/wp-content/uploads/2011/11/career-logo.jpg" /></a><a href="http://blog.jobbole.com/24424/">日常工作与新技术</a></li><li><a href="http://blog.jobbole.com/8406/"><img alt="Web开发者应掌握的12个Firebug技巧 " src="http://blog.jobbole.com/wp-content/uploads/2011/11/firebug-logo.png" /></a><a href="http://blog.jobbole.com/8406/">Web开发者应掌握的12个Firebug技巧 </a></li><li><a href="http://blog.jobbole.com/18758/"><img alt="前端工程师的编码遭遇战" src="http://blog.jobbole.com/wp-content/uploads/2011/10/web-develope-logo.jpg" /></a><a href="http://blog.jobbole.com/18758/">前端工程师的编码遭遇战</a></li><li><a href="http://blog.jobbole.com/30385/"><img alt="浏览器事件的思考" height="150" src="http://blog.jobbole.com/wp-content/uploads/2012/11/T1uqT.Xl8cXXb1upjX-150x150.jpg" width="150" /></a><a href="http://blog.jobbole.com/30385/">浏览器事件的思考</a></li></ul><a href="http://blog.jobbole.com/35528/">前端模块化开发那点历史</a>，首发于<a href="http://blog.jobbole.com/">博客 - 伯乐在线</a>。