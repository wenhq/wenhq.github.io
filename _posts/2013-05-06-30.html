---
layout: post
title: 30分钟泛型教程
date: '2013-05-06T18:29:00.001+08:00'
author: Wenh Q
tags: 
modified_time: '2013-05-06T18:29:05.639+08:00'
blogger_id: tag:blogger.com,1999:blog-4961947611491238191.post-6184396118030470483
blogger_orig_url: http://binaryware.blogspot.com/2013/05/30.html
---

<a href="http://blog.jobbole.com/39125/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=30%25e5%2588%2586%25e9%2592%259f%25e6%25b3%259b%25e5%259e%258b%25e6%2595%2599%25e7%25a8%258b">30分钟泛型教程</a>: <br />来源：<a href="http://www.cnblogs.com/liulun/archive/2013/05/02/3033599.html" rel="nofollow">liulun 的博客</a><br /><b>一、泛型入门：</b><br />我们先来看一个最为常见的泛型类型List&lt;T&gt;的定义<br /><br />(真正的定义比这个要复杂的多，我这里删掉了很多东西)<br /><div><pre>[Serializable]<br />public class List&lt;T&gt; : IList&lt;T&gt;, ICollection&lt;T&gt;, IEnumerable&lt;T&gt;<br />{<br />    public T this[int index] { get; set; }<br />    public void Add(T item);<br />    public void Clear();<br />    public bool Contains(T item);<br />    public int IndexOf(T item);<br />    public bool Remove(T item);<br />    public void Sort();<br />    public T[] ToArray();<br />}</pre></div>List后面紧跟着一个&lt;T&gt;表示它操作的是一个未指定的数据类型<br /><br />（T代表着一个未指定的数据类型）<br />可以把T看作一个变量名，T代表着一个类型，<br /><br />在List&lt;T&gt;的源代码中任何地方都能使用T<br />T被用作方法的参数和返回值<br /><br />Add方法接收T类型的参数，ToArray方法返回一个T类型的数组<br />注意：<br />泛型参数必须以T开头，要么就叫T，要么就叫TKey或者TValue；<br /><br />这跟接口要以I开头是一样的，这是约定。<br />下面来看一段使用泛型类型的代码<br /><div><pre>var a = new List&lt;int&gt;();<br />            a.Add(1);<br />            a.Add(2);<br />            //这是错误的，因为你已经指定了泛型类型为int，就不能在这个容器中放入其他的值<br />            //这是编译器错误，更提升了排错效率，如果是运行期错误，不知道要多么烦人<br />            a.Add("3");<br />            var item = a[2];</pre></div>请注意上面代码里的注释<br /><b>二、泛型的作用(1)：</b><br />作为<a href="http://blog.jobbole.com/821/" title="程序员的本质">程序员</a>，写代码时刻不忘代码重用。<br /><br />代码重用可以分成很多类，其中<b>算法重用</b>就是非常重要的一类<br />假设你要为一组整型数据写一个<a href="http://blog.jobbole.com/11745/" title="排序算法">排序算法</a>，又要为一组浮点型数据写一个排序算法<br /><br />如果没有泛型类型，你会怎么做呢？<br />你可能想到了方法的重载<br /><br />写两个同名方法，一个方法接收整型数组，另一个方法接收浮点型的数组<br />但有了泛型，你就完全不必这么做，只要设计一个方法就够用了，你甚至可以用这个方法为一组字符串数据排序<br /><b>三、泛型的作用(2)：</b><br />假设你是一个方法的设计者，<br /><br />这个方法需要有一个输入参数，但你并能确定这个输入参数的类型<br /><br />那么你会怎么做呢？<br />有一部分人可能会马上反驳：“不可能有这种时候！”<br /><br />那么我会跟你说，编程是一门经验型的工作，你的经验还不够，还没有碰到过类似的地方。<br />另一部分人可能考虑把这个参数的类型设置成Object的<br /><br />这确实是一种可行的方案<br /><br />但会造成下面两个问题<br />如果我给这个方法传递整形的数据<br /><br />（值类型的数据都一样）<br /><br />就会产生额外的装箱、拆箱操作<br /><br />造成<b>性能损耗</b><br />如果你这个方法里的处理逻辑不适用于字符串的参数<br /><br />而使用者又传了一个字符串进来<br /><br />编译器是不会报错的，<br /><br />只有在运行期才会报错<br /><br />(如果质管部门没有测出这个运行期BUG，那么不知道要造成多大的损失呢)<br /><br />这就是我们常说的：<b>类型不安全</b><br /><b>四、泛型的示例：</b><br />像List&lt;T&gt;和Dictionary&lt;TKey,TValue&gt;之类的泛型类型我们经常用到<br /><br />下面我介绍几个不常用到的泛型类型<br />ObservableCollection&lt;T&gt;<br /><br />当这个集合发生改变后会有相应的事件得到通知<br /><br />请看如下代码：<br /><div><pre>static void Main(string[] args)<br />{<br />    var a = new ObservableCollection&lt;int&gt;();<br />    a.CollectionChanged += a_CollectionChanged;<br />}<br /><br />static void a_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)<br />{<br />    //可以通过Action来判断是什么操作触发了事件<br />    //e.Action == NotifyCollectionChangedAction.Add<br /><br />    //可以根据以下两个属性来得到更改前和更改后的内容<br />    //e.NewItems;<br />    //e.OldItems;<br />}</pre></div>使用这个集合需要引用如下两个名称空间<br /><div><pre>using System.Collections.ObjectModel;<br />using System.Collections.Specialized;</pre></div><br />BlockingCollection&lt;int&gt;是线程安全的集合<br /><br />来看看下面这段代码<br /><div><pre>var bcollec = new BlockingCollection&lt;int&gt;(2);<br />//试图添加1-50<br />Task.Run(() =&gt;<br />{<br />    //并行循环<br />    Parallel.For(1, 51, i =&gt;<br />    {<br />        bcollec.Add(i);<br />        Console.WriteLine("加入：" + i);<br />    });<br />});<br /><br />Thread.Sleep(1000);<br />Console.WriteLine("调用一次Take");<br />bcollec.Take();<br /><br />//等待无限长时间<br />Thread.Sleep(Timeout.Infinite);</pre></div>输出结果为：<br /><div><pre>加入：1<br />加入：37<br />调用一次Take<br />加入：13</pre></div>BlockingCollection&lt;int&gt;还可以设置CompleteAdding和IsCompleted属性来拒绝加入新元素<br /><br />.NET类库还提供了很多的泛型类型，在这里就不一一例举了<br /><b>五、泛型的继承：</b><br />在.net中一切都继承字Object<br /><br />泛型也不例外<br /><br />泛型类型可以继承自其他类型<br /><br />来看一下如下代码<br /><div><pre>public class MyType<br />{<br />    public virtual string getOneStr()<br />    {<br />        return "base object Str";<br />    }<br />}<br />public class MyOtherType&lt;T&gt; : MyType<br />{<br />    public override string getOneStr()<br />    {<br />        return typeof(T).ToString();<br />    }<br />}<br />class Program<br />{<br />    static void Main(string[] args)<br />    {<br />        MyType target = new MyOtherType&lt;int&gt;();<br />        Console.WriteLine(target.getOneStr());<br />        Console.ReadKey();<br />    }<br />}</pre></div>泛型类型MyOtherType&lt;T&gt;成功的重写了非泛型类型MyType的方法<br /><br />如果我试图按如下方式从MyOtherType&lt;T&gt;类型派生子类型就会导致编译器错误<br /><div><pre>//编译期错误<br />public class MyThirdType : MyOtherType&lt;T&gt;<br />{<br />}</pre></div>但是如果写成这种方式，就不会出错<br /><div><pre>public class MyThirdType : MyOtherType&lt;int&gt;<br />    {<br />        public override string getOneStr()<br />        {<br />            return "MyThirdType";<br />        }<br />    }</pre></div><b>注意：</b><br />如果按照如上写法，会造成类型不统一的问题<br /><br />如果一个方法接收MyThirdType类型的参数，<br /><br />那么不能将一个MyOtherType&lt;int&gt;的实例传递给这个方法<br /><br />然而一个方法如果接收MyOtherType&lt;int&gt;类型的参数<br /><br />却可以把MyThirdType类型的实例传递给这个方法<br /><br />这是CLR内部实现机制造成的<br /><br />这看起来确实很怪异！<br />写成如下方式也不会出错<br /><div><pre>public class MyThirdType&lt;T&gt; : MyOtherType&lt;T&gt;<br />    {<br />        public override string getOneStr()<br />        {<br />            return typeof(T).ToString() + " from MyThirdType";<br />        }<br />    }</pre></div>此中诀窍，只可意会，不可言传<br /><b>六、泛型接口</b><br />.NET类库里有很多泛型的接口<br /><br />比如：IEnumerator&lt;T&gt;、IList&lt;T&gt;等<br /><br />这里不对这些接口做详细描述了<br /><br />值说说为什么要有泛型接口。<br />其实泛型接口出现的原因和泛型出现的原因类似<br /><br />拿IComparable这个接口来说，<br /><br />此接口只描述了一个方法：<br /><div><pre>int CompareTo(object obj);</pre></div>大家看到，如果是值类型的参数，势必会导致装箱和拆箱操作<br /><br />同时，也不是强类型的，不能在编译期确定参数的类型<br /><br />有了IComparable&lt;T&gt;就解决掉这个问题了<br /><div><pre>int CompareTo(T other);</pre></div><b>七、泛型委托</b><br />委托描述方法，<br /><br />泛型委托的由来和泛型接口类似<br />定义一个泛型委托也比较简单：<br /><div><pre>public delegate void MyAction&lt;T&gt;(T obj);</pre></div>这个委托描述一类方法<br /><br />这类方法接收T类型的参数，没有返回值<br /><br />来看看使用这个委托的方法<br /><div><pre>public delegate void MyAction&lt;T&gt;(T obj);<br />static void Main(string[] args)<br />{<br />    var method = new MyAction&lt;int&gt;(printInt);<br />    method(3);<br />    Console.ReadKey();<br />}<br />static void printInt(int i)<br />{<br />    Console.WriteLine(i);<br />}</pre></div>由于定义委托比较繁琐<br /><br />.NET类库在System名称空间，下定义了三种比较常用的泛型委托<br />Predicate&lt;T&gt;委托：<br /><div><pre>public delegate bool Predicate&lt;T&gt;(T obj);</pre></div>这个委托描述的方法为接收一个T类型的参数，返回一个BOOL类型的值，一般用于比较方法<br />Action&lt;T&gt;委托<br /><div><pre>public delegate void Action&lt;T&gt;(T obj);</pre></div><div><pre>public delegate void Action&lt;T1, T2&gt;(T1 arg1, T2 arg2);</pre></div>这个委托描述的方法，接收一个或多个T类型的参数（最多16个，我这里只写了两种类型的定义方式），没有返回值<br />Func&lt;T&gt;委托<br /><div><pre>public delegate TResult Func&lt;TResult&gt;();</pre></div><div><pre>public delegate TResult Func&lt;T, TResult&gt;(T arg);</pre></div>这个委托描述的方法，接收零个或多个T类型的参数（最多16个，我这里只写了两种类型的定义方式），<br /><br />与Action委托不同的是，它有一个返回值，返回值的类型为TResult类型的<br />关于委托的描述，您还可以看我这篇文章<br /><br /><a href="http://www.cnblogs.com/liulun/archive/2013/02/26/2909985.html">30分钟LINQ教程</a><br /><b>八、泛型方法</b><br />泛型类型中的T可以用在这个类型的任何地方<br /><br />然而有些时候，我们不希望在使用类型的时候就指定T的类型<br /><br />我们希望在使用这个类型的方法时，再指定T的类型<br /><br />来看看如下代码：<br /><div><pre>public class MyClass<br />    {<br />        public TParam CompareTo&lt;TParam&gt;(TParam other)<br />        {<br />            Console.WriteLine(other.ToString());<br />            return other;<br />        }<br />    }</pre></div>上面的代码中MyClass并不是一个泛型类型<br /><br />但这个类型中的CompareTo&lt;TParam&gt;()却是一个泛型方法<br /><br />TParam可以用在这个方法中的任何地方。<br />使用泛型方法一般用如下代码就可以了：<br /><div><pre>obj.CompareTo&lt;int&gt;(4);<br />obj.CompareTo&lt;string&gt;("ddd");</pre></div>然而，你可以写的更简单一些，写成如下的方式<br /><div><pre>obj.CompareTo(2);<br />obj.CompareTo("123");</pre></div>有人会问：“这不可能，没有指定CompareTo方法的TParam类型，肯定会编译出错的”<br /><br />我告诉你：不会的，编译器可以帮你完成<b>类型推断</b>的工作。<br /><b>注意：</b><br /><br />如果你为一个方法指定了两个泛型参数，而且这两个参数的类型都是T，<br /><br />那么如果你想使用类型推断，你必须传递两个相同类型的参数给这个方法<br /><br />不能一个参数用string类型，另一个用object类型，这会导致编译错误。<br /><b>九、泛型约束</b><br />我们设计了一个泛型类型<br /><br />很多时候，我们不希望使用者传入任意类型的参数<br /><br />也就是说，我们希望“约束”一下T的类型<br /><br />来看看如下代码：<br /><div><pre>public class MyClass&lt;T&gt; where T : IComparable&lt;T&gt;<br />    {<br />        public int CompareTo(T other)<br />        {<br />            return 0;<br />        }<br />    }</pre></div>上面的代码要求T类型必须实现了IComparable&lt;T&gt;接口<br /><br />如你所见：泛型的约束通过关键字where来实现。<br />泛型方法当然也可以通过类似的方式对泛型参数进行约束<br /><br />请看如下代码<br /><div><pre>public class MyClass<br />{<br />    public TParam CompareTo&lt;TParam&gt;(TParam other) where TParam:class<br />    {<br />        Console.WriteLine(other.ToString());<br />        return other;<br />    }<br />}</pre></div>上面代码中用了class关键字约束泛型参数TParam；具体稍后解释。<br /><b>注意1：</b><br /><br />如果我有一个类型也定义为MyClass&lt;T&gt;但没有做约束，<br /><br />那么这个时候，做过约束的MyClass&lt;T&gt;将与没做约束的MyClass&lt;T&gt;冲突，编译无法通过<b></b><br />注意2：<br /><br />当你重写一个泛型方法时，如果这个方法指定了约束<br /><br />在重写这个方法时，不能再指定约束了<b></b><br />注意3：<br /><br />虽然我上面的例子写的是接口约束，但你完全可以写一个类型，比如说BaseClass<br /><br />而且，只要是继承自BaseClass的类型都可以当作T类型使用，你不要试图约束T为Object类型，编译不会通过的。（傻子才这么干）<b></b><br />注意4：<br /><br />有两个特殊的约束：class和struct。<br /><br />where T : class &nbsp; 约束T类型必须为引用类型<br /><br />where T : struct &nbsp;约束T类型必须为值类型<b></b><br />注意5：<br /><br />如果你没有对T进行class约束，<br /><br />那么你不能写这样的代码：T obj = null; &nbsp;这无法通过编译，因为T有可能是值类型的。<br /><br />如果你没有对T进行struct约束，也没有对T进行new约束<br /><br />那么你不能写这样的代码：T obj = new T(); &nbsp;这无法通过编译，因为值类型肯定有无参数构造器，而引用类型就不一定了。<br /><br />如果你对T进行了new约束：where T : new(); &nbsp;那么new T()就是正确的，因为new约束要求T类型有一个公共无参构造器。<br /><b>注意6：<br /><br /></b>就算没有对T进行任何约束，也有一个办法来处理值类型和引用类型的问题<br /><br />T temp = default(T);<br /><br />如果T为引用类型，那么temp就是null；如果T为值类型，那么temp就是0；<br /><b>注意7：<br /><br /></b>试图对T类型的变量进行强制转化，一般情况下会报编译期错误。<br /><br />但你可以先把T转化成object再把object转化成你要的类型（一般不推荐这么做，你应该考虑把T转化成一个约束兼容的类型）<br /><br />你也可以考虑用as操作符进行类型转化，这一般不会报错，但只能转化成引用类型。<br />关于泛型约束的内容，我在这篇文章里也有提到<br /><br /><a href="http://www.cnblogs.com/liulun/archive/2013/02/26/2909985.html">30分钟linq教程</a><br /><b>十、逆变和协变</b><br />一般情况下，我们使用泛型时，由T标记的泛型类型是不能更改的<br /><br />也就是说,如下两种写法都是错误的<br /><div><pre>var a = new List&lt;object&gt;();<br />List&lt;string&gt; b = a;<br />var c = new List&lt;string&gt;();<br />List&lt;object&gt; d = c;</pre></div>注意：这里没有写强制转换，即使写了强制转换也是错误的，编译就无法通过<br />然而泛型提供了逆变和协变的特性，<br /><br />有了这两种特性，这种转换就成为了可能。<br /><b>逆变：</b><br /><br />泛型类型T可以从基类型更改为该类的派生类型，<br /><br />用in关键字标记逆变形式的类型参数，<br /><br />而且这个参数一般作输入参数。<br /><b>协变：</b><br /><br />泛型类型T可以从派生类型更改为它的基类型，<br /><br />用out关键字来标记协变形式的类型参数，<br /><br />而且这个参数一般作为返回值<br />如果我们定义了一个这样的委托：<br /><div><pre>public delegate TResult MyAction&lt;in T,out TResult&gt;(T obj);</pre></div>那么，就可以让如下代码通过编译（不用强制转换）<br /><div><pre>var a = new MyAction&lt;object, ArgumentException&gt;(o =&gt; new ArgumentException(o.ToString()));<br />MyAction&lt;string, Exception&gt; b = a;</pre></div>这就是逆变和协变的威力。<br /><b>参考资料</b><br /><a href="http://www.cnblogs.com/mgen/archive/2012/03/15/2397191.html">Mgen的博客</a><br /><br />CLR VIA C#(第三版)<br /><b>修改记录：</b><br />2013.4.21完成了一半的内容<br />2013.4.28完成了全部内容，修改了一些错别字<br />2013.4.29增加了一大部分内容，修改了排版样式<br /><br /><h4>相关文章</h4><ul><li><a href="http://blog.jobbole.com/23939/"><img alt="Java对象初始化详解" src="http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg" /></a><a href="http://blog.jobbole.com/23939/">Java对象初始化详解</a></li><li><a href="http://blog.jobbole.com/28297/"><img alt="Java多线程发展简史" height="150" src="http://blog.jobbole.com/wp-content/uploads/2012/09/image_thumb10-150x150.png" width="150" /></a><a href="http://blog.jobbole.com/28297/">Java多线程发展简史</a></li><li><a href="http://blog.jobbole.com/36088/"><img alt="你可能不知道的陷阱：C#委托和事件的困惑" height="150" src="http://blog.jobbole.com/wp-content/uploads/2013/03/96-150x150.jpg" width="150" /></a><a href="http://blog.jobbole.com/36088/">你可能不知道的陷阱：C#委托和事件的困惑</a></li><li><a href="http://blog.jobbole.com/30596/"><img alt="对几个软件开发传统观点的质疑和反驳" height="150" src="http://blog.jobbole.com/wp-content/uploads/2012/11/traditional-software-development-150x150.jpg" width="150" /></a><a href="http://blog.jobbole.com/30596/">对几个软件开发传统观点的质疑和反驳</a></li><li><a href="http://blog.jobbole.com/39006/"><img alt="Java 8 的新特性和改进总览" src="http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg" /></a><a href="http://blog.jobbole.com/39006/">Java 8 的新特性和改进总览</a></li><li><a href="http://blog.jobbole.com/22288/"><img alt="github 404 page" height="150" src="http://blog.jobbole.com/wp-content/uploads/2012/09/github-404-page-150x150.jpg" width="150" /></a><a href="http://blog.jobbole.com/22288/">从测试300万个超链接接学到的</a></li><li><a href="http://blog.jobbole.com/20400/"><img alt="理解ThreadLocal" src="http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg" /></a><a href="http://blog.jobbole.com/20400/">理解ThreadLocal</a></li><li><a href="http://blog.jobbole.com/18571/"><img alt="Java程序员面试中的多线程问题" src="http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg" /></a><a href="http://blog.jobbole.com/18571/">Java程序员面试中的多线程问题</a></li><li><a href="http://blog.jobbole.com/844/"><img alt="异常的代价" src="http://blog.jobbole.com/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/14.jpg" /></a><a href="http://blog.jobbole.com/844/">异常的代价</a></li><li><a href="http://blog.jobbole.com/38718/"><img alt="如何编码实现内存泄露" src="http://blog.jobbole.com/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/6.jpg" /></a><a href="http://blog.jobbole.com/38718/">如何编码实现内存泄露</a></li></ul><a href="http://blog.jobbole.com/39125/">30分钟泛型教程</a>，首发于<a href="http://blog.jobbole.com/">博客 - 伯乐在线</a>。