--- 
layout: post 
title: Java的内存回收机制 
date:'2013-03-31T20:13:00.001+08:00' 
author: Wenh Q
tags:
modified\_time: '2013-03-31T20:13:54.075+08:00' 
blogger\_id: tag:blogger.com,1999:blog-4961947611491238191.post-7395013572631362959
blogger\_orig\_url: http://binaryware.blogspot.com/2013/03/java.html
---
<div
style="margin: 0px 2px; padding-top: 1px;    background-color: #c3d9ff; font-size: 1px !important;    line-height: 0px !important;">

 

</div>

<div
style="margin: 0px 1px; padding-top: 1px;    background-color: #c3d9ff; font-size: 1px !important;    line-height: 0px !important;">

 

</div>

<div style="padding: 4px; background-color: #c3d9ff;">

### Quantum 通过 Google 阅读器发送给您的内容： {#quantum-通过-google-阅读器发送给您的内容 style="margin:0px 3px;font-family:sans-serif"}

</div>

<div
style="margin: 0px 1px; padding-top: 1px;    background-color: #c3d9ff; font-size: 1px !important;    line-height: 0px !important;">

 

</div>

<div
style="margin: 0px 2px; padding-top: 1px;    background-color: #c3d9ff; font-size: 1px !important;    line-height: 0px !important;">

 

</div>

<div
style="font-family:sans-serif;overflow:auto;width:100%;margin: 0px 10px">

 {#section style="margin: 0.25em 0 0 0"}

<div>

[Java的内存回收机制](http://blog.jobbole.com/37273/?utm_source=rss&utm_medium=rss&utm_campaign=java%25e7%259a%2584%25e5%2586%2585%25e5%25ad%2598%25e5%259b%259e%25e6%2594%25b6%25e6%259c%25ba%25e5%2588%25b6)

</div>

<div style="margin-bottom: 0.5em">

于 13-3-31 通过 [博客 - 伯乐在线](http://blog.jobbole.com){.f}
作者：童海波

</div>



来源
[小学徒的成长历程](http://www.cnblogs.com/xiaoxuetu/archive/2013/03/29/2987805.html)

在Java中，它的内存管理包括两方面：内存分配（创建Java对象的时候）和内存回收，这两方面工作都是由JVM自动完成的，降低了Java<span>[程序员](http://blog.jobbole.com/821/ "程序员的本质")</span>的学习难度，避免了像C/C++直接操作内存的危险。但是，也正因为内存管理完全由JVM负责，所以也使Java很多程序员不再关心内存分配，导致很多程序低效，耗内存。因此就有了Java程序员到最后应该去了解JVM，才能写出更高效，充分利用有限的内存的程序。

**1.Java在内存中的状态**

首先我们先写一个代码为例子：

Person.java

    package test;    import java.io.Serializable;    public class Person implements Serializable {        static final long serialVersionUID = 1L;        String name; // 姓名            Person friend;    //朋友        public Person() {}            public Person(String name) {          super();          this.name = name;      }  }

Test.java

    package test;      public class Test{        public static void main(String[] args) {          Person p1 = new Person("Kevin");          Person p2 = new Person("Rain");          Person p3 = new Person("Sunny");                    p1.friend = p2;          p3 = p2;          p2 = null;      }  }

把上面Test.java中main方面里面的对象引用画成一个从main方法开始的对象引用图的话就是这样的（顶点是对象和引用，有向边是引用关系）：

[![Java的内存回收机制](http://blog.jobbole.com/wp-content/uploads/2013/03/download.png "Java的内存回收机制")](http://blog.jobbole.com/wp-content/uploads/2013/03/download.png "Java的内存回收机制")

当程序运行起来之后，把它在内存中的状态看成是有向图后，可以分为三种：

1）**可达状态**：在一个对象创建后，有一个以上的引用变量引用它。在有向图中可以从起始顶点导航到该对象，那它就处于可达状态。

2）**可恢复状态**：如果程序中某个对象不再有任何的引用变量引用它，它将先进入可恢复状态，此时从有向图的起始顶点不能再导航到该对象。在这个状态下，系统的垃圾回收机制准备回收该对象的所占用的内存，在回收之前，系统会调用finalize()方法进行资源清理，如果资源整理后重新让一个以上引用变量引用该对象，则这个对象会再次变为可达状态；否则就会进入不可达状态。

3）**不可达状态**：当对象的所有关联都被切断，且系统调用finalize()方法进行资源清理后依旧没有使该对象变为可达状态，则这个对象将永久性失去引用并且变成不可达状态，系统才会真正的去回收该对象所占用的资源。

上述三种状态的转换图如下：

[![Java的内存回收机制](http://blog.jobbole.com/wp-content/uploads/2013/03/download-1.png "Java的内存回收机制")](http://blog.jobbole.com/wp-content/uploads/2013/03/download-1.png "Java的内存回收机制")

**2.Java对对象的4种引用**

1）**强引用** ：创建一个对象并把这个对象直接赋给一个变量，eg ：Person
person = new
Person("sunny"); 不管系统资源有么的紧张，强引用的对象都绝对不会被回收，即使他以后不会再用到**。**

2）**软引用** ：通过SoftReference类实现，eg :
SoftReference&lt;Person&gt; p = new SoftReference&lt;Person&gt;(new
Person("Rain"));,内存非常紧张的时候会被回收，其他时候不会被回收，所以在使用之前要判断是否为null从而判断他是否已经被回收了。

3）**弱引用 **：通过WeakReference类实现，eg :
WeakReference&lt;Person&gt; p = new WeakReference&lt;Person&gt;(new
Person("Rain"));不管内存是否足够，系统垃圾回收时必定会回收。

4）**虚引用 **：不能单独使用，主要是用于追踪对象被垃圾回收的状态。通过PhantomReference类和引用队列ReferenceQueue类联合使用实现，eg
：

    package test;    import java.lang.ref.PhantomReference;  import java.lang.ref.ReferenceQueue;      public class Test{        public static void main(String[] args) {          //创建一个对象          Person person = new Person("Sunny");              //创建一个引用队列              ReferenceQueue<Person> rq = new ReferenceQueue<Person>();          //创建一个虚引用，让此虚引用引用到person对象          PhantomReference<Person> pr = new PhantomReference<Person>(person, rq);          //切断person引用变量和对象的引用          person = null;          //试图取出虚引用所引用的对象          //发现程序并不能通过虚引用访问被引用对象，所以此处输出为null          System.out.println(pr.get());          //强制垃圾回收          System.gc();          System.runFinalization();          //因为一旦虚引用中的对象被回收后，该虚引用就会进入引用队列中          //所以用队列中最先进入队列中引用与pr进行比较，输出true          System.out.println(rq.poll() == pr);      }  }

运行结果：

[![Java的内存回收机制](http://blog.jobbole.com/wp-content/uploads/2013/03/download-2.png "Java的内存回收机制")](http://blog.jobbole.com/wp-content/uploads/2013/03/download-2.png "Java的内存回收机制")

**3.Java垃圾回收机制**

其实Java垃圾回收主要做的是两件事：1）内存回收 2）碎片整理

**3.1垃圾回收算法**

1）**串行回收（只用一个CPU）和并行回收（多个CPU才有用）**：串行回收是不管系统有多少个CPU，始终只用一个CPU来执行垃圾回收操作，而并行回收就是把整个回收工作拆分成多个部分，每个部分由一个CPU负责，从而让多个CPU并行回收。并行回收的执行效率很高，但复杂度增加，另外也有一些副作用，如内存随便增加。

2）**并发执行和应用程序停止 **：应用程序停止（Stop-the-world）顾名思义，其垃圾回收方式在执行垃圾回收的同时会导致应用程序的暂停。并发执行的垃圾回收虽然不会导致应用程序的暂停，但由于并发执行垃圾需要解决和应用程序的执行冲突（应用程序可能在垃圾回收的过程修改对象），因此并发执行垃圾回收的系统开销比Stop-the-world高，而且执行时需要更多的堆内存。

3）**压缩和不压缩和复制 ：**

①支持压缩的垃圾回收器**（标记-压缩
= 标记清除+压缩）**会把所有的可达对象搬迁到一起，然后将之前占用的内存全部回收，减少了内存碎片。

②不压缩的垃圾回收器**（标记-清除）**要遍历两次，第一次先从跟开始访问所有可达对象，并将他们标记为可达状态，第二次便利整个内存区域，对未标记可达状态的对象进行回收处理。这种回收方式不压缩，不需要额外内存，但要两次遍历，会产生碎片

③**复制**式的垃圾回收器：将堆内存分成两个相同空间，从根（类似于前面的有向图起始顶点）开始访问每一个关联的可达对象，将空间A的全部可达对象复制到空间B，然后一次性回收空间A。对于该算法而言，因为只需访问所有的可达对象，将所有的可达对象复制走之后就直接回收整个空间，完全不用理会不可达对象，所以遍历空间的成本较小，但需要巨大的复制成本和较多的内存。

[![Java的内存回收机制](http://blog.jobbole.com/wp-content/uploads/2013/03/download-3.png "Java的内存回收机制")](http://blog.jobbole.com/wp-content/uploads/2013/03/download-3.png "Java的内存回收机制")

**3.2堆内存的分代回收**

**1）分代回收的依据：**

**①对象生存时间的长短：**大部分对象在Young期间就被回收

**②不同代采取不同的垃圾回收策略：**新（生存时间短）老（生存时间长）对象之间很少存在引用

**2) 堆内存的分代：**

**①Young代 ：**

Ⅰ回收机制 ：因为对象数量少，所以采用复制回收。

Ⅱ组成区域
：由1个Eden区和2个Survivor区构成，同一时间的两个Survivor区，一个用来保存对象，另一个是空的；每次进行Young代垃圾回收的时候，就把Eden，From中的可达对象复制到To区域中，一些生存时间长的就复制到了老年代，接着清除Eden，From空间，最后原来的To空间变为From空间，原来的From空间变为To空间。

Ⅲ对象来源
：绝大多数对象先分配到Eden区，一些大的对象会直接被分配到Old代中。

Ⅳ回收频率
：因为Young代对象大部分很快进入不可达状态，因此回收频率高且回收速度快

[![Java的内存回收机制](http://blog.jobbole.com/wp-content/uploads/2013/03/download-4.png "Java的内存回收机制")](http://blog.jobbole.com/wp-content/uploads/2013/03/download-4.png "Java的内存回收机制") 
       
 [![Java的内存回收机制](http://blog.jobbole.com/wp-content/uploads/2013/03/download-5.png "Java的内存回收机制")](http://blog.jobbole.com/wp-content/uploads/2013/03/download-5.png "Java的内存回收机制")

**②Old代 ：**

Ⅰ回收机制 ：采用标记压缩算法回收。

Ⅱ对象来源 ：1.对象大直接进入老年代。

2.Young代中生存时间长的可达对象

Ⅲ回收频率
：因为很少对象会死掉，所以执行频率不高，而且需要较长时间来完成。

**③Permanent代 ：**

Ⅰ用      途 ：用来装载Class，方法等信息，默认为64M，不会被回收

Ⅱ对象来源
：eg：对于像Hibernate，Spring这类喜欢AOP动态生成类的框架，往往会生成大量的动态代理类，因此需要更多的Permanent代内存。所以我们经常在调试Hibernate，Spring的时候经常遇到java.lang.OutOfMemoryError:PermGen
space的错误，这就是Permanent代内存耗尽所导致的错误。

Ⅲ回收频率 ：不会被回收

**3.3常见的垃圾回收器**

**1）串行回收器**（只使用一个CPU）：Young代采用串行复制算法；Old代使用串行标记压缩算法（三个阶段：标记mark—清除sweep—压缩compact），回收期间程序会产生暂停，

**2）并行回收器**：对Young代采用的算法和串行回收器一样，只是增加了多CPU并行处理； 对Old代的处理和串行回收器完全一样，依旧是单线程。

**3）并行压缩回收器**：对Young代处理采用与并行回收器完全一样的算法；只是对Old代采用了不同的算法，其实就是划分不同的区域，然后进行标记压缩算法：

① 将Old代划分成几个固定区域；

② mark阶段（多线程并行），标记可达对象；

③
summary阶段（串行执行），从最左边开始检验知道找到某个达到数值（可达对象密度小）的区域时，此区域及其右边区域进行压缩回收，其左端为密集区域

④
compact阶段（多线程并行），识别出需要装填的区域，多线程并行的把数据复制到这些区域中。经此过程后，Old代一端密集存在大量活动对象，另一端则存在大块空间。

**4）并发标识—清理回收（CMS）**：对Young代处理采用与并行回收器完全一样的算法；只是对Old代采用了不同的算法，但归根待地还是标记清理算法：

① 初始标识（程序暂停）：标记被直接引用的对象(一级对象)；

② 并发标识（程序运行）：通过一级对象寻找其他可达对象；

③
再标记（程序暂停）：多线程并行的重新标记之前可能因为并发而漏掉的对象（简单的说就是防遗漏）

④ 并发清理（程序运行）

**4.内存管理小技巧**

1）尽量使用直接量，eg：String javaStr = "小学徒的成长历程";

2）使用StringBuilder和StringBuffer进行字符串连接等操作;

3）尽早释放无用对象;

4）尽量少使用静态变量;

5）缓存常用的对象:可以使用开源的开源缓存实现，eg：OSCache，Ehcache;

6）尽量不使用finalize()方法;

7）在必要的时候可以考虑使用软引用SoftReference。

#### 相关文章

-   [![深度解析Java内存原型](http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg)](http://blog.jobbole.com/22909/)[深度解析Java内存原型](http://blog.jobbole.com/22909/)
-   [![探索Java语言与JVM中的Lambda表达式](http://blog.jobbole.com/wp-content/uploads/2013/02/Java-programming-language-logo3-150x150.jpg)](http://blog.jobbole.com/31860/)[探索Java语言与JVM中的Lambda表达式](http://blog.jobbole.com/31860/)
-   [![《深入理解JAVA虚拟机》笔记](http://blog.jobbole.com/wp-content/uploads/2012/11/deep_into_JVM_001-150x150.jpg){width="150"
    height="150"}](http://blog.jobbole.com/30257/)[《深入理解JAVA虚拟机》笔记](http://blog.jobbole.com/30257/)
-   [![JVM程序员的阅读清单](http://blog.jobbole.com/wp-content/uploads/2011/11/book-logo.jpg)](http://blog.jobbole.com/15342/)[JVM程序员的阅读清单](http://blog.jobbole.com/15342/)
-   [![Time changes in year 1927 for
    China](http://blog.jobbole.com/wp-content/uploads/2011/08/Time-changes-in-year-1927-for-China-%E2%80%93-ShanghaiS-150x150.png){width="150"
    height="150"}](http://blog.jobbole.com/1178/)[陈皓：你确信你了解时间吗？](http://blog.jobbole.com/1178/)
-   [![Java对象初始化详解](http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg)](http://blog.jobbole.com/23939/)[Java对象初始化详解](http://blog.jobbole.com/23939/)
-   [![Java多线程发展简史](http://blog.jobbole.com/wp-content/uploads/2012/09/image_thumb10-150x150.png){width="150"
    height="150"}](http://blog.jobbole.com/28297/)[Java多线程发展简史](http://blog.jobbole.com/28297/)
-   [![Web
    Service入门](http://blog.jobbole.com/wp-content/uploads/2011/11/software-development-logo.jpg)](http://blog.jobbole.com/29195/)[Web
    Service入门](http://blog.jobbole.com/29195/)
-   [![异常的代价](http://blog.jobbole.com/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/14.jpg)](http://blog.jobbole.com/844/)[异常的代价](http://blog.jobbole.com/844/)
-   [![Java 8 中的 lambda
    表达式](http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg)](http://blog.jobbole.com/22433/)[Java
    8 中的 lambda 表达式](http://blog.jobbole.com/22433/)

[Java的内存回收机制](http://blog.jobbole.com/37273/)，首发于[博客 -
伯乐在线](http://blog.jobbole.com)。

</div>



<div
style="margin: 0px 2px; padding-top: 1px;    background-color: #c3d9ff; font-size: 1px !important;    line-height: 0px !important;">

 

</div>

<div
style="margin: 0px 1px; padding-top: 1px;    background-color: #c3d9ff; font-size: 1px !important;    line-height: 0px !important;">

 

</div>

<div style="padding: 4px; background-color: #c3d9ff;">

### 可从此处完成的操作： {#可从此处完成的操作 style="margin:0px 3px;font-family:sans-serif"}

-   使用 **Google 阅读器**[订阅博客 -
    伯乐在线](http://www.google.com/reader/view/feed%2Fhttp%3A%2F%2Fblog.jobbole.com%2Ffeed%2F?source=email)
-   [开始使用 Google
    阅读器](http://www.google.com/reader/?source=email)，轻松地与**您喜爱的所有网站**保持同步更新

</div>

<div
style="margin: 0px 1px; padding-top: 1px;    background-color: #c3d9ff; font-size: 1px !important;    line-height: 0px !important;">

 

</div>

<div
style="margin: 0px 2px; padding-top: 1px;    background-color: #c3d9ff; font-size: 1px !important;    line-height: 0px !important;">

 

</div>
