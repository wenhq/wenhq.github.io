---
layout: post
title: javascript必知必会+理解总结
date: '2013-05-14T13:20:00.001+08:00'
author: Wenh Q
tags: 
modified_time: '2013-05-14T13:20:18.914+08:00'
blogger_id: tag:blogger.com,1999:blog-4961947611491238191.post-9133960475139195537
blogger_orig_url: http://binaryware.blogspot.com/2013/05/javascript.html
---

<a href="http://blog.jobbole.com/39571/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=javascript%25e5%25bf%2585%25e7%259f%25a5%25e5%25bf%2585%25e4%25bc%259a%25e7%2590%2586%25e8%25a7%25a3%25e6%2580%25bb%25e7%25bb%2593">javascript必知必会+理解总结</a>: <br />英文原文：<a href="http://stackoverflow.com/questions/2628672/what-should-every-javascript-programmer-know" style="font-style: normal; font-weight: bold;">What should every JavaScript programmer know?</a>&nbsp;编译：<a href="http://www.ccforward.net/" rel="home" style="font-style: normal; font-weight: bold;" title="西城一隅">西城一隅</a><br />这是stackoverflow上的一个老问题，却有个干货答案，但是扩展的信息量很大，我只在此抛个砖。<br />Not jQuery. Not YUI. Not 等等…<br />js的框架的确很有用，但是它们却常常把一些js的丑陋细节和DOM原理给你隐藏了。如果你的目标是做一个<a href="http://click.union.360buy.com/JdClick/?unionId=16231&amp;to=http://book.360buy.com/10138436.html" rel="nofollow" title="精通JavaScript">精通JavaScript</a>的工程师，那花大把的时间放在框架上可能恰恰背道而驰了。<br />下面就有javascript这门语言的一些特性，你应该知道并且深谙此道，但是很多人可能还并不清楚。<br />一、对象属性，object.prop和object['prop']是一回事(所以你能停止使用eval了吗？！3KU)；对象的属性多是String类型（有些也是数组Array）<br />for…in是什么情况下使用，什么情况慎用？<br /><div>方括号可以通过变量来访问属性<br /><pre>person.name;<br />person['name'];<br />var propertyName = 'name';<br />person[propertyName]; // name</pre>当属性是带空格的string时就只能用方括号了：person['first name'];<br />for…in 循环输出的属性名顺序不可预测,使用之前先检测对象是否为null 或者 undefined</div>二、属性检测；undefined和null；为什么鲜为人知的in运算符非常有用，以及它和typeof、undefined的区别；hasOwnProperty；delete作用<br />undefined好理解一般用来表示未定义，而且不能用delete来删除它。<br />null 表示一个空对象指针 所以 typeof null返回 object<br />undefined派生自null alert(null == undefined) 返回true; 但alert(null === undefined)就返回false了<br />关于hasOwnProperty和Object：<br /><b>hasOwnProperty是js中唯一一个处理属性但是不查找原型链的函数</b><br /><div><pre>Object.prototype.prop = 'propsss';<br />var obj = {und:undefined};<br /><br />obj.prop; // propsss<br />'und' in obj; // true<br /><br />obj.hasOwnProperty('prop'); // false<br />obj.hasOwnProperty('und'); // true<br />//只有hasOwnProperty可以给出正确和期望的结果，尤其在遍历一个对象时<br />//除了hasOwnProperty外，没有其他方法可以排除原型链上的属性（不是定义在对象自身上的属性）<br /><br />//如果hasOwnProperty被占用呢？来看：<br />var obj = {<br />    hasOwnProperty: function(){<br />        return false;<br />    },<br />    prop: 'this is bad...'<br />};<br />obj.hasOwnProperty('prop'); // 总是返回false<br />//这样解决：<br />{}.hasOwnProperty.call(obj,'prop'); // 返回true</pre>var o =new Object();<br />Object的每个实例都具有下列属性方法：<br />1.Constructor：保存着用于创建当前对象的函数 上面例子 构造函数就是 Object()<br />2.hasOwnProperty(prop):检查给定的属性是否在当前对象实例中（而不是在实例的原型中）。作为参数的属性必须以string形式指定<br />3.isPrototypeOf(object):用于检查传入的对象是否是另一个对象的原型。<br />4.propertyIsEnumerable(propertyName)：用于检查给定的属性是否能够使用for in语句<br />5.toLocaleString():返回对象的字符串表示，与环境的地区对应<br />6.toString():同上<br />7.valueOf(): 返回对象的字符串、number、Boolean表示。通常与toString()相同<br />三、Number类型就是浮点类型（64位浮点数）；使用浮点数会遇到语言无关性的问题；避免使用parseInt时的八进制陷阱<br />ECMAScript5不具有解析八进制的能力，可在IE7和chrome上测试 parseInt(069);<br />ES3和ES5之间存在分歧<br />javascript中的乘法问题：<br />一般可以用 10000 作为基数<br />31.12 * 10000 * 9.7 / 10000</div>四、嵌套函数作用域；避免全局变量导致的意外而使用var的必要性；闭包的作用域如何结合使用；在循环与闭包的问题<br />作用域和var关键字的面试题<br /><div><pre>function(){<br />var a=b=10;<br />}<br />console.log(a);<br />console.log(b);</pre>循环中使用闭包<br /><pre>function createFunctions(){<br />    var result = new Array();<br />    for(var i=0;i&lt;10;i++){<br />        result[i] = fucntion(){<br />            return i;<br />        }<br />    }<br />    return result;<br />}<br />//每个函数的作用域链中都保存着createFunctions()函数的活动对象，所以他们引用的都是同一个变量i。<br />//当createFunctions()返回后 变量i的值是10<br />//所以可以这样写<br />for(var i=0;i&lt;10;i++){  <br />  result[i] = function(num){<br />    return function(){  <br />        return num;  <br />    };  <br />  }(i);  <br />}</pre>之前写过的闭包的理解<a href="http://www.ccforward.net/2013/01/js_closure.html">关于闭包</a><br />五、全局变量和window对象的属性产生冲突怎么办（它们其实是一回事）；全局变量和DOM元素在IE中的冲突；在全局作用域中使用var来避免这些问题<br />六、 function语句在解析时会被提升（不管function被放置在哪里，它都会被移动到定义时所在作用域的顶层） 函数声明和函数表达式；为什么命名函数表达式不应该使用<br />关于<b>函数声明提升</b>：<br />解析器会执行一个函数声明提升（function decalaration hoisting）的过程，读取并将函数声明添加到执行环境中。<br />对代码求值时js引擎在第一遍会声明函数并将它们放到源代码树的顶部。</div><div><pre>alert(sum(10,10))<br />function sum(n1,n2){<br />    return n1+n2;<br />}<br />//单独使用下面代码时，函数表达式会出错：<br />alert(sum(10,10));<br />var sum = function (n1,n2){<br />    return n1+n2;<br />}</pre><b>关于命名函数表达式</b>：<br />1、命名函数表达式即被认为是函数声明也被认为是函数表达式<br /><pre>typeof g; // "function"<br />var f = function g(){};<br />//上面这个例子论证了 jScript 是如何把一个命名函数表达式处理成一个函数声明的<br />//在函数声明发生之前就把 g 给解析了   【在IE中检测】</pre>2、命名函数表达式还能创建两个不同的函数对象—-这是js的bug<br /><pre>var f = function g(){};<br />f === g;  //false<br /><br />f.prop = 'a prop';<br />g.prop; // undefined  【在IE中检测】</pre>竟然创建了两个对象，他们之间还不是引用的关系，是不是很有趣。。。我只能说：呵呵 interesting……<br />3、在条件语句中命名函数表达的声明式仍然会被解析<br /><pre>var f = function g(){<br />    return 1;<br />};<br />if(false){<br />    f= function g(){<br />        return 100;<br />    };<br />}<br />g(); //猜猜返回什么 【在IE中检测】<br /><br />//还有arguments也中枪了<br />var f = function g(){<br />    return [<br />      arguments.callee == f,<br />      arguments.callee == g<br />    ];<br />  };<br />console.log(f()); // [true, false]<br />console.log(g()); // [false, true]   【在IE中检测】</pre>注：上面的3条准确的说应该是算是jScript的bug<br />七、构造函数;prototype属性;new运算符的运行机制;利用这些方法实现一个类-子类-实例的系统;在何时应该考虑使基于闭包的对象来替代原型设计</div><div><a href="http://www.ccforward.net/2013/01/javascript_oop.html">看看面向对象吧</a></div>八、this是在函数调用时才被确定的而不是定义的时候；把函数当做参数传入时不像其他语言那样执行；如何使用闭包或者Function.prototype.bind来解决这些问题呢<br /><div>关于this的调用，直接上代码：<br /><pre>var Dog = {<br />    toString: function() { return 'dog';},<br />    fn: function() { alert(this);},<br />};<br />var Cat = {<br />    toString: function() { return 'cat';}<br />};<br /><br />Dog.fn(); // dog<br />Dog['fn']() // dog<br /><br />Cat.fn = Dog.fn;<br />Cat.fn(); // cat<br /><br />var func = Dog.fn;<br />func(); // window</pre>上面代码很简单 请自行补脑……<br /><pre>Obj.method = function() {<br />    var self = this;<br />    function test() {<br />        //this 被设置为全局对象（window）<br />        //self 指向 Obj 对象<br />    }<br />}<br /><br />//想到了arguments做个低耦合的递归求阶乘<br />function factorial(num) {<br />    if(num&lt;=1)<br />        return 1;<br />    else<br />        return num*arguments.callee(num-1);<br />}<br />//callee指向拥有这个arguments对象的函数</pre><a href="http://www.ccforward.net/2013/01/js_this.html">之前写过的关于this的理解</a><br /><b>关于Function.prototype.bind(thisArg [, arg1 [, arg2, …]])：</b><br /><b></b>这是ECMAScript 5中的方法<a href="http://dev.opera.com/articles/view/introducing-ecmascript-5-1/#function-bind">看看Opera的对它的介绍吧</a><br />简单翻译就是：<br />Function.prototype.bind 返回一个新的函数对象，该对象的 this 绑定到了thisArg参数上。本质就是：这允许你在其他对象链中执行一个函数<br />但是很多<a href="http://blog.jobbole.com/12749/" title="浏览器">浏览器</a>不支持，通过一个js的hack看看原理吧：<br /><pre>if(!Object.bind){<br />    Function.prototype.bind = function(owner){<br />        var self = this;<br />        var args = Array.prototype.slice.call(arguments,1);<br />        return function() {<br />            return self.allpy(<br />                args.length===0 ? arguments : arguments.length===0? args:<br />                    args.contact(Array.prototype.slice.call(arguments,0))<br />            );<br />        };<br />    };<br />}</pre></div>九、其他的ES5新特性如indexOf &nbsp;、 forEach 以及Array使用函数式编程；旧浏览器如何兼容这些新的方法；使用匿名函数调用这些方法来使代码更加紧致具有可读性<br /><div><pre>Array.prototype.indexOf(searchString ,position)<br />    var data = [1,3,5,7,9];<br />    console.log(data.indexOf(5)); //2<br />    console.log(data.indexOf(5,4)); //-1  从4号位开始搜索<br />    console.log(data.indexOf('7'));  //-1  7!== '7'<br /><br />Array.prototype.lastIndexOf //从末尾开始查找<br />Array.prototype.some //某些条件符合<br />    var arr = [1,2,3,4,11];<br />    function larger(item){<br />        return item&gt; 10    <br />    }<br />    console.log(arr.some(larger)?'ok':'no...');<br />    //注：只要有一条符合 即返回true 不再执行<br /><br />Array.prototype.every // all符合  和some相比就是返回的 true 和 false 调换一下<br /><br />Array.prototype.forEach //类似jQ里的each<br />    [1, 2 ,3, 4].forEach(alert);<br />    [1, 2 ,3, 4].forEach(console.log);//FF下运行 不知为什么chrome不行。。。。。<br /><br />Array.prototype.map //映射 类似forEach 把原数组映射成新数组<br />    var arr = [1,3,5,7];<br />    var result = arr.map(function(item){<br />        return item * item;<br />    });<br />    console.log(result); //求各项平方<br /><br />Array.prototype.filter //筛选<br />    var filter = [0,2,3,0,undefined].filter(function(item){<br />        return item;<br />    });<br />    console.log(filter);<br />    //filter的callback函数需要返回值为 true 或 false。若为false则过滤掉<br /><br />Array.prototype.reduce //不是减少  是一种迭代<br />    var sum = [1,2,3,4,5].reduce(function(pre,current,index,array) {<br />        return pre + current;<br />    });<br />console.log(sum); //15<br /><br />Array.prototype.reduceRight //right 自然是从数组末未开始</pre>这些都是 ES5 中 Array 对象的扩展方法<br />PS:还是<a href="http://dev.opera.com/articles/view/javascript-array-extras-in-detail/">点此自行补脑</a>，我也在研究中…..后续会再补充<br />十、浏览器和js代码之间控制流程的原理；同步和异步执行；事件在运行时触发和事件在控制返回时触发的区别；调用同步执行的方法如alert而引起控制流重新进入的潜在问题（翻译不通，请自行补脑）。<br />十一、跨window脚本对instanceof的影响 在不同的DOM中跨window脚本对控制流的影响；postMessage怎么解决这个问题<br />postMessage就是HTML5解决跨域问题引入的API，使得多个iframe/window实现跨域通信。<br />写了个postMessage跨域通信的demo：&nbsp;<a href="http://www.ccforward.net/coding/html5css3/postMessage.html">点此查看</a><br />最重要的是，你需要批判的去看待javascript，承认因为种种历史原因而导致各种不完美（甚至比其他语言还要糟糕），并要避免各种陷阱。Crockford在这方面的研究很值得学习（虽然我不完全认同他的《<a href="http://click.union.360buy.com/JdClick/?unionId=16231&amp;to=http://book.360buy.com/10067180.html" rel="nofollow" title="JavaScript语言精粹">JavaScript语言精粹</a>》）</div><h4>相关文章</h4><ul><li><a href="http://blog.jobbole.com/995/"><img alt="阮一峰：Javascript的10个设计缺陷" src="http://blog.jobbole.com/wp-content/uploads/2011/06/javascript-logo.png" /></a><a href="http://blog.jobbole.com/995/">阮一峰：Javascript的10个设计缺陷</a></li><li><a href="http://blog.jobbole.com/36657/"><img alt="浅谈JavaScript的语言特性" src="http://blog.jobbole.com/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/3.jpg" /></a><a href="http://blog.jobbole.com/36657/">浅谈JavaScript的语言特性</a></li><li><a href="http://blog.jobbole.com/19203/"><img alt="网易邮箱前端Javascript编码规范：类规范" src="http://blog.jobbole.com/wp-content/uploads/2011/06/javascript-logo.png" /></a><a href="http://blog.jobbole.com/19203/">网易邮箱前端Javascript编码规范：类规范</a></li><li><a href="http://blog.jobbole.com/23563/"><img alt="Javascript定义类（class）的三种方法" height="150" src="http://blog.jobbole.com/wp-content/uploads/2012/07/three-methods-of-Javascript-defined-class2-150x150.png" width="150" /></a><a href="http://blog.jobbole.com/23563/">Javascript定义类（class）的三种方法</a></li><li><a href="http://blog.jobbole.com/28884/"><img alt="JavaScript：运算符" src="http://blog.jobbole.com/wp-content/uploads/2011/06/javascript-logo.png" /></a><a href="http://blog.jobbole.com/28884/">JavaScript：运算符</a></li><li><a href="http://blog.jobbole.com/25537/"><img alt="design-patterns-in-javascript" height="150" src="http://blog.jobbole.com/wp-content/uploads/2012/08/design-patterns-in-javascript-150x150.jpg" width="150" /></a><a href="http://blog.jobbole.com/25537/">理解JavaScript中的设计模式</a></li><li><a href="http://blog.jobbole.com/26859/"><img alt="JavaScript: 数据类型" src="http://www.jobbole.net/wp-content/uploads/2013/02/javascript-logo-150x150.png" /></a><a href="http://blog.jobbole.com/26859/">JavaScript: 数据类型</a></li><li><a href="http://blog.jobbole.com/18513/"><img alt="50个jQuery代码段帮你成为更出色的JS开发者" height="150" src="http://blog.jobbole.com/wp-content/uploads/2012/04/snippets-150x150.jpg" width="150" /></a><a href="http://blog.jobbole.com/18513/">50个jQuery代码段帮你成为更出色的JS开发者</a></li><li><a href="http://blog.jobbole.com/30468/"><img alt="测试：你自认为理解了JavaScript？" src="http://blog.jobbole.com/wp-content/uploads/2011/06/javascript-logo.png" /></a><a href="http://blog.jobbole.com/30468/">测试：你自认为理解了JavaScript？</a></li><li><a href="http://blog.jobbole.com/29553/"><img alt="Javascript模块化编程（一）：模块的写法" height="150" src="http://blog.jobbole.com/wp-content/uploads/2012/10/javascript-module-01-150x150.jpg" width="150" /></a><a href="http://blog.jobbole.com/29553/">Javascript模块化编程（一）：模块的写法</a></li></ul><a href="http://blog.jobbole.com/39571/">javascript必知必会+理解总结</a>，首发于<a href="http://blog.jobbole.com/">博客 - 伯乐在线</a>。