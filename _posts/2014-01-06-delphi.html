---
layout: post
title: Delphi剖析
date: '2014-01-06T17:23:00.004+08:00'
author: Wenh Q
tags: 
modified_time: '2014-01-06T17:23:59.104+08:00'
blogger_id: tag:blogger.com,1999:blog-4961947611491238191.post-5200411663305496748
blogger_orig_url: http://binaryware.blogspot.com/2014/01/delphi.html
---

<div dir="ltr"><span lang="EN-US" style="color: #500050;">Delphi</span><span style="color: #500050; font-family: 宋体;">剖析&nbsp;</span><a href="http://blog.csdn.net/romandion/archive/2006/01/23/587110.aspx" target="_blank">http://blog.csdn.net/romandion/archive/2006/01/23/587110.aspx</a><br /><div class="gmail_quote"><div class="HOEnZb"><div class="h5"><div dir="ltr"><div class="gmail_quote"><div lang="ZH-CN" link="blue" vlink="purple"><div class="MsoNormal"><br /></div><div class="MsoNormal"><span style="font-family: 宋体;">一、前言</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">关于你所提到</span><span lang="EN-US">VCL framework/Object  pascal/windows SDK/Com</span><span style="font-family: 宋体;">，这些在</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">的帮助都有提到，我想你之所以提到这些，是希望了解我对</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">理解的深度和广度，基于这个认识，我在这里阐述一</span>  <span style="font-family: 宋体;">下我对</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">的认识。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">我对一个语言的掌握一般分三个步骤，不论是</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">、</span><span lang="EN-US">Java</span><span style="font-family: 宋体;">、</span><span lang="EN-US">C/C++</span><span style="font-family: 宋体;">还是其他的：</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span><span style="font-family: 宋体;">、查看帮助或者相关资料，掌握其基本原理和架构，这个步骤主要还是以系统提供的帮助为主。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</span><span style="font-family: 宋体;">、学习源码，一个语言和工具的所有精髓都体现在他所提供的源码中。记得候捷曾经说过源码面前，无所遁形，对此深有同感。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3</span><span style="font-family: 宋体;">、编写具体的应用，在编写过程中再不断地重复查看帮助和源码，在实践中加深对他的理解和把握。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2004</span><span style="font-family: 宋体;">年的时候，朋友向我推荐了李维的《</span><span lang="EN-US">VCL</span><span style="font-family: 宋体;">架构剖析》，我到书店花了一个下午的时间扫了一遍，感觉写得很不错，确实写得很深入。你所提到的，以及</span><span lang="EN-US"> Delphi</span><span style="font-family: 宋体;">很多深层次的内容在这里都有相当精辟的分析。在最后我还是没有买下，因为他提到的绝大数自己都已经知道，或者正在这么做。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">对一个语言的掌握，我更倾向于掌握他的思路。任何语言之间相通的东西远远多于他本身的特性，因此我们在实现一个目标时，往往可以采取很多方式来实现。当这</span>  <span style="font-family: 宋体;">些共性被掌握足够多的时候，任何一个新兴的语言和工具都可以举一反三，以此类推，当然，</span><span lang="EN-US">Java</span><span style="font-family: 宋体;">代码看起来</span><span lang="EN-US">C</span><span style="font-family: 宋体;">的情况还是可能发生的，</span><span lang="EN-US">^_^</span><span style="font-family: 宋体;">，但这并不会有</span> <span style="font-family: 宋体;">大的问题</span> <span style="font-family: 宋体;">。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span style="font-family: 宋体;">二、</span><span lang="EN-US">Dephi</span><span style="font-family: 宋体;">架构概要</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">先介绍下</span><span lang="EN-US">VCL</span><span style="font-family: 宋体;">的整体架构，这里介绍的和李维有不少相重复，但架构本来就只有一个，也无需特意回避什么。如果要详细地谈，估计要写本书了，所以还是以介绍</span>  <span style="font-family: 宋体;">关键部分为主。这里介绍的是以</span><span lang="EN-US">Delphi 5</span><span style="font-family: 宋体;">为主，</span><span lang="EN-US">.Net</span><span style="font-family: 宋体;">没用过，也谈不出什么东西来。后面再详细介绍李维没有提到过的东西。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span><span style="font-family: 宋体;">、</span><span lang="EN-US">Delphi </span><span style="font-family: 宋体;">和</span><span lang="EN-US"> Object Pascal<u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Delphi</span><span style="font-family: 宋体;">首先是开发工具，</span><span lang="EN-US">Object Pascal</span><span style="font-family: 宋体;">才是纯粹的语言。</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">是</span><span lang="EN-US">Object Pascal</span><span style="font-family: 宋体;">在微软平台上的扩展，而</span><span lang="EN-US">Kylix</span><span style="font-family: 宋体;">是其在</span><span lang="EN-US">Posix</span><span style="font-family: 宋体;">（</span><span lang="EN-US">Linux</span><span style="font-family: 宋体;">、</span><span lang="EN-US">Unix</span><span style="font-family: 宋体;">）平台上的扩展，这是句废话，却反应了事物的本质。</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">中</span> <span style="font-family: 宋体;">使用到技术和实现很多和微软平台中密切相关的，而</span><span lang="EN-US">Object Pascal</span><span style="font-family: 宋体;">却是他的本质。</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">中的窗口、控件等的具体实现密切地应用微软平台的特性，因此只能局限在微软平台。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</span><span style="font-family: 宋体;">、</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">和</span><span lang="EN-US"> API<u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Delphi</span><span style="font-family: 宋体;">是在</span><span lang="EN-US">Windows API</span><span style="font-family: 宋体;">基础上封装的工具集、组件集，最大的特色是将过程性的</span><span lang="EN-US">API</span><span style="font-family: 宋体;">整合成对象的方法。因此</span><span lang="EN-US">Windows API</span><span style="font-family: 宋体;">中的内存、文件、图形三个方面的</span><span lang="EN-US">API</span><span style="font-family: 宋体;">在</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">的</span><span lang="EN-US">VCL</span><span style="font-family: 宋体;">中有广泛的应用。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">在</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">生成的每个工程中，都隐式包含</span><span lang="EN-US">SysInit.pas</span><span style="font-family: 宋体;">文件，这单元使用</span><span lang="EN-US">Object Pascal</span><span style="font-family: 宋体;">的外部函数导入语法，从"</span><span lang="EN-US">Kernel32.dll</span><span style="font-family: 宋体;">"中导入动态库管理函数、内存管理函数、线程变量（</span><span lang="EN-US">TLS</span><span style="font-family: 宋体;">）管理函数、命令行管理函数。可</span> <span style="font-family: 宋体;">以说，</span><span lang="EN-US">Object Pascal</span><span style="font-family: 宋体;">是父亲，</span><span lang="EN-US">Windows API</span><span style="font-family: 宋体;">是母亲，然后才有</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">这个英雄般的儿子。</span><span lang="EN-US">SysInit</span><span style="font-family: 宋体;">做的工作，是初始化一个进程，以及进程结束时的扫尾工作。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">在一个单元中，即使没有</span><span lang="EN-US">Uses</span><span style="font-family: 宋体;">任何单元，但你依然可以使用</span><span lang="EN-US">System.pas</span><span style="font-family: 宋体;">接口中列出的方法、变量、类型，这告诉我们</span><span lang="EN-US">System.pas</span><span style="font-family: 宋体;">是被</span><span lang="EN-US"> IDE</span><span style="font-family: 宋体;">自动包含的。在</span><span lang="EN-US">System.pas</span><span style="font-family: 宋体;">中定义并实现了三个主要的类型，</span><span lang="EN-US">Tobject</span><span style="font-family: 宋体;">、</span><span lang="EN-US">Interface</span><span style="font-family: 宋体;">、变体。这三个部分在后面的内容有相当广泛</span> <span style="font-family: 宋体;">地应用。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Classes.pas</span><span style="font-family: 宋体;">之后，才逐步脱离过程语言的影子，而更多体现出面向对象的优势。</span><span lang="EN-US">Tpersistent</span><span style="font-family: 宋体;">的功能其实很简单，就是为对象之间的拷贝而</span> <span style="font-family: 宋体;">设计的。关键是</span><span lang="EN-US">Tcomponent</span><span style="font-family: 宋体;">类，呵呵，我很喜欢研究这个类，感觉这个类比</span><span lang="EN-US">Tobject</span><span style="font-family: 宋体;">更象是</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">的基类。所有的常用的组件和窗体都继承</span> <span style="font-family: 宋体;">自这个类。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; SysInit.pas </span><span style="font-family: 宋体;">、</span><span lang="EN-US"> System.pas </span><span style="font-family: 宋体;">、</span><span lang="EN-US"> Classes.pas </span><span style="font-family: 宋体;">、</span><span lang="EN-US"> Control.pas </span><span style="font-family: 宋体;">、</span><span lang="EN-US"> Forms.pas</span><span style="font-family: 宋体;">，这几个单元的引用关系充分体现了</span><span lang="EN-US">VCL</span><span style="font-family: 宋体;">构造的精髓。这里不得不提到一个有趣的现象，</span><span lang="EN-US">Controls.pas</span><span style="font-family: 宋体;">中引用了</span><span lang="EN-US"> Forms.pas</span><span style="font-family: 宋体;">单元，而</span><span lang="EN-US">Forms.pas</span><span style="font-family: 宋体;">中引用了</span><span lang="EN-US">Controls.pas</span><span style="font-family: 宋体;">，这种相互引用的现象在</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">中很少见到，所以才觉得有趣。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tcanvas</span><span style="font-family: 宋体;">的设计又一次体现了对象封装</span><span lang="EN-US">API</span><span style="font-family: 宋体;">的强大功力。这个类的封装过程告诉我们一个事实，过程性语言和对象语言并不是完全对立的。在</span><span lang="EN-US"> Tcanvas</span><span style="font-family: 宋体;">所有的图形函数，都需要指示一个句柄，这个句柄就标识着同一个对象，而这就是</span><span lang="EN-US">Tcanvas</span><span style="font-family: 宋体;">成功实现的理论基础。在一个对象中，标识对象却</span>  <span style="font-family: 宋体;">是对象指针，这和</span><span lang="EN-US">API</span><span style="font-family: 宋体;">是殊途同归的。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3</span><span style="font-family: 宋体;">、</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">和</span><span lang="EN-US">COM<u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">说老实话，我对</span><span lang="EN-US">COM</span><span style="font-family: 宋体;">这个架构还不是很认同。如果要实现一个服务的话，我更倾向于使用</span><span lang="EN-US">C/C++</span><span style="font-family: 宋体;">，通过</span><span lang="EN-US">TCP/IP</span><span style="font-family: 宋体;">监听请求，这样更容易具备跨平台的特</span> <span style="font-family: 宋体;">性。在高性能需求的应用上，微软平台的性能不敢恭维，我们公司现在做的服务都是在</span><span lang="EN-US">POSIX</span><span style="font-family: 宋体;">标准上实现。如果要做个控件的话，我更倾向于直接使用</span><span lang="EN-US"> Tcomponent</span><span style="font-family: 宋体;">实现组件。对</span><span lang="EN-US">COM</span><span style="font-family: 宋体;">的了解，更多的停留在使用层次上，当然也有少量的开发工作，因此不敢说有什么深刻的了解。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; COM</span><span style="font-family: 宋体;">更多解决的是在二进制级别上实现各种语言、工具之间的兼容。他仅仅提供一个接口上的标准，而把具体的实现留给了各个语言，接口定义语言（</span><span lang="EN-US">IDL</span><span style="font-family: 宋体;">）是</span> <span style="font-family: 宋体;">用于描述</span><span lang="EN-US">COM</span><span style="font-family: 宋体;">接口和方法的一种高级符号语言。</span><span lang="EN-US">COM</span><span style="font-family: 宋体;">组件通过一个或者多个相关函数集来存取组件的数据，这些函数集称为接口，而接口的函数称为方法。</span><span lang="EN-US"> COM</span><span style="font-family: 宋体;">组件通过接口指针调用接口的方法。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">在</span><span lang="EN-US">ComObj.pas</span><span style="font-family: 宋体;">单元中定义了</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">中实现</span><span lang="EN-US">COM</span><span style="font-family: 宋体;">的基本结构，所有和</span><span lang="EN-US">COM</span><span style="font-family: 宋体;">相关的类都归于</span><span lang="EN-US">TcomObj</span><span style="font-family: 宋体;">和</span><span lang="EN-US">IUnknown</span><span style="font-family: 宋体;">。李维书中提道</span> <span style="font-family: 宋体;">"凡是支持</span><span lang="EN-US">Iunknown</span><span style="font-family: 宋体;">接口的都算是</span><span lang="EN-US">COM</span><span style="font-family: 宋体;">组件"，听起来感觉怎么这么象是林彪当年说的，却是一语中的。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  TcomObjFactory</span><span style="font-family: 宋体;">是为了更有效的管理</span><span lang="EN-US">TcomObj</span><span style="font-family: 宋体;">，如果套用设计模式所描述的模式，应该算是</span><span lang="EN-US">Factory</span><span style="font-family: 宋体;">模式吧，不过好像既不是抽象工</span> <span style="font-family: 宋体;">厂，也不是工厂方法模式，而应该是对象工厂模式吧，可惜《设计模式》这本书没有提到，呵呵，虽然叫工厂，感觉却接近于享元。当然</span><span lang="EN-US"> IclassFactory2</span><span style="font-family: 宋体;">是</span><span lang="EN-US"> License</span><span style="font-family: 宋体;">相关的。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">至于带有</span><span lang="EN-US">Type Info</span><span style="font-family: 宋体;">，具有</span><span lang="EN-US">Aggregation</span><span style="font-family: 宋体;">功能的，支持</span><span lang="EN-US">Idispatch</span><span style="font-family: 宋体;">的那些</span><span lang="EN-US">COM</span><span style="font-family: 宋体;">，只是在</span><span lang="EN-US">COM</span><span style="font-family: 宋体;">基础上的一个扩张，以此类推，由此及彼。</span><span lang="EN-US">Com Server</span><span style="font-family: 宋体;">可能有点另类，在</span><span lang="EN-US">TclientDataSet</span><span style="font-family: 宋体;">中，使用估计也是一种</span><span lang="EN-US">Com Server</span><span style="font-family: 宋体;">技术，因为我们在编译可执行的程序后，如果使用了这个数据集，就必须向系统注册</span><span lang="EN-US">Midas.dll</span><span style="font-family: 宋体;">，而</span><span lang="EN-US">Com Server</span><span style="font-family: 宋体;">就规定必须实现四个</span><span lang="EN-US">DLL</span><span style="font-family: 宋体;">函数。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">从个人理解来看，</span><span lang="EN-US">COM</span><span style="font-family: 宋体;">更像是在</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">开发的控件上包了层壳，这个壳就是</span><span lang="EN-US">COM</span><span style="font-family: 宋体;">标准。虽然微软已经将</span><span lang="EN-US">COM</span><span style="font-family: 宋体;">标准提交给第三方组织管理，并成为公共的标准，但怎么看，都打上微软的标签。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  ComObj.pas</span><span style="font-family: 宋体;">和</span><span lang="EN-US">ActiveX.pas</span><span style="font-family: 宋体;">的关系，就像</span><span lang="EN-US">System.pas</span><span style="font-family: 宋体;">和</span><span lang="EN-US">Windows.pas</span><span style="font-family: 宋体;">的关系，换句话说，</span><span lang="EN-US">ComObj.pas</span><span style="font-family: 宋体;">是属于</span><span lang="EN-US"> Delphi</span><span style="font-family: 宋体;">的，而</span><span lang="EN-US">ActiveX.pas</span><span style="font-family: 宋体;">是属于</span><span lang="EN-US">Windows</span><span style="font-family: 宋体;">的。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">上面三点所概括的是对</span><span lang="EN-US">Delphi VCL</span><span style="font-family: 宋体;">架构的认识，下面有重点的谈些更深层次的理解。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span style="font-family: 宋体;">三、一切归于汇编</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">佛曰："尘归尘，土归土"，在程序设计方面，也是类似的。不论是动态语言</span><span lang="EN-US">Java</span><span style="font-family: 宋体;">、</span><span lang="EN-US">Ruby</span><span style="font-family: 宋体;">，还是过程语言</span><span lang="EN-US">C</span><span style="font-family: 宋体;">、</span><span lang="EN-US">Pascal</span><span style="font-family: 宋体;">，甚至面向对象的</span><span lang="EN-US">C++</span><span style="font-family: 宋体;">、</span><span lang="EN-US"> Object Pascal</span><span style="font-family: 宋体;">，归根结底都要归结于汇编代码。设计语言经历着机器代码</span> <span style="font-family: 宋体;">à</span> <span style="font-family: 宋体;">汇编</span> <span style="font-family: 宋体;">à</span> <span style="font-family: 宋体;">过程语言</span> <span style="font-family: 宋体;">à</span> <span style="font-family: 宋体;">对象语言</span> <span style="font-family: 宋体;">à</span> <span style="font-family: 宋体;">动态语言</span> <span style="font-family: 宋体;">。不论什么语言，我们如果从汇编层次来看待这个问题的话，是很容易看出其中的最深刻的原理的。</span><span lang="EN-US">Object Pascal</span><span style="font-family: 宋体;">实际上是汇编＋过程＋对象的混合编程语言，下面我们探讨一下过程和对象在汇编层次的技术基础。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 1</span><span style="font-family: 宋体;">、数值计算</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">过程语言的基础应用就是数值计算，不论后面的面向对象的语言还是更高层次的动态语言都没有放弃这个基本功能。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 2</span><span style="font-family: 宋体;">、函数调用</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">在汇编语言中，已经存在着子过程的概念而调用子过程的就是</span><span lang="EN-US">Call</span><span style="font-family: 宋体;">方法，只不过过程语言使用函数这个更容易理解的方法来使用这个</span><span lang="EN-US">Call</span><span style="font-family: 宋体;">，而不是</span><span lang="EN-US">Push</span><span style="font-family: 宋体;">＋</span><span lang="EN-US">Call</span><span style="font-family: 宋体;">，使用调用参数这个概念更容易接受。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 3</span><span style="font-family: 宋体;">、内存操作</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">内存是如此的神奇，以至于在内存的操作能够演绎出多姿多彩的世界。过程语言、面向对象语言无一不是在内存上大做文章。</span><span lang="EN-US">C</span><span style="font-family: 宋体;">受人推崇的是指针，而受人诟病也同</span> <span style="font-family: 宋体;">样是指针，指针只是简单地指向内存中位置，如此简单，以至于无所不能，啥都能指。指针提供给开发人员强大的内存操作功能，同时也带来巨大的风险。就像剑有</span>  <span style="font-family: 宋体;">双刃一样，既伤人也伤己，只有高手才能操控。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 4</span><span style="font-family: 宋体;">、结构与成员</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">神说：世界要有光，于是这个世界就有了光。估计哪个程序员嫌对基础数据操作过于繁琐，于是结构就出现来拯救世界。结构的作用是将若干基础类型数据集中在一起，方便用户使用。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">结构的定义实际只是绑定了成员之间在内存中的相对内存位置，代码中对结构成员的访问实际上被转化对该成员在内存中与结构相对位置的访问，这个转化工作由编</span>  <span style="font-family: 宋体;">译器自动完成，对开发人员来说，看到的依然是"结构·成员"这个访问方式。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; 5</span><span style="font-family: 宋体;">、对象的实现原理</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">对象的访问方式看起来和结构是如此的相似，以至于有很多文章介绍如何在</span><span lang="EN-US">C</span><span style="font-family: 宋体;">等过程语言中实现面向对象的编程。事实上，确实如此，结构的成员可以是函数指针，这和对象中对象方法是如此的相似。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp; &nbsp;&nbsp;</span><span style="font-family: 宋体;">实际上，对象在语言中的实现和结构是异曲同工的。在</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">中，对象实际上以结构的方式存放在内存中，</span><span lang="EN-US">VMT</span><span style="font-family: 宋体;">就是指示不同方法在该结构的相对位移。当</span> <span style="font-family: 宋体;">一个实例被创建的时候，</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">就自动被为他分配一个</span><span lang="EN-US">InstanceSize</span><span style="font-family: 宋体;">大小的内存给他，并清空内存，然后初始化实例。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">对象之所以为对象，他和结构最根本的区别在于</span><span lang="EN-US">Self</span><span style="font-family: 宋体;">指针。我们在执行对象中方法时，如果查看</span><span lang="EN-US">EAX</span><span style="font-family: 宋体;">寄存器，会发现</span><span lang="EN-US">EAX</span><span style="font-family: 宋体;">中值和</span><span lang="EN-US">SELF</span><span style="font-family: 宋体;">是一样的。也就是</span> <span style="font-family: 宋体;">说，在一般情况下，</span><span lang="EN-US">Object Pascal</span><span style="font-family: 宋体;">总是将自身的指针放在</span><span lang="EN-US">EAX</span><span style="font-family: 宋体;">寄存器中，因此他总能找到自身。虽然结构和对象在表现上很相似，但是执行结构中的方法时，却无法找到自身，只能通</span>  <span style="font-family: 宋体;">过外部传输句柄或者结构指针来获取自身的位置。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">"世间本来没有对象，因为有了编译器，于是就有对象"。呵呵，开个玩笑，但是归根结底来说，对象的生命是编译器赋予的，因为有了编译器，编程的生活才如此多姿多彩。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span style="font-family: 宋体;">四、</span><span lang="EN-US">Tcomponent</span><span style="font-family: 宋体;">类</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Tobject</span><span style="font-family: 宋体;">的定义体现了</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">关于对象设计的精华，但体现</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">价值的却是</span><span lang="EN-US">Tcomponent </span><span style="font-family: 宋体;">类。</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">中关于操作系统消息的封装，更多的是为事件系统服务的。在</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">中，事件更象是回调函数的一个子集，</span><span lang="EN-US">Delphi</span><span style="font-family: 宋体;">事件系统两个方</span> <span style="font-family: 宋体;">面，一个消息驱动的事件，另外一个是对象方法指针，如</span><span lang="EN-US">TnotifyEvent</span><span style="font-family: 宋体;">类型的事件。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">在</span><span lang="EN-US">Tcomponent</span><span style="font-family: 宋体;">类有个技术细节十分有趣，</span><span lang="EN-US">Notification</span><span style="font-family: 宋体;">是</span><span lang="EN-US">Tcomponent</span><span style="font-family: 宋体;">的一个保护的方法，但在</span><span lang="EN-US">Tcomponent.  Notification</span><span style="font-family: 宋体;">方法中，有这么段代码：</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp;  TComponent(FComponents[I]).Notification(AComponent, Operation);<u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">在面向对象的教程中，明确指出，对保护的方法只对自己和后代是可见的，而外部对象只能通过公共方法来访问。在这个例子中，显然调用的是外部对象的保护方</span>  <span style="font-family: 宋体;">法，既然如此，那么有个问题就需要解决，这种与教条相违背的事情什么情况下允许发生呢？</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">经过多次实验，发现当两个类处于同一个单元中，这两个类是可以互相访问保护甚至私有的方法和变量，这种方法是如此的有用，以至于通过这个方法可以实现一个</span>  <span style="font-family: 宋体;">新的设计模式。比如存在这种情况，</span><span lang="EN-US">A</span><span style="font-family: 宋体;">类是</span><span lang="EN-US">B</span><span style="font-family: 宋体;">类的成员，当</span><span lang="EN-US">A</span><span style="font-family: 宋体;">类被创建时，能够自动在</span><span lang="EN-US">B</span><span style="font-family: 宋体;">类中注册自己，这个注册过程是自动完成；当然</span><span lang="EN-US">A</span><span style="font-family: 宋体;">类被析构时，也能够自动</span> <span style="font-family: 宋体;">在</span><span lang="EN-US">B</span><span style="font-family: 宋体;">类中注销自己，这个注销过程也是自动完成的。如果是使用前面提到的方法，可以我们可以轻而易举地将这个注册注销过程屏蔽起来。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span style="font-family: 宋体;">五、动态和静态</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">静态指的是在编译的时候就已经知道了，而动态指的是只有在运行时才知道。如果一个函数是静态的，那么对他的调用，一般直接使用</span><span lang="EN-US">Call</span><span style="font-family: 宋体;">该函数的地址，而动态方法却需要通过类的指针来计算该函数地址。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Object  Pascal</span><span style="font-family: 宋体;">是个过程和对象混合使用的语言，动态与静态之间的结合被应用的如此精妙，在</span><span lang="EN-US">Tobject</span><span style="font-family: 宋体;">中存在若干</span><span lang="EN-US">Class Function</span><span style="font-family: 宋体;">，这些函数实现的是对对象的操作，他们被绑定在类的定义中，而不是类的实例中，因此在</span><span lang="EN-US">Class Function</span><span style="font-family: 宋体;">中是无法引用类中非</span><span lang="EN-US">Class </span><span style="font-family: 宋体;">方法的。这种方法在</span><span lang="EN-US">Object Pascal</span><span style="font-family: 宋体;">中显得有点古怪，以至于在除了</span><span lang="EN-US">Tobject</span><span style="font-family: 宋体;">的定义外，其他地方少有使用。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">在</span><span lang="EN-US">Java</span><span style="font-family: 宋体;">语言里，也专门使用</span><span lang="EN-US">Static</span><span style="font-family: 宋体;">保留字来处理这种情况，通过对象指针就可以直接访问的方法，而不需要创建新的实例来访问。这种现象说明了，即使</span>  <span style="font-family: 宋体;">在自诩一切皆对象的</span><span lang="EN-US">Java</span><span style="font-family: 宋体;">语言中，静态的存在依然必不可少。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">对象的三大特性：封装、继承、多态中，封装利用的</span><span lang="EN-US">Self</span><span style="font-family: 宋体;">指针实现，而继承和多态却是由动态函数指针来实现的。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; Inherited</span><span style="font-family: 宋体;">关键字的使用可以很清晰的反应出继承关系的实现。假设我们先定义一个基类</span><span lang="EN-US">BaseClass</span><span style="font-family: 宋体;">，里面定义个虚函数</span><span lang="EN-US">vf</span><span style="font-family: 宋体;">，然后再实现一个子</span> <span style="font-family: 宋体;">类</span><span lang="EN-US">SubClass</span><span style="font-family: 宋体;">，覆盖该虚函数。如果在</span><span lang="EN-US">vf</span><span style="font-family: 宋体;">中使用</span><span lang="EN-US">Inherited</span><span style="font-family: 宋体;">，那么在</span><span lang="EN-US">Inherited</span><span style="font-family: 宋体;">的位置，会出现调用</span><span lang="EN-US">BaseClass</span><span style="font-family: 宋体;">中</span><span lang="EN-US">vf</span><span style="font-family: 宋体;">函数的代</span> <span style="font-family: 宋体;">码。但不管在什么地方调用</span><span lang="EN-US">vf</span><span style="font-family: 宋体;">函数，也不管</span><span lang="EN-US">SubClass</span><span style="font-family: 宋体;">是否覆盖</span><span lang="EN-US">vf</span><span style="font-family: 宋体;">虚函数，他的汇编代码总是</span><span lang="EN-US">Call [ebx +  $000000e0]</span><span style="font-family: 宋体;">，这意味着，</span><span lang="EN-US">vf</span><span style="font-family: 宋体;">函数在子类和基类中具有相同的占位符。只有在</span><span lang="EN-US">SubClass</span><span style="font-family: 宋体;">中使用</span><span lang="EN-US">Inherited</span><span style="font-family: 宋体;">这个关键字的时候，编译器才</span> <span style="font-family: 宋体;">会将其调用基类实际的函数。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">多态的实现，道理也是一样的，也是依靠动态的对象方法指针来实现的。</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span style="font-family: 宋体;">六、编译器就是上帝</span><span lang="EN-US"><u></u><u></u></span></div><div class="MsoNormal"><br /></div><div class="MsoNormal"><span lang="EN-US">&nbsp;&nbsp;&nbsp;&nbsp;&nbsp; </span><span style="font-family: 宋体;">计算机象个洪荒时代，里面啥都没有，除了比特还是比特。就是因为有了编译器，才有如此丰富的语言和特性。在讨论</span><span lang="EN-US">VCL framework</span><span style="font-family: 宋体;">的时候，很多时候不得不提到编译器。比如面向对象的</span><span lang="EN-US">Self</span><span style="font-family: 宋体;">就是由编译器支持的，正是因为有了</span><span lang="EN-US">Self</span><span style="font-family: 宋体;">，开发人员才能在类方法中编写代</span> <span style="font-family: 宋体;">码，而无需考虑要访问的资源究竟是否是自己的。</span></div></div></div></div></div></div></div><br /></div>