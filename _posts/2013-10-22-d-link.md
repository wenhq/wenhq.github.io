--- layout: post title:
"我是如何反编译D-Link路由器固件程序并发现它的后门的" date:
'2013-10-22T11:19:00.001+08:00' author: Wenh Q tags: modified\_time:
'2013-10-22T11:19:06.055+08:00' blogger\_id:
tag:blogger.com,1999:blog-4961947611491238191.post-8070230170234363967
blogger\_orig\_url: http://binaryware.blogspot.com/2013/10/d-link.html
---

[我是如何反编译D-Link路由器固件程序并发现它的后门的](http://www.oschina.net/news/45251/reverse-engineering-a-d-link-backdoor)

Via [开源中国社区最新新闻](http://www.oschina.net/?from=rss)

OK，又是周末晚上，没有约会，只有一大瓶Shasta汽水和全是快节奏的音乐…[那就研究一下程序吧](http://www.youtube.com/watch?v=-pIMVZZRb7Y&t=22s)。\
一时兴起，我下载了D-link无线路由器(型号：DIR-100 revA)的[固件程序
v1.13](ftp://ftp.dlink.eu/Products/dir/dir-100/driver_software/DIR-100_fw_reva_113_ALL_en_20110915.zip)。使用工具Binwalk，很快的就从中发现并提取出一个只读SquashFS文件系统，没用多大功夫我就将这个固件程序的web
server(/bin/webs)加载到了IDA中：\
![Strings inside
/bin/webs](http://static.oschina.net/uploads/img/201310/22075604_03YD.png)\
/bin/webs中的字符信息\
基于上面的字符信息可以看出，这个/bin/webs二进制程序是一个修改版的thttpd，提供路由器管理员界面操作功能。看起来是经过了台湾明泰科技(D-Link的一个[子公司](http://www.alphanetworks.com/chinese/06_about/00_overview.php))的修改。他们甚至很有心计的将他们很多自定义的函数名都辅以"alpha"前缀：\
![Alphanetworks' custom
functions](http://static.oschina.net/uploads/img/201310/22075604_irrl.png)\
明泰科技的自定义函数\
这个**alpha\_auth\_check**函数看起来很有意思！\
这个函数被很多地方调用，最明显的一个是来自**alpha\_httpd\_parse\_request**函数：\
![Function call to
alpha\_auth\_check](http://static.oschina.net/uploads/img/201310/22075604_iHn7.png)\
调用alpha\_auth\_check函数\
我们可以看到**alpha\_auth\_check**函数接收一个参数(是存放在寄存器\$s2里)；如果**alpha\_auth\_check**返回-1(0xFFFFFFFF)，程序将会跳到**alpha\_httpd\_parse\_request**的结尾处，否则，它将继续处理请求。\
寄存器\$s2在被**alpha\_auth\_check**函数使用前的一些操作代码显示，它是一个指向一个数据结构体的指针，里面有一个char\*指针，会指向从HTTP请求里接收到的各种数据；比如HTTP头信息和请求地址URL：\
![\$s2 is a pointer to a data
structure](http://static.oschina.net/uploads/img/201310/22075605_bgtG.png)\
\$s2是一个指向一个数据结构体的指针\
我们现在可以模拟出**alpha\_auth\_check**函数和数据结构体的大概样子：\

    struct http_request_t  {      char unknown[0xB8];      char *url; // At offset 0xB8 into the data structure  };    int alpha_auth_check(struct http_request_t *request);

**alpha\_auth\_check**本身是一个非常简单的函数。它会针对**http\_request\_t**结构体里的一些指针进行字符串**strcmp**比较操作，然后调用**check\_login**函数，实际上就是身份验证检查。如果一旦有字符串比较成功或**check\_login**成功，它会返回1；否者，它会重定向浏览器到登录页，返回-1;\
![alpha\_auth\_check code
snippet](http://static.oschina.net/uploads/img/201310/22075605_kSWw.png)\
alpha\_auth\_check函数代码片段\
这些字符串比较过程看起来非常有趣。它们提取请求的URL地址(在**http\_request\_t**数据结构体的偏移量0xB8处)，检查它们是否含有字符串"graphic/"
或
"public/"。这些都是位于路由器的Web目录下的公开子目录，如果请求地址包含这样的字符串，这些请求就可以不经身份认证就能执行。\
然而，这最后一个strcmp却是相当的吸引眼球：\
![An interesting string comparison in
alpha\_auth\_check](http://static.oschina.net/uploads/img/201310/22075605_Sr2i.png)\
alpha\_auth\_check函数中一个非常有趣的字符串比较\
这个操作是将**http\_request\_t**结构体中偏移量0xD0的字符串指针和字符串"xmlset\_roodkcableoj28840ybtide"比较，如果字符匹配，就会跳过**check\_login**函数，**alpha\_auth\_check**操作返回1(认证通过)。\
我在谷歌上搜索了一下"xmlset\_roodkcableoj28840ybtide"字符串，只发现在一个俄罗斯论坛里提到过它，说这是一个在/bin/webs里一个"非常有趣"的一行。我非常同意。\
那么，这个神秘的字符串究竟是和什么东西进行比较？如果回顾一下调用路径，我们会发现**http\_request\_t**结构体被传进了好几个函数：\
![call\_graph](http://static.oschina.net/uploads/img/201310/22075605_7d16.png)\
事实证明，**http\_request\_t**结构体中处在偏移量
0xD0处的指针是由**httpd\_parse\_request**函数赋值的：\
![Checks for the User-Agent HTTP
header](http://static.oschina.net/uploads/img/201310/22075605_4OeD.png)\
检查HTTP头信息中的User-Agent值\
![Populates http\_request\_t + 0xD0 with a pointer to the User-Agent
header
string](http://static.oschina.net/uploads/img/201310/22075605_LlHH.png)\
将http\_request\_t + 0xD0指针指向头信息User-Agent字符串\
这代码实际上就是：\

    if(strstr(header, "User-Agent:") != NULL)  {      http_request_t->0xD0 = header + strlen("User-Agent:") + strspn(header, " \t");  }

知道了**http\_request\_t**偏移量0xD0处的指针指向User-Agent头信息，我们可以推测出**alpha\_auth\_check**函数的结构：\

    #define AUTH_OK 1  #define AUTH_FAIL -1    int alpha_auth_check(struct http_request_t *request)  {      if(strstr(request->url, "graphic/") ||         strstr(request->url, "public/") ||         strcmp(request->user_agent, "xmlset_roodkcableoj28840ybtide") == 0)      {          return AUTH_OK;      }      else      {          // These arguments are probably user/pass or session info          if(check_login(request->0xC, request->0xE0) != 0)          {              return AUTH_OK;          }      }        return AUTH_FAIL;  }

换句话说，如果浏览器的User-Agent值是
"xmlset\_roodkcableoj28840ybtide"(不带引号)，你就可以不经任何认证而能访问web控制界面，能够查看/修改路由器的
设置(下面是D-Link路由器(DI-524UP)的截图，我没有
DIR-100型号的，但DI-524UP型号使用的是相同的固件)：\
![Accessing the admin page of a
DI-524UP](http://static.oschina.net/uploads/img/201310/22075605_W9Op.png)\
访问型号DI-524UP路由器的主界面\
基于HTML页上的源代码信息和Shodan[搜索结果](http://www.shodanhq.com/search?q=thttpd-alphanetworks%2F2.23)，差不多可以得出这样的结论：下面的这些型号的D-Link路由器将会受到影响：\

-   DIR-100
-   DI-524
-   DI-524UP
-   DI-604S
-   DI-604UP
-   DI-604+
-   TM-G5240

除此之外，几款Planex路由器显然也是用的同样的固件程序：\

-   BRL-04UR
-   BRL-04CW

你很酷呀，D-Link。\
**脚注：**万
能的网友指出，字符串"xmlset\_roodkcableoj28840ybtide"是一个倒序文，反过来读就是
"editby04882joelbackdoor\_teslmx"——edit by 04882joel backdoor
\_teslmx，这个后门的作者真是位天才！\

[英文原文： [Reverse Engineering a D-Link
Backdoor](http://www.devttys0.com/2013/10/reverse-engineering-a-d-link-backdoor/)
]
