--- 
layout: post 
title: 45个实用的JavaScript技巧、窍门和最佳实践 
date: '2014-01-01T12:43:00.000+08:00' 
author: Wenh Q
tags: - tech
modified\_time: '2014-01-01T12:43:02.550+08:00' 
blogger\_id: tag:blogger.com,1999:blog-4961947611491238191.post-1394053527321928462
blogger\_orig\_url: http://binaryware.blogspot.com/2014/01/45javascript.html
---
<div dir="ltr">

[45个实用的JavaScript技巧、窍门和最佳实践](http://blog.jobbole.com/54495/)

</div>

<div style="margin-top: 15px;">

通过 [博客 - 伯乐在线](http://blog.jobbole.com/)

</div>

<div dir="ltr"
style="font-size: 14px; line-height: 20px; margin-top: 15px;">

如你所知，JavaScript是世界上第一的编程语言，它是Web的语言，是移动混合应用（mobile
hybrid
apps）的语言（比如[PhoneGap](http://phonegap.com/)或者[Appcelerator](http://www.appcelerator.com/)），是服务器端的语言（比如[NodeJS](http://nodejs.org/)或者[Wakanda](http://wakanda.org/)），并且拥有很多其他的实现。同时它也是很多新手的启蒙语言，因为它不但可以在浏览器上显示一个简单的alert信息，而且还可以用来控制一个机器人（使用[nodebot](http://nodebots.io/)，或者[nodruino](http://semu.github.io/noduino/)）。掌握JavaScript并且能够写出组织规范并性能高效的代码的开发人员，已经成为人才市场上的猎寻对象。

![keep-calm-and-learn-javascript](http://jbcdn2.b0.upaiyun.com/2013/12/keep-calm-and-learn-javascript.jpg)

在这篇文章中，我将分享一组JavaScript的技巧、窍门和最佳实践，这些都是JavaScript程序员应该知晓的，不管他们是使用在浏览器/引擎上，还是服务器端（SSJS——Service
Side JavaScript）JavaScript解释器上。

<span
style="color: red;">【译者注：原文作者总共写了44条（漏写了第3条），译者自己补了一条觉得比较重要的技巧。】</span>

需要注意的是，这篇文章中的代码片段都在最新的Google
Chrome（版本号30）上测试过，它使用V8 JavaScript引擎（V8 3.20.17.15）

**1 – 在第一次给一个变量赋值的时候不要忘记使用`var`关键字**

给一个未定义的变量赋值会导致创建一个全局变量。要避免全局变量。

**2 – 使用===，而不是＝＝**

==（或!=）操作符在需要的时候会自动执行类型转换。===（或!==）操作不会执行任何转换。它将比较值和类型，而且在速度上也被认为优于==。

    [10] === 10    // is false  [10]  == 10    // is true  '10' == 10     // is true  '10' === 10    // is false   []   == 0     // is true   [] ===  0     // is false   '' == false   // is true but true == "a" is false   '' ===   false // is false

**3 – 使用闭包实现私有变量（译者添加）**

    function Person(name, age) {      this.getName = function() { return name; };      this.setName = function(newName) { name = newName; };      this.getAge = function() { return age; };      this.setAge = function(newAge) { age = newAge; };        //未在构造函数中初始化的属性      var occupation;      this.getOccupation = function() { return occupation; };      this.setOccupation = function(newOcc) { occupation =                            newOcc; };  }

**4 – 在行结尾处使用冒号**

在行结尾处使用冒号是一个很好的实践。如果你忘记写了你也不会被警告，因为多数情况下JavaScript解释器会帮你加上冒号。

**5 – 创建对象的构造函数**

    function Person(firstName, lastName){      this.firstName =  firstName;      this.lastName = lastName;  }    var Saad = new Person("Saad", "Mousliki");

**6 – 小心使用typeof、instanceof和constructor**

    var arr = ["a", "b", "c"];  typeof arr;   // return "object"  arr  instanceof Array // true  arr.constructor();  //[]

**7 – 创建一个自调用函数（Self-calling Funtion）**

这个经常被称为自调用匿名函数（Self-Invoked Anonymous
Function）或者即时调用函数表达式（IIFE-Immediately Invoked Function
Expression)。这是一个在创建后立即自动执行的函数，通常如下：

    (function(){      // some private code that will be executed automatically  })();  (function(a,b){      var result = a+b;      return result;  })(10,20)

**8- 从数组中获取一个随机项**

    var items = [12, 548 , 'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' , 2145 , 119];    var  randomItem = items[Math.floor(Math.random() * items.length)];

**9 – 在特定范围内获取一个随机数**

这个代码片段在你想要生成测试数据的时候非常有用，比如一个在最小最大值之间的一个随机薪水值。

    var x = Math.floor(Math.random() * (max - min + 1)) + min;

**10 – 在0和设定的最大值之间生成一个数字数组**

    var numbersArray = [] , max = 100;    for( var i=1; numbersArray.push(i++) < max;);  // numbers = [0,1,2,3 ... 100]

**11 – 生成一个随机的数字字母字符串**

    function generateRandomAlphaNum(len) {      var rdmstring = "";      for( ; rdmString.length < len; rdmString  += Math.random().toString(36).substr(2));      return  rdmString.substr(0, len);  }

<span
style="color: grey;">【译者注：特意查了一下Math.random()生成0到1之间的随机数，number.toString(36)是将这个数字转换成36进制（0-9，a-z），最后substr去掉前面的"0."字符串】</span>

**12 – 打乱一个数字数组**

    var numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411];  numbers = numbers.sort(function(){ return Math.random() - 0.5});  /* the array numbers will be equal for example to [120, 5, 228, -215, 400, 458, -85411, 122205]  */

**13 – String的trim函数**

在Java、C
#、PHP和很多其他语言中都有一个经典的 trim
函数，用来去除字符串中的空格符，而在JavaScript中并没有，所以我们需要在String对象上加上这个函数。

    String.prototype.trim = function(){return this.replace(/^
s+|
s+$/g, "");};

<span
style="color: grey;">【译者注：去掉字符串的前后空格，不包括字符串内部空格】</span>

**14 – 附加（append）一个数组到另一个数组上**

    var array1 = [12 , "foo" , {name: "Joe"} , -2458];    var array2 = ["Doe" , 555 , 100];  Array.prototype.push.apply(array1, array2);  /* array1 will be equal to  [12 , "foo" , {name "Joe"} , -2458 , "Doe" , 555 , 100] */

<span
style="color: grey;">【译者注：其实concat可以直接实现两个数组的连接，但是它的返回值是一个新的数组。这里是直接改变array1】</span>

**15 – 将arguments对象转换成一个数组**

    var argArray = Array.prototype.slice.call(arguments);

<span style="color: grey;">【译者注：<span
style="text-decoration: underline;">[<span
style="color: grey; text-decoration: underline;">arguments对象是一个类数组对象，但不是一个真正的数组</span>](http://debuggable.com/posts/turning-javascript-s-arguments-object-into-an-array:4ac50ef8-3bd0-4a2d-8c2e-535ccbdd56cb)</span>】</span>

**16 – 验证参数是否是数字（number）**

    function isNumber(n){      return !isNaN(parseFloat(n)) && isFinite(n);  }

**17 – 验证参数是否是数组**

    function isArray(obj){      return Object.prototype.toString.call(obj) === '[object Array]' ;  }

注意：如果toString()方法被重写了（overridden），你使用这个技巧就不能得到想要的结果了。或者你可以使用：

    Array.isArray(obj); // 这是一个新的array的方法

如果你不在使用多重frames的情况下，你还可以使用 instanceof
方法。但如果你有多个上下文，你就会得到错误的结果。

    var myFrame = document.createElement('iframe');  document.body.appendChild(myFrame);    var myArray = window.frames[window.frames.length-1].Array;  var arr = new myArray(a,b,10); // [a,b,10]    // instanceof will not work correctly, myArray loses his constructor  // constructor is not shared between frames  arr instanceof Array; // false

<span
style="color: grey;">【译者注：关于如何判断数组网上有不少讨论，大家可以google一下。<span
style="text-decoration: underline;">[<span
style="color: grey; text-decoration: underline;">这篇</span>](http://perfectionkills.com/instanceof-considered-harmful-or-how-to-write-a-robust-isarray/)</span>就写的挺详细的。】</span>

**18 – 获取一个数字数组中的最大值或最小值**

    var  numbers = [5, 458 , 120 , -215 , 228 , 400 , 122205, -85411];  var maxInNumbers = Math.max.apply(Math, numbers);  var minInNumbers = Math.min.apply(Math, numbers);

<span
style="color: grey;">【译者注：这里使用了Function.prototype.apply方法传递参数的技巧】</span>

**19 – 清空一个数组**

    var myArray = [12 , 222 , 1000 ];  myArray.length = 0; // myArray will be equal to [].

**20 – 不要使用 delete 来删除一个数组中的项。**

使用 splice 而不要使用 delete 来删除数组中的某个项。使用 delete 只是用
undefined 来替换掉原有的项，并不是真正的从数组中删除。

不要使用这种方式：

    var items = [12, 548 ,'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' ,2154 , 119 ];  items.length; // return 11  delete items[3]; // return true  items.length; // return 11  /* items will be equal to [12, 548, "a", undefined × 1, 5478, "foo", 8852, undefined × 1, "Doe", 2154,       119]   */

而使用：

    var items = [12, 548 ,'a' , 2 , 5478 , 'foo' , 8852, , 'Doe' ,2154 , 119 ];  items.length; // return 11  items.splice(3,1) ;  items.length; // return 10  /* items will be equal to [12, 548, "a", 5478, "foo", 8852, undefined × 1, "Doe", 2154,       119]   */

delete 方法应该被用来删除一个对象的某个属性。

**21 – 使用 length 来截短一个数组**

跟上面的清空数组的方式类似，我们使用 length 属性来截短一个数组。

    var myArray = [12 , 222 , 1000 , 124 , 98 , 10 ];  myArray.length = 4; // myArray will be equal to [12 , 222 , 1000 , 124].

此外，如果你将一个数组的 length
设置成一个比现在大的值，那么这个数组的长度就会被改变，会增加新的
undefined 的项补上。 数组的 length 不是一个只读属性。

    myArray.length = 10; // the new array length is 10  myArray[myArray.length - 1] ; // undefined

**22 – 使用逻辑 AND/OR 做条件判断**

    var foo = 10;  foo == 10 && doSomething(); // 等价于 if (foo == 10) doSomething();  foo == 5 || doSomething(); // 等价于 if (foo != 5) doSomething();

逻辑 AND 还可以被使用来为函数参数设置默认值

    function doSomething(arg1){      Arg1 = arg1 || 10; // 如果arg1没有被设置的话，Arg1将被默认设成10  }

**23 – 使用 map() 方法来遍历一个数组里的项**

    var squares = [1,2,3,4].map(function (val) {      return val * val;  });  // squares will be equal to [1, 4, 9, 16]

**24 – 四舍五入一个数字，保留N位小数**

    var num =2.443242342;  num = num.toFixed(4);  // num will be equal to 2.4432

**25 – 浮点数问题**

    0.1 + 0.2 === 0.3 // is false  9007199254740992 + 1 // is equal to 9007199254740992  9007199254740992 + 2 // is equal to 9007199254740994

为什么会这样？
0.1+0.2等于0.30000000000000004。你要知道，所有的JavaScript数字在内部都是以64位二进制表示的浮点数，符合IEEE
754标准。更多的介绍，可以阅读[这篇博文](http://www.2ality.com/2012/04/number-encoding.html)。你可以使用
toFixed() 和 toPrecision() 方法解决这个问题。

**26 – 使用for-in遍历一个对象内部属性的时候注意检查属性**

下面的代码片段能够避免在遍历一个对象属性的时候访问原型的属性

    for (var name in object) {      if (object.hasOwnProperty(name)) {          // do something with name      }  }

**27 – 逗号操作符**

    var a = 0;  var b = ( a++, 99 );  console.log(a);  // a will be equal to 1  console.log(b);  // b is equal to 99

**28 – 缓存需要计算和查询（calculation or querying）的变量**

对于jQuery选择器，我们最好缓存这些DOM元素。

    var navright = document.querySelector('#right');  var navleft = document.querySelector('#left');  var navup = document.querySelector('#up');  var navdown = document.querySelector('#down');

**29 – 在调用 isFinite()之前验证参数**

    isFinite(0/0) ; // false  isFinite("foo"); // false  isFinite("10"); // true  isFinite(10);   // true  isFinite(undifined);  // false  isFinite();   // false  isFinite(null);  // true  !!!

**30 – 避免数组中的负数索引（negative indexes）**

    var numbersArray = [1,2,3,4,5];  var from = numbersArray.indexOf("foo") ;  // from is equal to -1  numbersArray.splice(from,2);    // will return [5]

确保调用 indexOf 时的参数不是负数。

**31 – 基于JSON的序列化和反序列化（serialization and
deserialization）**

    var person = {name :'Saad', age : 26, department : {ID : 15, name : "R&D"} };  var stringFromPerson = JSON.stringify(person);  /* stringFromPerson is equal to "{"name":"Saad","age":26,"department":{"ID":15,"name":"R&D"}}"   */  var personFromString = JSON.parse(stringFromPerson);  /* personFromString is equal to person object  */

**32 – 避免使用 eval() 和 Function 构造函数**

使用 eval 和 Function
构造函数是非常昂贵的操作，因为每次他们都会调用脚本引擎将源代码转换成可执行代码。

    var func1 = new Function(functionCode);  var func2 = eval(functionCode);

**33 – 避免使用 with()**

使用 with()
会插入一个全局变量。因此，同名的变量会被覆盖值而引起不必要的麻烦。

**34 – 避免使用 for-in 来遍历一个数组**

避免使用这样的方式：

    var sum = 0;  for (var i in arrayNumbers) {      sum += arrayNumbers[i];  }

更好的方式是：

    var sum = 0;  for (var i = 0, len = arrayNumbers.length; i < len; i++) {      sum += arrayNumbers[i];  }

附加的好处是，i 和 len
两个变量的取值都只执行了一次，会比下面的方式更高效：

    for (var i = 0; i < arrayNumbers.length; i++)

为什么？因为arrayNumbers.length每次循环的时候都会被计算。

**35 – 在调用 setTimeout() 和 setInterval()
的时候传入函数，而不是字符串。**

如果你将字符串传递给 setTimeout() 或者
setInterval()，这个字符串将被如使用 eval 一样被解析，这个是非常耗时的。

不要使用：

    setInterval('doSomethingPeriodically()', 1000);  setTimeOut('doSomethingAfterFiveSeconds()', 5000)

而用：

    setInterval(doSomethingPeriodically, 1000);  setTimeOut(doSomethingAfterFiveSeconds, 5000);

**36 – 使用 switch/case 语句，而不是一长串的 if/else**

在判断情况大于2种的时候，使用 switch/case
更高效，而且更优雅（更易于组织代码）。但在判断的情况超过10种的时候不要使用
switch/case。

<span style="color: grey;">【译者注：查了一下文献，大家可以看一下<span
style="text-decoration: underline;">[<span
style="color: grey; text-decoration: underline;">这篇介绍</span>](http://oreilly.com/server-administration/excerpts/even-faster-websites/writing-efficient-javascript.html#the_fastest_conditionals)</span>】</span>

**37 – 在判断数值范围时使用 switch/case**

在下面的这种情况，使用 switch/case 判断数值范围的时候是合理的：

    function getCategory(age) {      var category = "";      switch (true) {          case isNaN(age):              category = "not an age";              break;          case (age >= 50):              category = "Old";              break;          case (age <= 20):              category = "Baby";              break;          default:              category = "Young";              break;      };      return category;  }  getCategory(5);  // will return "Baby"

<span style="color: grey;">【译者注：一般对于数值范围的判断，用 if/else
会比较合适。 switch/case 更适合对确定数值的判断】</span>

**38 – 为创建的对象指定prototype对象**

写一个函数来创建一个以指定参数作为prototype的对象是有可能：

    function clone(object) {      function OneShotConstructor(){};      OneShotConstructor.prototype= object;      return new OneShotConstructor();  }  clone(Array).prototype ;  // []

**39 – 一个HTML转义函数**

    function escapeHTML(text) {      var replacements= {"<": "<", ">": ">","&": "&", "
"": """};      return text.replace(/[<>&"]/g, function(character) {          return replacements[character];      });  }

**40 – 避免在循环内部使用 try-catch-finally**

在运行时，每次当 catch
从句被执行的时候，被捕获的异常对象会赋值给一个变量，而在
try-catch-finally 结构中，每次都会新建这个变量。

避免这样的写法：

    var object = ['foo', 'bar'], i;  for (i = 0, len = object.length; i <len; i++) {      try {          // do something that throws an exception      }      catch (e) {          // handle exception      }  }

而使用：

    var object = ['foo', 'bar'], i;  try {      for (i = 0, len = object.length; i <len; i++) {          // do something that throws an exception      }  }  catch (e) {      // handle exception  }

**41 – 为 XMLHttpRequests 设置超时。**

在一个XHR请求占用很长时间后（比如由于网络问题），你可能需要中止这次请求，那么你可以对XHR调用配套使用
setTimeout()。

    var xhr = new XMLHttpRequest ();  xhr.onreadystatechange = function () {      if (this.readyState == 4) {          clearTimeout(timeout);          // do something with response data      }  }  var timeout = setTimeout( function () {      xhr.abort(); // call error callback  }, 60*1000 /* timeout after a minute */ );  xhr.open('GET', url, true);      xhr.send();

此外，一般你应该完全避免同步的Ajax请求。

**42 – 处理WebSocket超时**

通常，在一个WebSocket连接创建之后，如果你没有活动的话，服务器会在30秒之后断开（time
out）你的连接。防火墙也会在一段时间不活动之后断开连接。

为了防止超时的问题，你可能需要间歇性地向服务器端发送空消息。要这样做的话，你可以在你的代码里添加下面的两个函数：一个用来保持连接，另一个用来取消连接的保持。通过这个技巧，你可以控制超时的问题。

使用一个 timerID：

    var timerID = 0;  function keepAlive() {      var timeout = 15000;      if (webSocket.readyState == webSocket.OPEN) {          webSocket.send('');      }      timerId = setTimeout(keepAlive, timeout);  }  function cancelKeepAlive() {      if (timerId) {          cancelTimeout(timerId);      }  }

keepAlive()方法应该被添加在webSOcket连接的 onOpen() 方法的最后，而
cancelKeepAlive() 添加在 onClose() 方法的最后。

**43 –
牢记，[原始运算符始终比函数调用要高效](http://dev.opera.com/articles/view/efficient-javascript/?page=2#primitiveoperator)。使用[VanillaJS](http://vanilla-js.com/)。**

举例来说，不使用：

    var min = Math.min(a,b);  A.push(v);

而用：

    var min = a < b ? a b;  A[A.length] = v;

**44 –
编码的时候不要忘记使用代码整洁工具。在上线之前使用JSLint和代码压缩工具（minification）（比如JSMin）。**

**45 –
JavaScript是不可思议的。[最好的JavaScript学习资源](http://stackoverflow.com/questions/11246/best-resources-to-learn-javascript)。**

总结
====

我知道还有很多其他的技巧，窍门和最佳实践，所以如果你有其他想要添加或者对我分享的这些有反馈或者纠正，请在评论中指出。

引用
====

在这篇文章中，我使用了一些我自己的代码片段，也有一些代码片段来自别人的文章或者论坛：

-   [JavaScript Performance Best
    Practices](http://developer.nokia.com/Community/Wiki/JavaScript_Performance_Best_Practices) ([CC](http://creativecommons.org/licenses/by-nc-sa/2.5/))
-   [Google Code JavaScript
    tips](https://code.google.com/p/jslibs/wiki/JavascriptTips)
-   [StackOverFlow tips and
    tricks](http://stackoverflow.com/questions/724826/javascript-tips-and-tricks-javascript-best-practices)
-   [TimeOut for
    XHR](http://stackoverflow.com/questions/6888409/settimeout-for-xhr-requests)

<div>

<div>

### 相关文章

-   [JavaScript必知必会+理解总结](http://blog.jobbole.com/39571/)
-   [阮一峰：Javascript的10个设计缺陷](http://blog.jobbole.com/995/)
-   [JavaScript：运算符](http://blog.jobbole.com/28884/)
-   [浅谈JavaScript的语言特性](http://blog.jobbole.com/36657/)
-   [如何编写可维护的面向对象JavaScript代码](http://blog.jobbole.com/18191/)
-   [编写快速、高效的JavaScript代码](http://blog.jobbole.com/31951/)
-   [给JavaScript初学者的24条最佳实践](http://blog.jobbole.com/53199/)
-   [Javascript定义类（class）的三种方法](http://blog.jobbole.com/23563/)
-   [测试：你自认为理解了JavaScript？](http://blog.jobbole.com/30468/)
-   [理解JavaScript中的设计模式](http://blog.jobbole.com/25537/)

</div>

</div>

[45个实用的JavaScript技巧、窍门和最佳实践](http://blog.jobbole.com/54495/)，首发于[博客
- 伯乐在线](http://blog.jobbole.com/)。

</div>
