---
layout: post
title: "高效操作Bash"
date: '2014-01-01T14:07:00.001+08:00'
author: Wenh Q
tags: 
modified_time: '2014-01-01T14:07:11.923+08:00'
blogger_id: tag:blogger.com,1999:blog-4961947611491238191.post-5345703269631038704
blogger_orig_url: http://binaryware.blogspot.com/2014/01/bash.html
---

<div dir="ltr"><div style="font-family: sans-serif; margin: 0px 10px; overflow: auto; width: 100%;"><h2 style="margin: 0.25em 0px 0px;"><div><a href="http://ahei.info/bash.htm" target="_blank">高效操作Bash</a></div></h2><div style="margin-bottom: 0.5em;">于 10-12-18 通过 <a href="http://ahei.info/" target="_blank">极限手指</a> 作者：ahei</div><br />我们在平常工作中大量使用linux, 而使用linux的过程中操作Bash更是非常之频繁, 所以怎样高效的操作Bash是一个非常重要的问题. 下面我结合自己的经验总结一下高效操作Bash的一些技巧.  <br /><div><div><ul><li><a href="http://ahei.info/#sec-1" target="_blank">1 快捷键 </a>  <ul><li><a href="http://ahei.info/#sec-1_1" target="_blank">1.1 注意 </a></li><li><a href="http://ahei.info/#sec-1_2" target="_blank">1.2 重度推荐 </a></li><li><a href="http://ahei.info/#sec-1_3" target="_blank">1.3 常用快捷键 </a></li><li><a href="http://ahei.info/#sec-1_4" target="_blank">1.4 高级快捷键 </a></li><li><a href="http://ahei.info/#sec-1_5" target="_blank">1.5 总结 </a></li></ul></li><li><a href="http://ahei.info/#sec-2" target="_blank">2 历史扩展 </a>  <ul><li><a href="http://ahei.info/#sec-2_1" target="_blank">2.1 概念 </a></li><li><a href="http://ahei.info/#sec-2_2" target="_blank">2.2 事件指示器(Event Designators) </a></li><li><a href="http://ahei.info/#sec-2_3" target="_blank">2.3 单词指示器(Word Designators) </a></li><li><a href="http://ahei.info/#sec-2_4" target="_blank">2.4 修饰符(Modifiers) </a></li><li><a href="http://ahei.info/#sec-2_5" target="_blank">2.5 例子 </a></li><li><a href="http://ahei.info/#sec-2_6" target="_blank">2.6 总结 </a></li></ul></li><li><a href="http://ahei.info/#sec-3" target="_blank">3 shell技巧 </a>  <ul><li><a href="http://ahei.info/#sec-3_1" target="_blank">3.1 Here Documents </a></li><li><a href="http://ahei.info/#sec-3_2" target="_blank">3.2 Here Strings </a></li><li><a href="http://ahei.info/#sec-3_3" target="_blank">3.3 进程替换(Process Substitution) </a></li></ul></li><li><a href="http://ahei.info/#sec-4" target="_blank">4 广告 </a></li></ul></div></div><div><h3>1 快捷键 </h3><div></div><div><h4>1.1 注意 </h4><div>本文的快捷键表示中, <b>C</b> 表示Ctrl键, M表示Alt健. 这些快捷键中, 有一个小规律, 对字符操作一般是C开头,   对单词操作一般是M开头. 如果你用SecureCRT, 默认的话, 会输入不了Alt开头的快捷键, 因为Alt被当作菜单快捷键了, 可以点 选项   -&gt; 回话选项, 选择tab 终端-&gt;仿真-&gt;Emacs, 把"使用Alt键作为元键"打勾.   如果你用gnome-terminal, 默认状态下也输入不了Alt开头的快捷键，也被当作菜单快捷键了，可以点 编辑 -&gt; 键盘快捷键, 把＂启用菜单快捷键＂前面的勾去掉.<br />  下面的快捷键中很多以Ctrl键开头, 很多键盘的Ctrl键并不是很好按, 可以尝试把<a href="http://emacser.com/capslocak.htm" target="_blank">Ctrl键和Capslock键交换</a>.  </div></div><div><h4>1.2 重度推荐 </h4><div><ul><li>C-r <br /><br />  有时候，如果你想重新输入以前输入过的某条命令怎么办? 我见过两种做法：  <ol><li>  不停的按向上方向键，试图找出那条命令  </li><li>  输入history命令，然后找到那条命令，或者grep一把history命令的输出  </li></ol>其实, 你有更好的选择, 那就是按 <b>C-r</b>, 然后输入你想要的命令中含有的单词, 就会出现含有这个单词的命令, 如果它不是你想要的命令, 就继续按C-r, 知道出现你想要的命令为止. C-r效果: <br />  <br />  <pre>(reverse-i-search)`ls': ls a b c  </pre></li></ul><ul><li>M-. <br /><br />  我经常见别人用mkdir long-long-long-name-dir后, 再输入cd, 后面跟那个长的不能再长的目录名, 这时候我就会告诉他, 其实你输入完cd后, 可以按M-., 就可以自动输入那个长的不能再长的目录名了. 其实, M-.的真正作用就是把上一条命令的最后一个参数输入到当前命令行. <b>非常非常之方便, 强烈推荐</b>. 如果继续按M-., 会把上上条命令的最后一个参数拿过来. 同样, 如果你想把上一条命令第一个参数拿过来咋办呢? 用M-0 M-., 就是先输入M-0, 再输入M-.. 如果是上上条命令的第一个参数呢? 当然是M-0 M-. M-.了.  </li></ul></div></div><div><h4>1.3 常用快捷键 </h4><div><ul><li>程序控制 <br /><br />  <table border="2" cellpadding="6" cellspacing="0">  <caption><br /></caption>  <colgroup>  <col></col>  <col></col>  </colgroup>  <thead><tr>  <th>意义</th>  <th>快捷键</th>  </tr></thead>  <tbody><tr>  <td>终止当前在前台运行的程序</td>  <td>C-c</td>  </tr><tr>  <td>挂起当前在前台运行的程序</td>  <td>C-z</td>  </tr><tr>  <td>如果光标在行首且当前行没有输入任何字符, C-d会退出当前会话</td>  <td>C-d</td>  </tr></tbody>  </table></li></ul><ul><li>光标移动 <br /><br />  <table border="2" cellpadding="6" cellspacing="0">  <caption><br /></caption>  <colgroup>  <col></col>  <col></col>  </colgroup>  <thead><tr>  <th>意义</th>  <th>快捷键</th>  </tr></thead>  <tbody><tr>  <td>向前(Forward)移动一个字符</td>  <td>C-f</td>  </tr><tr>  <td>向后(Backward)移动一个字符</td>  <td>C-b</td>  </tr><tr>  <td>向前移动一个单词</td>  <td>M-f</td>  </tr><tr>  <td>向后移动一个单词</td>  <td>M-b</td>  </tr><tr>  <td>移动光标到行首</td>  <td>C-a</td>  </tr><tr>  <td>移动光标到行尾</td>  <td>C-e</td>  </tr></tbody>  </table></li></ul><ul><li>编辑 <br /><br />  <table border="2" cellpadding="6" cellspacing="0">  <caption><br /></caption>  <colgroup>  <col></col>  <col></col>  </colgroup>  <thead><tr>  <th>意义</th>  <th>快捷键</th>  </tr></thead>  <tbody><tr>  <td>向前删一个字符</td>  <td>C-d</td>  </tr><tr>  <td>向后删一个字符</td>  <td>C-h</td>  </tr><tr>  <td>向前删一个单词</td>  <td>M-d</td>  </tr><tr>  <td>向后删一个单词, 单词之间以符号分割</td>  <td>C-M-h</td>  </tr><tr>  <td>向后删一个单词, 单词之间以空格分割</td>  <td>C-w</td>  </tr><tr>  <td>清屏, 相当于命令clear, 有了这个快捷键, 就不用每次努力的敲clear了</td>  <td>C-l</td>  </tr><tr>  <td>删除当前光标到行尾的字符</td>  <td>C-k</td>  </tr><tr>  <td>删除当前光标到行首的字符</td>  <td>C-u</td>  </tr><tr>  <td>粘贴删除环里面的第一项</td>  <td>C-y</td>  </tr><tr>  <td>粘贴删除环里面的后面的项</td>  <td>M-y</td>  </tr><tr>  <td>undo</td>  <td>C-/</td>  </tr><tr>  <td>取出上一条命令的最后一个参数</td>  <td>M-.</td>  </tr></tbody>  </table>对于C-M-h和C-w的区别, 看下面这个例子: <br /><br />  如果当前光标前面的字符串为"abc def-ghi", C-M-h会删掉ghi, 但是C-w会删掉"def-ghi", 也就是说, C-M-h向后删的时候碰到非字母和数字就会停止, 但是C-w碰到空格才会停止. <br />  <br />  Bash下有一个删除环(kill-ring), 所有被删除的东西(用C-d删除的字符不算)都会进入这个环, C-y会粘贴环里面最近进去的项, 想要粘贴后面的项, 必须在按C-y后, 不停的按M-y, 直到出来你想要的项为止. <br />  <br />  有时候, 你想搜索某个文件中是否有TAB键, 你这时候会怎么做呢? 你或许会用grep, 在你输入完grep后, 你再按TAB, 这时候会出来什么? 什么都没出现! 再按? 出来:  <br />  <pre>Display all N possibilities? (y or n)  </pre>这是为何呢? 因为TAB是补全键. 那么是否是输入不了TAB吗? 不是! 按C-v后, 再按TAB即可. 同样, 想输入C-a, C-b也是同样的道理. <br />  <br />  </li></ul><ul><li>历史命令操作 <br /><br />  <table border="2" cellpadding="6" cellspacing="0">  <caption><br /></caption>  <colgroup>  <col></col>  <col></col>  </colgroup>  <thead><tr>  <th>意义</th>  <th>快捷键</th>  </tr></thead>  <tbody><tr>  <td>从历史命令列表中取下一条命令, 相当于向下方向键</td>  <td>C-n</td>  </tr><tr>  <td>从历史命令列表中取上一条命令, 相当于向上方向键</td>  <td>C-p</td>  </tr><tr>  <td>向后增量搜索历史命令, <b>非常方便</b>, 严重推荐, 有了它, 以前输入过的很长的命令, 可以不用重复输入</td>  <td>C-r</td>  </tr><tr>  <td>循环执行历史命令</td>  <td>C-o</td>  </tr></tbody>  </table>用C-p取出历史命令列表中某一个命令后, 按C-o可以在这条命令到历史命令列表后面的命令之间循环执行命令,   比如历史命令列表中有50条命令, 后面三项分别是命令A, 命令B, 命令C, 用C-p取出命令A后, 再按C-o就可以不停的在命令A, 命令B,   命令C中循环执行这三个命令. C-o有一个非常好用的地方, 比如用cp命令在拷贝一个大目录的时候, 你肯定很想知道当前的拷贝进度,   那么你现在该怎样做呢? 估计很多人会想到不停的输入du -sh dir去执行, 但用C-o可以非常完美的解决这个问题, 方法就是:  <br />  <ol><li>  输入du -sh dir, 按回车执行命令  </li><li>  C-p, C-o, 然后就可以不停的按C-o了, 会不停的执行du -sh dir这条命令  </li></ol>其实上面这个问题也可以用watch命令解决:  <br />  <pre>watch -n 1 -d du -sh dir  </pre></li></ul></div></div><div><h4>1.4 高级快捷键 </h4><div><table border="2" cellpadding="6" cellspacing="0">  <caption><br /></caption>  <colgroup>  <col></col>  <col></col>  </colgroup>  <thead><tr>  <th>意义</th>  <th>快捷键</th>  </tr></thead>  <tbody><tr>  <td>从当前光标处向前搜索字符</td>  <td>C-]</td>  </tr><tr>  <td>从当前光标处向后搜索字符</td>  <td>C-M-]</td>  </tr><tr>  <td>交换当前光标下的字符和光标前面的一个字符, 交换后, 光标向后移东一个字符</td>  <td>C-t</td>  </tr><tr>  <td>交换当前光标所在单词和光标前面一个单词, 交换后, 光标向后移动一个单词</td>  <td>M-t</td>  </tr><tr>  <td>把单词首字符变成大写, 其他变成小写</td>  <td>M-c</td>  </tr><tr>  <td>把单词变成小写</td>  <td>M-l</td>  </tr><tr>  <td>把单词变成大写</td>  <td>M-u</td>  </tr><tr>  <td>删除当前光标前面所有的空白字符</td>  <td>M-\</td>  </tr><tr>  <td>向后非增量搜索历史命令</td>  <td>M-p</td>  </tr><tr>  <td>相当于TAB健</td>  <td>C-i</td>  </tr><tr>  <td>相当于回车键</td>  <td>C-m/C-j</td>  </tr><tr>  <td>在当前光标处和上一次光标处不停的移动</td>  <td>C-x C-x</td>  </tr></tbody>  </table></div></div><div><h4>1.5 总结 </h4><div>其实, 上面所说的快捷键并不是由Bash来控制的, 而是有一个叫<a href="http://www.gnu.org/software/readline/" target="_blank"><b>readline</b></a>的  库来控制的, readline库用在很多地方, 比如gdb, mysql, 你使用gdb的时候, 是不是很奇怪,   为啥它也能用上下方向键取出前面后面的命令? 因为它用的也是readline库. 所以只要掌握了readline, 就掌握了Bash, gdb,   mysql等程序里面的快捷键操作技巧. readline是一个非常非常强悍的库, 它有两种模式, 一个是<a href="http://emacser.com/" target="_blank">Emacs</a>模  式, 另外一个是vi模式, Emacs模式非常适合在命令行下使用, 我上面说的快捷键都是针对Emacs模式来说的.   readline的Emacs模式下的光标移动, 编辑等快捷键和Emacs下的快捷键也非常相近. 所以你学会了这些快捷键, 也快入门Emacs了,   <img alt=":)" src="http://ahei.info/wp-includes/images/smilies/icon_smile.gif" /> . readline也可以自定义快捷键, 它还有一套配置语法. 关于它的详细介绍, 可以man readline或者info readline, 也可以看看大牛王垠写的<a href="http://docs.huihoo.com/homepage/shredderyin/readline.html" target="_blank">readline介绍</a>.  </div></div></div><div><h3>2 历史扩展 </h3><div></div><div><h4>2.1 概念 </h4><div>首先举个例子:<br />  首先输入一条命令:  <br /><pre>ls abc def ghi  </pre>再输入:  <br /><pre>!!*:s/b/d  </pre>那么实际上执行的命令是:  <br /><pre>adc def ghi  </pre>我来解释一下, !!表示从命令历史列表中取上一条历史命令"ls abc def ghi", *表示选择取刚才选择的命令的所有参数, 即:   "abc def ghi", :s/b/d表示对刚才取出来的参数"abc def ghi"进行替换, 把第一个出现的b替换成d <br /><br />  从上面可以看出, 操作历史命令分为三步: <br />  <br /><ul><li>  首先从历史命令列表中选择某条命令, 被选择到的命令被称作 <b>事件(event)</b> (对应上面的!!)  </li><li>  再从选择好的事件中选择一部分单词(words), 事件中的每个单词以空格分割(对应上面的*)  </li><li>  最后对选择好的一部分单词进行修改(Modifiers)  </li></ul></div></div><div><h4>2.2 事件指示器(Event Designators) </h4><div>事件指示器用来从历史命令列表中选择一条命令, 也就是选择事件 <br />  <br /><ul><li>  !n <br /><br />  选择历史命令列表中第n条命令  </li><li>  !-n <br /><br />  选择倒数第n条命令  </li><li>  !! <br /><br />  选择上一条命令, 相当于!-1, 和 <b>C-p</b> 的作用也一样  </li><li>  !string <br /><br />  选择最近的以string开头的命令  </li><li>  !?string[?] <br /><br />  选择最近的包含string的命令, 如果该指示器后面是换行符, 则可以不用输入结尾的"?"  </li><li>  ^string1^string2 <br /><br />  取上一条命令, 并把第一个出现的string1替换成string2  </li><li>  !# <br /><br />  引用目前输入的所有命令, 比如输入:  <pre>more a !#  </pre>那么最终执行的命令就是:  <br />  <pre>more a more a  </pre></li></ul></div></div><div><h4>2.3 单词指示器(Word Designators) </h4><div>单词指示器用来从被选择好的事件中选择一部分单词, 单词指示器必须以冒号(:)和事件指示器分割开来, 除非单词指示器以^, $, *, -, %开头 <br />  <br /><ul><li>  0 <br /><br />  选择第0个word, 也就是命令. 假如事件为"ls abc", 那么单词指示器0选择的word即为"ls"  </li><li>  n <br /><br />  选择第n个word  </li><li>  ^ <br /><br />  选择命令的第一个参数, 也就是第一个word, 相当于单词指示器1  </li><li>  $ <br /><br />  选择命令的最后一个参数  </li><li>  % <br /><br />  选择最近的与 "?string?" 搜索相匹配的单词  </li><li>  x-y <br /><br />  选择第x到第y个word, -y表示0-y  </li><li>  * <br /><br />  选择命令的所有参数, 相当于1-$  </li><li>  x* <br /><br />  x-$的缩写  </li><li>  x- <br /><br />  类似x*, 不过不包含最后一个word. -选择除最后一个word外所有的words  </li></ul></div></div><div><h4>2.4 修饰符(Modifiers) </h4><div>对选择的单词进行修改, 修饰符可以出现多次, 每个修饰符要以冒号开头 <br />  <br /><ul><li>  p <br /><br />  打印新命令, 但不执行  </li><li>  s/old/new/<br />  把 <b>第一次出现的</b> old替换成new, 如果分隔符"/"是最后一个字符的话, 可以省略. 就像sed中一样, 分隔符"/"可以用其他字符代替, 比如s:old:new:. new中出现的&amp;将被old代替. 如果old省略, 那么就用上一次替换用的old代替.  </li><li>  &amp; <br /><br />  重复上一次替换  </li><li>  g <br /><br />  使修饰符所做的修改应用于整个选择的单词. 类似于sed中的s命令最后的g, 可配合:s和:&amp;修饰符使用, 比如:gs/old/new则对整个事件进行替换.  </li><li>  a <br /><br />  和g作用一样  </li><li>  G <br /><br />  使后面的:s修饰符对每个word只替换一次  </li></ul></div></div><div><h4>2.5 例子 </h4><div><ul><li>例一 <br /><br />  从别的机器的一个目录拷贝一个a.log文件, 执行:  <pre>scp user@machine:/home/user/a/a.log .  </pre>后来执行:  <br />  <pre>ls a.log  rm -rf a.log  </pre>这时候再想拷贝一下b/b.log, 这时候就可以这样做:  <br />  <pre>!scp:gs/a/b  </pre>如果只想看看用历史扩展出来的命令, 那可以这样:  <br />  <pre>!scp:gs/a/b/:p  </pre></li></ul><ul><li>例二 <br /><br />  从别的机器同时拷贝a/a.log和b/b.log:  <pre>scp user@mbchine:/home/user/a/a.log . &amp;&amp; !#-:gs/a/b  </pre>上面的!#为事件指示器, 选择前面已经输入的命令"scp user@mbchine:/home/user/a/a.log . &amp;&amp;", "-"为单词指示器, 选择除最后一个word, 即"&amp;&amp;"外的所有words, 也就是"scp user@mbchine:/home/user/a/a.log . ", 最后的":gs/a/b"为修饰符, 对刚才选择的words进行全局替换, 把a替换成b, 最后就成了"scp user@mbchine:/home/user/b/b.log .", 那么最终命令也就成了"scp user@mbchine:/home/user/a/a.log . &amp;&amp; scp user@mbchine:/home/user/b/b.log ."  <br />  </li></ul></div></div><div><h4>2.6 总结 </h4><div>上面的例子都可以用前面所说的快捷键完成, 不过灵活利用历史扩展有时候还是能更高效的完成同样的事情  </div></div></div><div><h3>3 shell技巧 </h3><div></div><div><h4>3.1 Here Documents </h4><div><pre>&lt;&lt;[-]word  here-documents  delimiter  </pre>把here-documents作为某个命令的标准输入, 例子:  <br /><pre>grep a <span style="color: cyan;">&lt;&lt;</span> EOF<span style="color: deeppink;">  asdf  qweszd  asdf  EOF  </span></pre></div></div><div><h4>3.2 Here Strings </h4><div><pre>&lt;&lt;&lt; here-strings  </pre>把word作为命令的标准输入, 例子:<br />  grep a &lt;&lt;&lt; abc  </div></div><div><h4>3.3 进程替换(Process Substitution) </h4><div>假如我现在想比较两个目录dir1和dir2中的文件有啥不同, 我想很多人会这样做:  <br /><pre>ls dir1 <span style="color: cyan;">&gt;</span> 1  ls dir2 <span style="color: cyan;">&gt;</span> 2  diff 1 2  </pre>但你试试这样:  <br /><pre>diff <span style="color: cyan;">&lt;</span><span style="color: cornflowerblue;">(</span>ls dir1<span style="color: cornflowerblue;">)</span> <span style="color: cyan;">&lt;</span><span style="color: cornflowerblue;">(</span>ls dir2<span style="color: cornflowerblue;">)</span>  </pre>是不是也可以? 很神奇吧. 上面的这个语法&lt;(command)就是进程替换. &lt;(command)表示把command的输出生成一个临时文件, 并把这个文件名作为另外一个命令的参数. 对于上面的命令, 就是把"ls dir1″命令的输出生成一个临时文件, 并把临时文件名做为diff命令的第一个参数. 再举一个例子:  <br /><pre>wget -q -O <span style="color: cyan;">&gt;</span><span style="color: cornflowerblue;">(</span>cat<span style="color: cornflowerblue;">)</span> <a href="http://baidu.com/" target="_blank">http://baidu.com</a>  </pre>wget命令会把下载后的文件保存到文件中去, 但是我们可以用上面的命令不让它保存到文件中去, 而是显示出来.   wget的"-O"选项后本来应该是一个文件名的参数, 但是我们现在用&gt;(cat)代替, 表示wget下载下来的内容放到一个临时文件中,   然后把这个临时文件名再传给&gt;()里面的cat命令.<br />  灵活运用进程替换, 将会非常的方便, <b>严重推荐</b>  </div></div></div><div><h3>4 广告 </h3><div>呵呵, 最后做一点小广告, 这篇文章是在Emacs Org Mode下写的(本文最后一句话, HTML generated by org-mode 7.3 in emacs 23, 你看到了吗), <a href="http://orgmode.org/" target="_blank">Org Mode</a>是Emacs内置的一个非常强悍非常强悍的Mode, 是实践<a href="http://zh.wikipedia.org/zh/GTD" target="_blank">GTD</a>最好的工具, 它的功能包括但不限于: <b>时间管理</b>, 做笔记, 用原始的文本格式html/pdf/latex, 画流程图等. 可以看看这几篇文章以引起你的兴趣: <a href="http://emacser.com/org-mode.htm" target="_blank">Emacs org mode学习笔记</a>, <a href="http://emacser.com/emacs-ditaa.htm" target="_blank">Emacs中绘图 － ditaa篇</a>, <a href="http://emacser.com/emacs-simple-use.htm" target="_blank">Emacs － 普通人的编辑利器</a>.  </div></div><div>HTML generated by org-mode 7.3 in emacs 23</div></div></div>