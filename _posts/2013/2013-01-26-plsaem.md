--- layout: post title: "概率语言模型及其变形系列-PLSA及EM算法" date:
'2013-01-26T12:23:00.001+08:00' author: Wenh Q tags: - NLP - tech.nlp
modified\_time: '2013-11-30T12:25:44.000+08:00' blogger\_id:
tag:blogger.com,1999:blog-4961947611491238191.post-622948483033239572
blogger\_orig\_url: http://binaryware.blogspot.com/2013/01/plsaem.html
---
[概率语言模型及其变形系列-PLSA及EM算法](http://feedproxy.google.com/~r/52nlp/~3/XLAXGkJth8E/%e6%a6%82%e7%8e%87%e8%af%ad%e8%a8%80%e6%a8%a1%e5%9e%8b%e5%8f%8a%e5%85%b6%e5%8f%98%e5%bd%a2%e7%b3%bb%e5%88%971-plsa%e5%8f%8aem%e7%ae%97%e6%b3%95):
\
本系列博文介绍常见概率语言模型及其变形模型，主要总结PLSA、LDA及LDA的变形模型及参数Inference方法。初步计划内容如下\
第一篇：[PLSA及EM算法](http://blog.csdn.net/yangliuy/article/details/8330640)\
第二篇：[LDA及Gibbs
Samping](http://blog.csdn.net/yangliuy/article/details/8302599)\
第三篇：LDA变形模型-Twitter
LDA，TimeUserLDA，ATM，Labeled-LDA，MaxEnt-LDA等\
第四篇：基于变形LDA的paper分类总结\
第一篇 PLSA及EM算法\
[Update 2012/12/21
为了解决部分朋友反映的网页图片无法显示的问题，更新PDF版本\
下载地址 [PLSA及EM算法-yangliuy](http://www.52nlp.cn/%e6%a6%82%e7%8e%87%e8%af%ad%e8%a8%80%e6%a8%a1%e5%9e%8b%e5%8f%8a%e5%85%b6%e5%8f%98%e5%bd%a2%e7%b3%bb%e5%88%971-plsa%e5%8f%8aem%e7%ae%97%e6%b3%95/plsa%e5%8f%8aem%e7%ae%97%e6%b3%95-yangliuy)]\
前言：本文主要介绍PLSA及EM算法，首先给出LSA（隐性语义分析）的早期方法SVD，然后引入基于概率的PLSA模型，其参数学习采用EM算法。接着我们分析如何运用EM算法估计一个简单的mixture
unigram
语言模型和混合高斯模型GMM的参数，最后总结EM算法的一般形式及运用关键点。对于改进PLSA，引入hyperparameter的LDA模型及其Gibbs
Sampling参数估计方法放在本系列后面的文章[LDA及Gibbs
Samping](http://blog.csdn.net/yangliuy/article/details/8302599)介绍。\
\
\
\
1 LSA and SVD\
LSA(隐性语义分析)的目的是要从文本中发现隐含的语义维度-即“Topic”或者“Concept”。我们知道，在文档的空间向量模型（VSM）中，文档被表示成由特征词出现概率组成的多维向量，这种方法的好处是可以将query和文档转化成同一空间下的向量计算相似度，可以对不同词项赋予不同的权重，在文本检索、分类、聚类问题中都得到了广泛应用，在[newsgroup18828文本分类器JAVA实现](http://blog.csdn.net/yangliuy/article/details/7400984)和[newsgroup18828文本聚类器的JAVA实现](http://blog.csdn.net/yangliuy/article/details/7471659)系列文章中的分类聚类算法大多都是采用向量空间模型。然而，向量空间模型没有能力处理一词多义和一义多词问题，例如同义词也分别被表示成独立的一维，计算向量的余弦相似度时会低估用户期望的相似度；而某个词项有多个词义时，始终对应同一维度，因此计算的结果会高估用户期望的相似度。\
LSA方法的引入就可以减轻类似的问题。基于SVD分解，我们可以构造一个原始向量矩阵的一个低秩逼近矩阵，具体的做法是将词项文档矩阵做SVD分解\
[![](http://latex.codecogs.com/gif.latex?C%20=%20U%20%5CSigma%20V%5ET "C = U \Sigma V^T")](http://www.codecogs.com/eqnedit.php?latex=C%20=%20U%20%5CSigma%20V%5ET)\
其中[![](http://latex.codecogs.com/gif.latex?C "C")](http://www.codecogs.com/eqnedit.php?latex=C)是以词项(terms)为行,
文档(documents)为列做一个大矩阵. 设一共有t行d列,
 矩阵的元素为词项的tf-idf值。然后把[![](http://latex.codecogs.com/gif.latex?%5CSigma "\Sigma")](http://www.codecogs.com/eqnedit.php?latex=%5CSigma)的r个对角元素的前k个保留（最大的k个保留）,
后面最小的r-k个奇异值置0,
得到[![](http://latex.codecogs.com/gif.latex?%5CSigma_k "\Sigma_k")](http://www.codecogs.com/eqnedit.php?latex=%5CSigma_k)；最后计算一个近似的分解矩阵\
[![](http://latex.codecogs.com/gif.latex?C_k%20=%20U%5CSigma_k%20V%5ET "C_k = U\Sigma_k V^T")](http://www.codecogs.com/eqnedit.php?latex=C_k%20=%20U%5CSigma_k%20V%5ET)\
则[![](http://latex.codecogs.com/gif.latex?C_k "C_k")](http://www.codecogs.com/eqnedit.php?latex=C_k)在最小二乘意义下是[![](http://latex.codecogs.com/gif.latex?C "C")](http://www.codecogs.com/eqnedit.php?latex=C)的最佳逼近。由于[![](http://latex.codecogs.com/gif.latex?%5CSigma_k "\Sigma_k")](http://www.codecogs.com/eqnedit.php?latex=%5CSigma_k)最多包含k个非零元素，所以[![](http://latex.codecogs.com/gif.latex?C_k "C_k")](http://www.codecogs.com/eqnedit.php?latex=C_k)的秩不超过k。通过在SVD分解近似，我们将原始的向量转化成一个低维隐含语义空间中，起到了特征降维的作用。每个奇异值对应的是每个“语义”维度的权重，将不太重要的权重置为0，只保留最重要的维度信息，去掉一些信息“nosie”,因而可以得到文档的一种更优表示形式。将SVD分解降维应用到文档聚类的JAVA实现可参见[此文](http://blog.csdn.net/yangliuy/article/details/7471839)。\
2 PLSA\
尽管基于SVD的LSA取得了一定的成功，但是其缺乏严谨的数理统计基础，而且SVD分解非常耗时。Hofmann在SIGIR’99上提出了基于概率统计的PLSA模型，并且用EM算法学习模型参数。PLSA的概率图模型如下\
![](http://img.my.csdn.net/uploads/201212/20/1355968136_9389.JPG)\
其中D代表文档，Z代表隐含类别或者主题，W为观察到的单词，[![](http://latex.codecogs.com/gif.latex?P(d_i) "P(d_i)")](http://www.codecogs.com/eqnedit.php?latex=P(d_i))表示单词出现在文档[![](http://latex.codecogs.com/gif.latex?d_i "d_i")](http://www.codecogs.com/eqnedit.php?latex=d_i)的概率，[![](http://latex.codecogs.com/gif.latex?P(z_k%7Cd_i) "P(z_k|d_i)")](http://www.codecogs.com/eqnedit.php?latex=P(z_k%7Cd_i))表示文档[![](http://latex.codecogs.com/gif.latex?d_i "d_i")](http://www.codecogs.com/eqnedit.php?latex=d_i)中出现主题[![](http://latex.codecogs.com/gif.latex?z_k "z_k")](http://www.codecogs.com/eqnedit.php?latex=z_k)下的单词的概率，[![](http://latex.codecogs.com/gif.latex?P(w_j%7Cz_k) "P(w_j|z_k)")](http://www.codecogs.com/eqnedit.php?latex=P(w_j%7Cz_k))给定主题[![](http://latex.codecogs.com/gif.latex?z_k "z_k")](http://www.codecogs.com/eqnedit.php?latex=z_k)出现单词[![](http://latex.codecogs.com/gif.latex?w_j "w_j")](http://www.codecogs.com/eqnedit.php?latex=w_j)的概率。并且每个主题在所有词项上服从Multinomial
分布，每个文档在所有主题上服从Multinomial
分布。整个文档的生成过程是这样的：\
(1)
以[![](http://latex.codecogs.com/gif.latex?P(d_i) "P(d_i)")](http://www.codecogs.com/eqnedit.php?latex=P(d_i))的概率选中文档[![](http://latex.codecogs.com/gif.latex?d_i "d_i")](http://www.codecogs.com/eqnedit.php?latex=d_i)；\
(2)
以[![](http://latex.codecogs.com/gif.latex?P(z_k%7Cd_i) "P(z_k|d_i)")](http://www.codecogs.com/eqnedit.php?latex=P(z_k%7Cd_i))的概率选中主题[![](http://latex.codecogs.com/gif.latex?z_k "z_k")](http://www.codecogs.com/eqnedit.php?latex=z_k)；\
(3)
以[![](http://latex.codecogs.com/gif.latex?P(w_j%7Cz_k) "P(w_j|z_k)")](http://www.codecogs.com/eqnedit.php?latex=P(w_j%7Cz_k))的概率产生一个单词。\
我们可以观察到的数据就是[![](http://latex.codecogs.com/gif.latex?(d_i,w_j) "(d_i,w_j)")](http://www.codecogs.com/eqnedit.php?latex=(d_i,w_j))对，而[![](http://latex.codecogs.com/gif.latex?z_k "z_k")](http://www.codecogs.com/eqnedit.php?latex=z_k)是隐含变量。[![](http://latex.codecogs.com/gif.latex?(d_i,w_j) "(d_i,w_j)")](http://www.codecogs.com/eqnedit.php?latex=(d_i,w_j))的联合分布为\
![](http://img.my.csdn.net/uploads/201212/20/1355968213_3980.JPG)\
而[![](http://latex.codecogs.com/gif.latex?P(z_k%7Cd_i) "P(z_k|d_i)")](http://www.codecogs.com/eqnedit.php?latex=P(z_k%7Cd_i))和[![](http://latex.codecogs.com/gif.latex?P(w_j%7Cz_k) "P(w_j|z_k)")](http://www.codecogs.com/eqnedit.php?latex=P(w_j%7Cz_k))分布对应了两组Multinomial
分布，我们需要估计这两组分布的参数。下面给出用EM算法估计PLSA参数的详细推导过程。\
3 Estimate parameters in PLSA  by EM\
如[文本语言模型的参数估计-最大似然估计、MAP及贝叶斯估计](http://blog.csdn.net/yangliuy/article/details/8296481)一文所述，常用的参数估计方法有MLE、MAP、贝叶斯估计等等。但是在PLSA中，如果我们试图直接用MLE来估计参数，就会得到似然函数\
[![](http://latex.codecogs.com/gif.latex?L%20=%20%5CSigma_%7Bi=1%7D%5EN%5CSigma_%7Bj=1%7D%5EM%20n(d_i,%20w_j)%5Clog%20p(d_i,%20w_j)%5Cpropto%20%5CSigma_%7Bi=1%7D%5EN%5CSigma_%7Bj=1%7D%5EM%20n(d_i,%20w_j)%5Clog%20%5B%5CSigma_%7Bk%20=%201%7D%5EKp(w_j%7Cz_k)p(z_k%7Cd_i)%5D "L = \Sigma_{i=1}^N\Sigma_{j=1}^M n(d_i, w_j)\log p(d_i, w_j)\propto \Sigma_{i=1}^N\Sigma_{j=1}^M n(d_i, w_j)\log [\Sigma_{k = 1}^Kp(w_j|z_k)p(z_k|d_i)]")](http://www.codecogs.com/eqnedit.php?latex=L%20=%20%5CSigma_%7Bi=1%7D%5EN%5CSigma_%7Bj=1%7D%5EM%20n(d_i,%20w_j)%5Clog%20p(d_i,%20w_j)%5Cpropto%20%5CSigma_%7Bi=1%7D%5EN%5CSigma_%7Bj=1%7D%5EM%20n(d_i,%20w_j)%5Clog%20%5B%5CSigma_%7Bk%20=%201%7D%5EKp(w_j%7Cz_k)p(z_k%7Cd_i)%5D)\
其中[![](http://latex.codecogs.com/gif.latex?n(d_i,w_j) "n(d_i,w_j)")](http://www.codecogs.com/eqnedit.php?latex=n(d_i,w_j))是单词[![](http://latex.codecogs.com/gif.latex?w_j "w_j")](http://www.codecogs.com/eqnedit.php?latex=w_j)出现在文档[![](http://latex.codecogs.com/gif.latex?d_i "d_i")](http://www.codecogs.com/eqnedit.php?latex=d_i)中的次数。注意这是一个关于[![](http://latex.codecogs.com/gif.latex?P(z_k%7Cd_i) "P(z_k|d_i)")](http://www.codecogs.com/eqnedit.php?latex=P(z_k%7Cd_i))和[![](http://latex.codecogs.com/gif.latex?P(w_j%7Cz_k) "P(w_j|z_k)")](http://www.codecogs.com/eqnedit.php?latex=P(w_j%7Cz_k))的函数，一共有N\*K
+
M\*K个自变量，如果直接对这些自变量求偏导数，我们会发现由于自变量包含在对数和中，这个方程的求解很困难。因此对于这样的包含“隐含变量”或者“缺失数据”的概率模型参数估计问题，我们采用EM算法。\
EM算法的步骤是：\
(1)E步骤：求隐含变量Given当前估计的参数条件下的后验概率。\
(2)M步骤：最大化Complete
data对数似然函数的期望，此时我们使用E步骤里计算的隐含变量的后验概率，得到新的参数值。\
两步迭代进行直到收敛。\
先解释一下什么是Incomplete data和complete
data。Zhai老师在一篇经典的EM算法[Notes](http://www.cs.ust.hk/~qyang/Teaching/537/PPT/em-note.pdf)中讲到，当原始数据的似然函数很复杂时，我们通过增加一些隐含变量来增强我们的数据，得到“complete
data”,而“complete
data”的似然函数更加简单，方便求极大值。于是，原始的数据就成了“incomplete
data”。我们将会看到，我们可以通过最大化“complete
data”似然函数的期望来最大化”incomplete
data”的似然函数，以便得到求似然函数最大值更为简单的计算途径。\
针对我们PLSA参数估计问题，在E步骤中，直接使用贝叶斯公式计算隐含变量在当前参数取值条件下的后验概率，有\
![](http://img.my.csdn.net/uploads/201212/20/1355971110_6613.JPG)\
在这个步骤中，我们假定所有的[![](http://latex.codecogs.com/gif.latex?P(z_k%7Cd_i) "P(z_k|d_i)")](http://www.codecogs.com/eqnedit.php?latex=P(z_k%7Cd_i))和[![](http://latex.codecogs.com/gif.latex?P(w_j%7Cz_k) "P(w_j|z_k)")](http://www.codecogs.com/eqnedit.php?latex=P(w_j%7Cz_k))都是已知的，因为初始时随机赋值，后面迭代的过程中取前一轮M步骤中得到的参数值。\
在M步骤中，我们最大化Complete
data对数似然函数的期望。在PLSA中，Incomplete data
是观察到的[![](http://latex.codecogs.com/gif.latex?(d_i,w_j) "(d_i,w_j)")](http://www.codecogs.com/eqnedit.php?latex=(d_i,w_j))，隐含变量是主题[![](http://latex.codecogs.com/gif.latex?z_k "z_k")](http://www.codecogs.com/eqnedit.php?latex=z_k)，那么complete
data就是三元组[![](http://latex.codecogs.com/gif.latex?(d_i,w_j,z_k) "(d_i,w_j,z_k)")](http://www.codecogs.com/eqnedit.php?latex=(d_i,w_j,z_k))，其期望是\
![](http://img.my.csdn.net/uploads/201212/20/1355972206_7028.JPG)\
注意这里[![](http://latex.codecogs.com/gif.latex?(z_k%7Cd_i,w_j) "(z_k|d_i,w_j)")](http://www.codecogs.com/eqnedit.php?latex=(z_k%7Cd_i,w_j))是已知的，取得是前面E步骤里面的估计值。下面我们来最大化期望，这又是一个多元函数求极值的问题，可以用拉格朗日乘数法。拉格朗日乘数法可以把条件极值问题转化为无条件极值问题，在PLSA中目标函数就是[![](http://latex.codecogs.com/gif.latex?E(L%5Ec) "E(L^c)")](http://www.codecogs.com/eqnedit.php?latex=E(L%5Ec)),约束条件是\
[![](http://latex.codecogs.com/gif.latex?%5Cbegin%7Baligned%7D%20&%5CSigma_%7Bj=1%7D%5EMp(w_j%7Cz_k)%20=%201%5C%5C%20&%5CSigma_%7Bk=1%7D%5EKp(z_k%7Cd_i)%20=%201%20%5Cend%7Baligned%7D "\begin{aligned} &\Sigma_{j=1}^Mp(w_j|z_k) = 1\\ &\Sigma_{k=1}^Kp(z_k|d_i) = 1 \end{aligned}")](http://www.codecogs.com/eqnedit.php?latex=%5Cbegin%7Baligned%7D%20&%5CSigma_%7Bj=1%7D%5EMp(w_j%7Cz_k)%20=%201%5C%5C%20&%5CSigma_%7Bk=1%7D%5EKp(z_k%7Cd_i)%20=%201%20%5Cend%7Baligned%7D)\
由此我们可以写出拉格朗日函数\
![](http://img.my.csdn.net/uploads/201212/20/1355973171_1946.JPG)\
这是一个关于[![](http://latex.codecogs.com/gif.latex?P(z_k%7Cd_i) "P(z_k|d_i)")](http://www.codecogs.com/eqnedit.php?latex=P(z_k%7Cd_i))和[![](http://latex.codecogs.com/gif.latex?P(w_j%7Cz_k) "P(w_j|z_k)")](http://www.codecogs.com/eqnedit.php?latex=P(w_j%7Cz_k))的函数，分别对其求偏导数，我们可以得到\
![](http://img.my.csdn.net/uploads/201212/20/1355973625_1925.JPG)\
注意这里进行过方程两边同时乘以[![](http://latex.codecogs.com/gif.latex?P(w_j%7Cz_k) "P(w_j|z_k)")](http://www.codecogs.com/eqnedit.php?latex=P(w_j%7Cz_k))和[![](http://latex.codecogs.com/gif.latex?P(z_k%7Cd_i) "P(z_k|d_i)")](http://www.codecogs.com/eqnedit.php?latex=P(z_k%7Cd_i))的变形，联立上面4组方程，我们就可以解出M步骤中通过最大化期望估计出的新的参数值\
![](http://img.my.csdn.net/uploads/201212/20/1355973818_4258.JPG)\
解方程组的关键在于先求出[![](http://latex.codecogs.com/gif.latex?%5Ctau_k,%5Crho_i "\tau_k,\rho_i")](http://www.codecogs.com/eqnedit.php?latex=%5Ctau_k,%5Crho_i),其实只需要做一个加和运算就可以把[![](http://latex.codecogs.com/gif.latex?%5Ctau_k,%5Crho_i "\tau_k,\rho_i")](http://www.codecogs.com/eqnedit.php?latex=%5Ctau_k,%5Crho_i)的系数都化成1，后面就好计算了。\
然后使用更新后的参数值，我们又进入E步骤，计算隐含变量[![](http://latex.codecogs.com/gif.latex?z_k "z_k")](http://www.codecogs.com/eqnedit.php?latex=z_k) Given当前估计的参数条件下的后验概率。如此不断迭代，直到满足终止条件。\
注意到我们在M步骤中还是使用对Complete
Data的MLE，那么如果我们想加入一些先验知识进入我们的模型，我们可以在M步骤中使用MAP估计。正如[文本语言模型的参数估计-最大似然估计、MAP及贝叶斯估计](http://blog.csdn.net/yangliuy/article/details/8296481)中投硬币的二项分布实验中我们加入“硬币一般是两面均匀的”这个先验一样。而由此计算出的参数的估计值会在分子分母中多出关于先验参数的preduo
counts,其他步骤都是一样的。具体可以参考Mei Qiaozhu
的[Notes](http://sifaka.cs.uiuc.edu/course/410s12/plsa-note.pdf)。\
PLSA的实现也不难，网上有很多实现code。\
4 Estimate parameters in a simple mixture unigram language model by EM\
在PLSA的参数估计中，我们使用了EM算法。EM算法经常用来估计包含“缺失数据”或者“隐含变量”模型的参数估计问题。这两个概念是互相联系的，当我们的模型中有“隐含变量”时，我们会认为原始数据是“不完全的数据”，因为隐含变量的值无法观察到；反过来，当我们的数据incomplete时，我们可以通过增加隐含变量来对“缺失数据”建模。\
为了加深对EM算法的理解，下面我们来看如何用EM算法来估计一个简单混合unigram语言模型的参数。本部分主要参考Zhai老师的EM算法[Notes](http://www.cs.ust.hk/~qyang/Teaching/537/PPT/em-note.pdf)。\
4.1 最大似然估计与隐含变量引入\
所谓unigram语言模型，就是构建语言模型是抛弃所有上下文信息，认为一个词出现的概率与其所在位置无关，具体概率图模型可以参见[LDA及Gibbs
Samping](http://blog.csdn.net/yangliuy/article/details/8302599)一文中的介绍。什么是混合模型(mixture
model)呢？通俗的说混合概率模型就是由最基本的概率分布比如正态分布、多元分布等经过线性组合形成的新的概率模型，比如混合高斯模型就是由K个高斯分布线性组合而得到。混合模型中产生数据的确切“component
model”对我们是隐藏的。我们假设混合模型包含两个multinomial component
model,一个是背景词生成模型[![](http://latex.codecogs.com/gif.latex?p(w%7CC) "p(w|C)")](http://www.codecogs.com/eqnedit.php?latex=p(w%7CC)),另一个是主题词生成模型[![](http://latex.codecogs.com/gif.latex?p(w%7C%5Ctheta_F) "p(w|\theta_F)")](http://www.codecogs.com/eqnedit.php?latex=p(w%7C%5Ctheta_F))。注意这种模型组成方式在概率语言模型中很常见，比如在TwitterLDA中使用的背景词和主题词两个多元分布；TimeUserLDA中使用的Global
Topic 和Personal
Topic两个多元分布，都是这类模型。为了表示单词是哪个模型生成的，我们会为每个单词增加一个布尔类型的控制变量。\
文档的对数似然函数为\
![](http://img.my.csdn.net/uploads/201212/20/1355985023_6924.JPG)\
[![](http://latex.codecogs.com/gif.latex?d_%7Bij%7D "d_{ij}")](http://www.codecogs.com/eqnedit.php?latex=d_%7Bij%7D)为第i个文档中的第j个词，[![](http://latex.codecogs.com/gif.latex?%5Clambda "\lambda")](http://www.codecogs.com/eqnedit.php?latex=%5Clambda)为表示文档中背景词比例的参数，通常根据经验给定。因此[![](http://latex.codecogs.com/gif.latex?%5Clambda "\lambda")](http://www.codecogs.com/eqnedit.php?latex=%5Clambda)是已知的，我们只需要估计[![](http://latex.codecogs.com/gif.latex?p(w%7C%5Ctheta_F) "p(w|\theta_F)")](http://www.codecogs.com/eqnedit.php?latex=p(w%7C%5Ctheta_F))即可。\
同样的我们首先试图用最大似然估计来估计参数。也就是去找最大化似然函数的参数值，有\
![](http://img.my.csdn.net/uploads/201212/20/1355985495_3018.JPG)\
这是一个关于[![](http://latex.codecogs.com/gif.latex?p(w%7C%5Ctheta_F) "p(w|\theta_F)")](http://www.codecogs.com/eqnedit.php?latex=p(w%7C%5Ctheta_F))的函数，同样的，[![](http://latex.codecogs.com/gif.latex?p(w%7C%5Ctheta_F) "p(w|\theta_F)")](http://www.codecogs.com/eqnedit.php?latex=p(w%7C%5Ctheta_F))包含在了对数和中。因此很难求解极大值，用拉格朗日乘数法，你会发现偏导数等于0得到的方程很难求解。所以我们需要依赖数值算法，而EM算法就是其中常用的一种。\
我们为每个单词引入一个布尔类型的变量z表示该单词是background word
还是topic word.即\
![](http://img.my.csdn.net/uploads/201212/20/1355986103_7471.JPG)\
这里我们假设”complete
data”不仅包含可以观察到F中的所有单词，而且还包括隐含的变量z。那么根据EM算法，在E步骤我们计算“complete
data”的对数似然函数有\
![](http://img.my.csdn.net/uploads/201212/20/1355986325_6765.JPG)\
比较一下[![](http://latex.codecogs.com/gif.latex?L_c(%5Ctheta_F) "L_c(\theta_F)")](http://www.codecogs.com/eqnedit.php?latex=L_c(%5Ctheta_F))和[![](http://latex.codecogs.com/gif.latex?L(%5Ctheta_F) "L(\theta_F)")](http://www.codecogs.com/eqnedit.php?latex=L(%5Ctheta_F))，求和运算在对数之外进行，因为此时通过控制变量z的设置，我们明确知道了单词是由背景词分布还是topic
词分布产生的。[![](http://latex.codecogs.com/gif.latex?L_c(%5Ctheta_F) "L_c(\theta_F)")](http://www.codecogs.com/eqnedit.php?latex=L_c(%5Ctheta_F))和[![](http://latex.codecogs.com/gif.latex?L(%5Ctheta_F) "L(\theta_F)")](http://www.codecogs.com/eqnedit.php?latex=L(%5Ctheta_F))的关系是怎样的呢？如果带估计参数是[![](http://latex.codecogs.com/gif.latex?%5Ctheta "\theta")](http://www.codecogs.com/eqnedit.php?latex=%5Ctheta),原始数据是X，对于每一个原始数据分配了一个隐含变量H，则有\
![](http://img.my.csdn.net/uploads/201212/20/1355986747_6560.JPG)\
![](http://img.my.csdn.net/uploads/201212/20/1355986754_3631.JPG)\
4.2 似然函数的下界分析\
EM算法的基本思想就是初始随机给定待估计参数的值，然后通过E步骤和M步骤两步迭代去不断搜索更好的参数值。更好的参数值应该要满足使得似然函数更大。我们假设一个潜在的更好参数值是[![](http://latex.codecogs.com/gif.latex?%5Ctheta "\theta")](http://www.codecogs.com/eqnedit.php?latex=%5Ctheta)，第n次迭代M步骤得到的参数估计值是[![](http://latex.codecogs.com/gif.latex?%5Ctheta%5E%7B(n)%7D "\theta^{(n)}")](http://www.codecogs.com/eqnedit.php?latex=%5Ctheta%5E%7B(n)%7D),那么两个参数值对应的似然函数和”complete
data”的似然函数的差满足\
![](http://img.my.csdn.net/uploads/201212/20/1355987343_1590.JPG)\
我们寻找更好参数值的目标就是要最大化[![](http://latex.codecogs.com/gif.latex?L(%5Ctheta)%20-%20L(%5Ctheta%5E%7B(n)%7D) "L(\theta) - L(\theta^{(n)})")](http://www.codecogs.com/eqnedit.php?latex=L(%5Ctheta)%20-%20L(%5Ctheta%5E%7B(n)%7D)),也等价于最大化[![](http://latex.codecogs.com/gif.latex?L(%5Ctheta) "L(\theta)")](http://www.codecogs.com/eqnedit.php?latex=L(%5Ctheta))。我们来计算隐含变量在给定当前数据X和当前估计的参数值[![](http://latex.codecogs.com/gif.latex?%5Ctheta%5E%7B(n)%7D "\theta^{(n)}")](http://www.codecogs.com/eqnedit.php?latex=%5Ctheta%5E%7B(n)%7D)条件下的条件概率分布即[![](http://latex.codecogs.com/gif.latex?p(H%7CX,%5Ctheta%5E%7B(n)%7D) "p(H|X,\theta^{(n)})")](http://www.codecogs.com/eqnedit.php?latex=p(H%7CX,%5Ctheta%5E%7B(n)%7D))，有\
![](http://img.my.csdn.net/uploads/201212/20/1355987913_5510.JPG)\
其中右边第三项是[![](http://latex.codecogs.com/gif.latex?p(H%7CX,%5Ctheta%5E%7B(n)%7D) "p(H|X,\theta^{(n)})")](http://www.codecogs.com/eqnedit.php?latex=p(H%7CX,%5Ctheta%5E%7B(n)%7D))和[![](http://latex.codecogs.com/gif.latex?p(H%7CX,%5Ctheta) "p(H|X,\theta)")](http://www.codecogs.com/eqnedit.php?latex=p(H%7CX,%5Ctheta))的相对熵，总为非负值。因此我们有\
![](http://img.my.csdn.net/uploads/201212/20/1355988047_8941.JPG)\
![](http://img.my.csdn.net/uploads/201212/20/1355988052_2612.JPG)\
于是我们得到了潜在更好参数值[![](http://latex.codecogs.com/gif.latex?%5Ctheta "\theta")](http://www.codecogs.com/eqnedit.php?latex=%5Ctheta)的incomplete
data似然函数的下界。这里我们尤其要注意右边后两项为常数，因为不包含[![](http://latex.codecogs.com/gif.latex?%5Ctheta "\theta")](http://www.codecogs.com/eqnedit.php?latex=%5Ctheta)。所以incomplete
data似然函数的下界就是complete
data似然函数的期望，也就是诸多EM算法讲义中出现的Q函数，表达式为\
![](http://img.my.csdn.net/uploads/201212/20/1355988576_8854.JPG)\
可以看出这个期望等于complete
data似然函数乘以对应隐含变量条件概率再求和。对于我们要求解的问题，Q函数就是\
![](http://img.my.csdn.net/uploads/201212/20/1355988728_3028.JPG)\
这里多解释几句Q函数。单词相应的变量z为0时，单词为topic
word,从多元分布[![](http://latex.codecogs.com/gif.latex?%5Ctheta_F "\theta_F")](http://www.codecogs.com/eqnedit.php?latex=%5Ctheta_F)中产生；当z为1时，单词为background
word,从多元分布[![](http://latex.codecogs.com/gif.latex?%5Ctheta "\theta")](http://www.codecogs.com/eqnedit.php?latex=%5Ctheta)产生。同时我们也可以看到如何求Q函数即complete
data似然函数的期望，也就是我们要最大化的那个期望(EM算法最大化期望指的就是这个期望)，我们要特别关注隐含变量在观察到数据X和前一轮估计出的参数值[![](http://latex.codecogs.com/gif.latex?%5Ctheta%5E%7B(n)%7D "\theta^{(n)}")](http://www.codecogs.com/eqnedit.php?latex=%5Ctheta%5E%7B(n)%7D)条件下取不同值的概率，而隐含变量不同的值对应complete
data的不同的似然函数，我们要计算的所谓的期望就是指complete
data的似然函数值在不同隐含变量取值情况下的期望值。\
4.3 EM算法的一般步骤\
通过4.2部分的分析，我们知道，如果我们在下一轮迭代中可以找到一个更好的参数值[![](http://latex.codecogs.com/gif.latex?%5Ctheta%5E%7B(n+1)%7D "\theta^{(n+1)}")](http://www.codecogs.com/eqnedit.php?latex=%5Ctheta%5E%7B(n@plus;1)%7D)使得\
![](http://img.my.csdn.net/uploads/201212/20/1355989811_9961.JPG)\
那么相应的也会有[![](http://latex.codecogs.com/gif.latex?L(%5Ctheta%5E%7B(n+1)%7D)%20%3E%20L(%5Ctheta%5E%7B(n)%7D) "L(\theta^{(n+1)}) > L(\theta^{(n)})")](http://www.codecogs.com/eqnedit.php?latex=L(%5Ctheta%5E%7B(n@plus;1)%7D)%20%3E%20L(%5Ctheta%5E%7B(n)%7D))，因此EM算法的一般步骤如下\
(1)
随机初始化参数值[![](http://latex.codecogs.com/gif.latex?%5Ctheta%5E%7B(0)%7D "\theta^{(0)}")](http://www.codecogs.com/eqnedit.php?latex=%5Ctheta%5E%7B(0)%7D)，也可以根据任何关于最佳参数取值范围的先验知识来初始化[![](http://latex.codecogs.com/gif.latex?%5Ctheta%5E%7B(0)%7D "\theta^{(0)}")](http://www.codecogs.com/eqnedit.php?latex=%5Ctheta%5E%7B(0)%7D)。\
(2)
不断两步迭代寻找更优的参数值[![](http://latex.codecogs.com/gif.latex?%5Ctheta%5E%7B(n+1)%7D "\theta^{(n+1)}")](http://www.codecogs.com/eqnedit.php?latex=%5Ctheta%5E%7B(n@plus;1)%7D)：\
(a) E步骤（求期望） 计算Q函数\
![](http://img.my.csdn.net/uploads/201212/20/1355988576_8854.JPG)\
(b)M步骤（最大化）通过最大化Q函数来寻找更优的参数值[![](http://latex.codecogs.com/gif.latex?%5Ctheta%5E%7B(n+1)%7D "\theta^{(n+1)}")](http://www.codecogs.com/eqnedit.php?latex=%5Ctheta%5E%7B(n@plus;1)%7D)\
![](http://img.my.csdn.net/uploads/201212/20/1355990524_2125.JPG)\
(3)
当似然函数[![](http://latex.codecogs.com/gif.latex?L(%5Ctheta) "L(\theta)")](http://www.codecogs.com/eqnedit.php?latex=L(%5Ctheta))收敛时算法停止。\
这里需要注意如何尽量保证EM算法可以找到全局最优解而不是局部最优解呢？第一种方法是尝试许多不同的参数初始值，然后从得到的很多估计出的参数值中选取最优的；第二种方法是通过一个更简单的模型比如只有唯一全局最大值的模型来决定复杂模型的初始值。\
通过前面的分析可以知道，EM算法的优势在于complete
data的似然函数[![](http://latex.codecogs.com/gif.latex?L_c(%7B%5Ctheta%7D) "L_c({\theta})")](http://www.codecogs.com/eqnedit.php?latex=L_c(%7B%5Ctheta%7D))更容易最大化，因为已经假定了隐含变量的取值，当然要乘以隐含变量取该值的条件概率，所以最终变成了最大化期望值。由于隐含变量变成了已知量，Q函数比原始incomplete
data的似然函数更容易求最大值。因此对于“缺失数据”的情况，我们通过引入隐含变量使得complete
data的似然函数容易最大化。\
在E步骤中，主要的计算难点在于计算隐含变量的条件概率[![](http://latex.codecogs.com/gif.latex?p(H%7CX,%5Ctheta%5E%7B(n)%7D) "p(H|X,\theta^{(n)})")](http://www.codecogs.com/eqnedit.php?latex=p(H%7CX,%5Ctheta%5E%7B(n)%7D))，在PLSA中就是\
![](http://img.my.csdn.net/uploads/201212/20/1355971110_6613.JPG)\
在我们这个简单混合语言模型的例子中就是\
![](http://img.my.csdn.net/uploads/201212/20/1355991377_3324.JPG)\
![](http://img.my.csdn.net/uploads/201212/20/1355991382_6127.JPG)\
我们假设z的取值只于当前那一个单词有关，计算很容易，但是在LDA中用这种方法计算隐含变量的条件概率和最大化Q函数就比较复杂，可以参见原始LDA论文的参数推导部分。我们也可以用更简单的Gibbs
Sampling来估计参数，具体可以参见[LDA及Gibbs
Samping](http://blog.csdn.net/yangliuy/article/details/8302599)。\
继续我们的问题，下面便是M步骤。使用拉格朗日乘数法来求Q函数的最大值，约束条件是\
![](http://img.my.csdn.net/uploads/201212/20/1355992140_1162.JPG)\
构造拉格朗日辅助函数\
![](http://img.my.csdn.net/uploads/201212/20/1355992150_2283.JPG)\
对自变量[![](http://latex.codecogs.com/gif.latex?p(w%7C%5Ctheta_F) "p(w|\theta_F)")](http://www.codecogs.com/eqnedit.php?latex=p(w%7C%5Ctheta_F))求偏导数\
![](http://img.my.csdn.net/uploads/201212/20/1355992156_7677.JPG)\
令偏导数为0解出来唯一的极值点\
![](http://img.my.csdn.net/uploads/201212/20/1355992161_2410.JPG)\
容易知道这里唯一的极值点就是最值点了。注意这里Zhai老师变换了一下变量表示，把对文档里面词的遍历转化成了对词典里面的term的遍历，因为z的取值至于对应的那一个单词有关，与上下文无关。因此E步骤求隐含变量的条件概率公式也相应变成了\
![](http://img.my.csdn.net/uploads/201212/20/1355992166_8866.JPG)\
最后我们就得到了简单混合Unigram语言模型的EM算法更新公式\
即E步骤 求隐含变量条件概率和M步骤 最大化期望估计参数的公式\
![](http://img.my.csdn.net/uploads/201212/20/1355992171_3845.JPG)\
整个计算过程我们可以看到，我们不需要明确求出Q函数的表达式。取而代之的是我们计算隐含变量的条件概率，然后通过最大化Q函数来得到新的参数估计值。\
因此EM算法两步迭代的过程实质是在寻找更好的待估计参数的值使得原始数据即incomplete
data似然函数的下界不断提升，而这个“下界“就是引入隐含变量之后的complete
data似然函数的期望，也就是诸多EM算法讲义中出现的Q函数，通过最大化Q函数来寻找更优的参数值。同时，上一轮估计出的参数值会在下一轮E步骤中当成已知条件计算隐含变量的条件概率，而这个条件概率又是最大化Q函数求新的参数值是所必需的。\
5 Estimate parameters in GMM by EM\
经过第3部分和第4部分用EM算法求解PLSA和简单unigram混合模型参数估计问题的详细分析，相信大部分读者已经对EM算法有了一定理解。关于EM算法的材料包括PRML会首先介绍用EM算法去求解混合高斯模型GMM的参数估计问题。下面就让我们来看看如何用EM算法来求解混合高斯模型GMM。\
混合高斯模型GMM由K个高斯模型的线性组合组成，高斯模型就是正态分布模型，其中每个高斯模型我们成为一个”Component“，GMM的概率密度函数就是这K个高斯模型概率密度函数的线性组合即\
![](http://img.my.csdn.net/uploads/201212/20/1356010844_5490.JPG)\
其中\
![](http://img.my.csdn.net/uploads/201212/20/1356011218_7035.JPG)\
就是高斯分布即正态分布的概率密度函数。这是x为向量的情况，对于x为标量的情况就是\
![](http://img.my.csdn.net/uploads/201212/20/1356011225_1810.JPG)\
大部分读者应该对标量情形的概率分布更熟悉。这里啰嗦几句，最近看机器学习的论文和书籍，里面的随机变量基本都是多维向量，向量的计算比如加减乘除和求导运算都和标量运算有一些区别，尤其是求导运算，向量和矩阵的求导运算会麻烦很多，看pluskid推荐的一本册子Matrix
Cookbook,里面有很多矩阵求导公式，直接查阅应该会更方便。\
下面继续说GMM。根据上面给出的概率密度函数，如果我们要从 GMM
的分布中Sample一个样本，实际上可以分为两步：首先随机地在这 ![K](http://blog.pluskid.org/latexrender/pictures/a5f3c6a11b03839d46af9fb43c97c188.png "K") 个
Component 之中选一个，每个 Component
被选中的概率实际上就是它的系数 ![\\pi\_k](http://blog.pluskid.org/latexrender/pictures/18db600e9b6993dd9ec8642eb24695dd.png "\pi_k") ，选中了
Component 之后，再单独地考虑从这个 Component
的分布中选取一个样本点就可以了。在PRML上，引入了一个K维二值随机变量z,只有1维是1，其他维都是0。唯一那个非零的维对应的就是GMM参数样本时被选中的那个高斯分布，而某一维非零的概率就是![\\pi\_k](http://blog.pluskid.org/latexrender/pictures/18db600e9b6993dd9ec8642eb24695dd.png "\pi_k")，即\
![](http://img.my.csdn.net/uploads/201212/20/1356012787_5909.JPG)\
下面我们开始估计GMM的参数，包括这K个高斯分布的所有均值和方差以及线性组合的系数。我们给每个样本数据增加一个隐含变量[![](http://latex.codecogs.com/gif.latex?z_n "z_n")](http://www.codecogs.com/eqnedit.php?latex=z_n),
就是上面所说的K维向量，表明了[![](http://latex.codecogs.com/gif.latex?x_n "x_n")](http://www.codecogs.com/eqnedit.php?latex=x_n)是从哪个高斯分布中sample出来的。对应的概率图模型就是\
![](http://img.my.csdn.net/uploads/201212/20/1356013504_2063.JPG)\
观察变量的对数似然函数为\
![](http://img.my.csdn.net/uploads/201212/20/1356013633_3355.JPG)\
令对[![](http://latex.codecogs.com/gif.latex?%5Cmu_k "\mu_k")](http://www.codecogs.com/eqnedit.php?latex=%5Cmu_k)的偏导数等于0我们有\
![](http://img.my.csdn.net/uploads/201212/20/1356014058_1383.JPG)\
注意这里我们定义了[![](http://latex.codecogs.com/gif.latex?%5Cgamma(z_%7Bnk%7D) "\gamma(z_{nk})")](http://www.codecogs.com/eqnedit.php?latex=%5Cgamma(z_%7Bnk%7D))表示后验概率[![](http://latex.codecogs.com/gif.latex?p(z_k=1%7Cx) "p(z_k=1|x)")](http://www.codecogs.com/eqnedit.php?latex=p(z_k=1%7Cx))，也就是第n个样本是有第k个高斯分布产生的概率。可以解出\
![](http://img.my.csdn.net/uploads/201212/20/1356014386_7950.JPG)\
[![](http://latex.codecogs.com/gif.latex?N_k "N_k")](http://www.codecogs.com/eqnedit.php?latex=N_k)就是由第K个高斯分布产生的样本点的总数；用聚类的观点看，就是聚到cluster
k的样本点总数。然后我们将对数似然函数对[![](http://latex.codecogs.com/gif.latex?%5CSigma_k "\Sigma_k")](http://www.codecogs.com/eqnedit.php?latex=%5CSigma_k)求偏导数，令偏导数为0，得到协方差矩阵\
\
![](http://img.my.csdn.net/uploads/201212/20/1356014849_9305.JPG)\
最后我们求系数![\\pi\_k](http://blog.pluskid.org/latexrender/pictures/18db600e9b6993dd9ec8642eb24695dd.png "\pi_k")。注意到系数的和为1，即\
![](http://img.my.csdn.net/uploads/201212/20/1356015004_2006.JPG)\
这就是约束条件，最大化对数似然函数又成为了条件极值问题。我们仍然用拉格朗日乘数法，构造辅助函数如下\
![](http://img.my.csdn.net/uploads/201212/20/1356015110_3612.JPG)\
对[![](http://latex.codecogs.com/gif.latex?%5Cpi_k "\pi_k")](http://www.codecogs.com/eqnedit.php?latex=%5Cpi_k)求导数，令导数为0有\
![](http://img.my.csdn.net/uploads/201212/20/1356015212_6155.JPG)![](http://img.my.csdn.net/uploads/201212/20/1356015219_4330.JPG)\
\
这样我们就估计出来系数项。\
因此用EM算法估计GMM参数的步骤如下\
(1) E步骤：估计数据由每个 Component
生成的概率:对于每个数据[![](http://latex.codecogs.com/gif.latex?x_n "x_n")](http://www.codecogs.com/eqnedit.php?latex=x_n)  来说，它由第 ![k](http://blog.pluskid.org/latexrender/pictures/8ce4b16b22b58894aa86c421e8759df3.png "k") 个
Component 生成的概率为\
![](http://img.my.csdn.net/uploads/201212/20/1356015662_8215.JPG)\
注意里面 ![\\mu\_k](http://blog.pluskid.org/latexrender/pictures/c593ae692832e500a04c7f47900f689a.png "\mu_k") 和 ![\\Sigma\_k](http://blog.pluskid.org/latexrender/pictures/d6dec39b28ae3ddd249138e5f59596df.png "\Sigma_k") 也是需要我们估计的值，在E步骤我们假定 ![\\mu\_k](http://blog.pluskid.org/latexrender/pictures/c593ae692832e500a04c7f47900f689a.png "\mu_k") 和 ![\\Sigma\_k](http://blog.pluskid.org/latexrender/pictures/d6dec39b28ae3ddd249138e5f59596df.png "\Sigma_k") 均已知，我们使用上一次迭代所得的值（或者初始值）。\
(2)M步骤：由最大估计求出高斯分布的所有均值、方差和线性组合的系数，更新待估计的参数值，根据上面的推导，计算公式是\
![](http://img.my.csdn.net/uploads/201212/20/1356015669_3581.JPG)\
其中\
![](http://img.my.csdn.net/uploads/201212/20/1356015674_8947.JPG)\
(3)重复迭代E步骤和M步骤，直到似然函数\
![](http://img.my.csdn.net/uploads/201212/20/1356015680_6301.JPG)\
收敛时算法停止。\
更多关于EM算法的深入分析，可以参考PRML第9章内容。\
6 全文总结\
本文主要介绍PLSA及EM算法，首先给出LSA（隐性语义分析）的早期方法SVD，然后引入基于概率的PLSA模型，接着我们详细分析了如何用EM算法估计PLSA、混合unigram
语言模型及混合高斯模型的参数过程，并总结了EM算法的一般形式和运用关键点。关于EM算法收敛性的证明可以参考斯坦福机器学习课程CS229
Andrew
Ng老师的课程notes和[JerryLead](http://www.cnblogs.com/jerrylead/archive/2011/04/06/2006936.html)的笔记。EM算法在”缺失数据“和包含”隐含变量“的概率模型参数估计问题中非常常用，是机器学习、数据挖掘及NLP研究必须掌握的算法。\
参考文献及推荐Notes\
本文主要参考了Hoffman的PLSA论文、Zhai老师的EM Notes以及PRML第9章内容。\
[1] Christopher M. Bishop. Pattern Recognition and Machine Learning
(Information Science and Statistics). Springer-Verlag New York, Inc.,
Secaucus, NJ, USA, 2006.\
\
[2] Gregor Heinrich. Parameter estimation for text analysis. Technical
report, 2004.\
[3] Wayne Xin Zhao, Note for pLSA and LDA, Technical report, 2011.\
[4] Freddy Chong Tat Chua. Dimensionality reduction and clustering of
text documents.Technical report, 2009.\
[5] CX Zhai, [A note on the expectation-maximization (em)
algorithm](http://citeseerx.ist.psu.edu/viewdoc/download?doi=10.1.1.149.8289&rep=rep1&type=pdf) 2007\
[6] Qiaozhu Mei, [A Note on EM Algorithm for Probabilistic Latent
Semantic
Analysis](http://sifaka.cs.uiuc.edu/course/410s12/plsa-note.pdf) 2008\
[7] pluskid, 漫谈Clustering, Gaussina Mixture Model\
[8] [Christopher D.
Manning](http://nlp.stanford.edu/~manning/), [Prabhakar
Raghavan](http://theory.stanford.edu/~pragh/) and [Hinrich
Schütze](http://gelbaugenpinguin.ims.uni-stuttgart.de/wiki/extern/HinrichSchuetze), Introduction
to Information Retrieval, Cambridge University Press. 2008.\
更多语言模型相关文章见http://blog.csdn.net/yangliuy/\

相关文章:\

1.  [概率语言模型及其变形系列-LDA及Gibbs
    Sampling](http://www.52nlp.cn/%e6%a6%82%e7%8e%87%e8%af%ad%e8%a8%80%e6%a8%a1%e5%9e%8b%e5%8f%8a%e5%85%b6%e5%8f%98%e5%bd%a2%e7%b3%bb%e5%88%97-lda%e5%8f%8agibbs-sampling "概率语言模型及其变形系列-LDA及Gibbs Sampling")
2.  [MIT自然语言处理第三讲：概率语言模型（第六部分）](http://www.52nlp.cn/mit-nlp-third-lesson-probabilistic-language-modeling-sixth-part "MIT自然语言处理第三讲：概率语言模型（第六部分）")
3.  [MIT自然语言处理第三讲：概率语言模型（第四部分）](http://www.52nlp.cn/mit-nlp-third-lesson-probabilistic-language-modeling-fourth-part "MIT自然语言处理第三讲：概率语言模型（第四部分）")
4.  [MIT自然语言处理第三讲：概率语言模型（第五部分）](http://www.52nlp.cn/mit-nlp-third-lesson-probabilistic-language-modeling-fifth-part "MIT自然语言处理第三讲：概率语言模型（第五部分）")
5.  [MIT自然语言处理第三讲：概率语言模型（第三部分）](http://www.52nlp.cn/mit-nlp-third-lesson-probabilistic-language-modeling-third-part "MIT自然语言处理第三讲：概率语言模型（第三部分）")
6.  [MIT自然语言处理第四讲：标注（第二部分）](http://www.52nlp.cn/mit-nlp-fourth-lesson-tagging-second-part "MIT自然语言处理第四讲：标注（第二部分）")
7.  [Beautiful
    Data-统计语言模型的应用三：分词6](http://www.52nlp.cn/beautiful-data-%e7%bb%9f%e8%ae%a1%e8%af%ad%e8%a8%80%e6%a8%a1%e5%9e%8b%e7%9a%84%e5%ba%94%e7%94%a8%e4%b8%89%e5%88%86%e8%af%8d6 "Beautiful Data-统计语言模型的应用三：分词6")
8.  [From Google Research Blog: Google at ACL
    2011](http://www.52nlp.cn/from-google-research-blog-google-at-acl-2011 "From Google Research Blog: Google at ACL 2011")
9.  [斯坦福大学机器学习第九课“神经网络的学习(Neural Networks:
    Learning)”](http://www.52nlp.cn/%e6%96%af%e5%9d%a6%e7%a6%8f%e5%a4%a7%e5%ad%a6%e6%9c%ba%e5%99%a8%e5%ad%a6%e4%b9%a0%e7%ac%ac%e4%b9%9d%e8%af%be%e7%a5%9e%e7%bb%8f%e7%bd%91%e7%bb%9c%e7%9a%84%e5%ad%a6%e4%b9%a0neural-networks-le "斯坦福大学机器学习第九课“神经网络的学习(Neural Networks: Learning)”")
10. [MIT自然语言处理第三讲：概率语言模型（第二部分）](http://www.52nlp.cn/mit-nlp-third-lesson-probabilistic-language-modeling-second-part "MIT自然语言处理第三讲：概率语言模型（第二部分）")

![](http://feeds.feedburner.com/~r/52nlp/~4/XLAXGkJth8E)
