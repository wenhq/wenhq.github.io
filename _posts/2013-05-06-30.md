--- layout: post title: 30分钟泛型教程 date:
'2013-05-06T18:29:00.001+08:00' author: Wenh Q tags: modified\_time:
'2013-05-06T18:29:05.639+08:00' blogger\_id:
tag:blogger.com,1999:blog-4961947611491238191.post-6184396118030470483
blogger\_orig\_url: http://binaryware.blogspot.com/2013/05/30.html ---
[30分钟泛型教程](http://blog.jobbole.com/39125/?utm_source=rss&utm_medium=rss&utm_campaign=30%25e5%2588%2586%25e9%2592%259f%25e6%25b3%259b%25e5%259e%258b%25e6%2595%2599%25e7%25a8%258b):\
来源：[liulun
的博客](http://www.cnblogs.com/liulun/archive/2013/05/02/3033599.html)\
**一、泛型入门：**\
我们先来看一个最为常见的泛型类型List&lt;T&gt;的定义\
\
(真正的定义比这个要复杂的多，我这里删掉了很多东西)\

<div>

    [Serializable]
    public class List<T> : IList<T>, ICollection<T>, IEnumerable<T>
    {
        public T this[int index] { get; set; }
        public void Add(T item);
        public void Clear();
        public bool Contains(T item);
        public int IndexOf(T item);
        public bool Remove(T item);
        public void Sort();
        public T[] ToArray();
    }

</div>

List后面紧跟着一个&lt;T&gt;表示它操作的是一个未指定的数据类型\
\
（T代表着一个未指定的数据类型）\
可以把T看作一个变量名，T代表着一个类型，\
\
在List&lt;T&gt;的源代码中任何地方都能使用T\
T被用作方法的参数和返回值\
\
Add方法接收T类型的参数，ToArray方法返回一个T类型的数组\
注意：\
泛型参数必须以T开头，要么就叫T，要么就叫TKey或者TValue；\
\
这跟接口要以I开头是一样的，这是约定。\
下面来看一段使用泛型类型的代码\

<div>

    var a = new List<int>();
                a.Add(1);
                a.Add(2);
                //这是错误的，因为你已经指定了泛型类型为int，就不能在这个容器中放入其他的值
                //这是编译器错误，更提升了排错效率，如果是运行期错误，不知道要多么烦人
                a.Add("3");
                var item = a[2];

</div>

请注意上面代码里的注释\
**二、泛型的作用(1)：**\
作为[程序员](http://blog.jobbole.com/821/ "程序员的本质")，写代码时刻不忘代码重用。\
\
代码重用可以分成很多类，其中**算法重用**就是非常重要的一类\
假设你要为一组整型数据写一个[排序算法](http://blog.jobbole.com/11745/ "排序算法")，又要为一组浮点型数据写一个排序算法\
\
如果没有泛型类型，你会怎么做呢？\
你可能想到了方法的重载\
\
写两个同名方法，一个方法接收整型数组，另一个方法接收浮点型的数组\
但有了泛型，你就完全不必这么做，只要设计一个方法就够用了，你甚至可以用这个方法为一组字符串数据排序\
**三、泛型的作用(2)：**\
假设你是一个方法的设计者，\
\
这个方法需要有一个输入参数，但你并能确定这个输入参数的类型\
\
那么你会怎么做呢？\
有一部分人可能会马上反驳：“不可能有这种时候！”\
\
那么我会跟你说，编程是一门经验型的工作，你的经验还不够，还没有碰到过类似的地方。\
另一部分人可能考虑把这个参数的类型设置成Object的\
\
这确实是一种可行的方案\
\
但会造成下面两个问题\
如果我给这个方法传递整形的数据\
\
（值类型的数据都一样）\
\
就会产生额外的装箱、拆箱操作\
\
造成**性能损耗**\
如果你这个方法里的处理逻辑不适用于字符串的参数\
\
而使用者又传了一个字符串进来\
\
编译器是不会报错的，\
\
只有在运行期才会报错\
\
(如果质管部门没有测出这个运行期BUG，那么不知道要造成多大的损失呢)\
\
这就是我们常说的：**类型不安全**\
**四、泛型的示例：**\
像List&lt;T&gt;和Dictionary&lt;TKey,TValue&gt;之类的泛型类型我们经常用到\
\
下面我介绍几个不常用到的泛型类型\
ObservableCollection&lt;T&gt;\
\
当这个集合发生改变后会有相应的事件得到通知\
\
请看如下代码：\

<div>

    static void Main(string[] args)
    {
        var a = new ObservableCollection<int>();
        a.CollectionChanged += a_CollectionChanged;
    }

    static void a_CollectionChanged(object sender, NotifyCollectionChangedEventArgs e)
    {
        //可以通过Action来判断是什么操作触发了事件
        //e.Action == NotifyCollectionChangedAction.Add

        //可以根据以下两个属性来得到更改前和更改后的内容
        //e.NewItems;
        //e.OldItems;
    }

</div>

使用这个集合需要引用如下两个名称空间\

<div>

    using System.Collections.ObjectModel;
    using System.Collections.Specialized;

</div>

\
BlockingCollection&lt;int&gt;是线程安全的集合\
\
来看看下面这段代码\

<div>

    var bcollec = new BlockingCollection<int>(2);
    //试图添加1-50
    Task.Run(() =>
    {
        //并行循环
        Parallel.For(1, 51, i =>
        {
            bcollec.Add(i);
            Console.WriteLine("加入：" + i);
        });
    });

    Thread.Sleep(1000);
    Console.WriteLine("调用一次Take");
    bcollec.Take();

    //等待无限长时间
    Thread.Sleep(Timeout.Infinite);

</div>

输出结果为：\

<div>

    加入：1
    加入：37
    调用一次Take
    加入：13

</div>

BlockingCollection&lt;int&gt;还可以设置CompleteAdding和IsCompleted属性来拒绝加入新元素\
\
.NET类库还提供了很多的泛型类型，在这里就不一一例举了\
**五、泛型的继承：**\
在.net中一切都继承字Object\
\
泛型也不例外\
\
泛型类型可以继承自其他类型\
\
来看一下如下代码\

<div>

    public class MyType
    {
        public virtual string getOneStr()
        {
            return "base object Str";
        }
    }
    public class MyOtherType<T> : MyType
    {
        public override string getOneStr()
        {
            return typeof(T).ToString();
        }
    }
    class Program
    {
        static void Main(string[] args)
        {
            MyType target = new MyOtherType<int>();
            Console.WriteLine(target.getOneStr());
            Console.ReadKey();
        }
    }

</div>

泛型类型MyOtherType&lt;T&gt;成功的重写了非泛型类型MyType的方法\
\
如果我试图按如下方式从MyOtherType&lt;T&gt;类型派生子类型就会导致编译器错误\

<div>

    //编译期错误
    public class MyThirdType : MyOtherType<T>
    {
    }

</div>

但是如果写成这种方式，就不会出错\

<div>

    public class MyThirdType : MyOtherType<int>
        {
            public override string getOneStr()
            {
                return "MyThirdType";
            }
        }

</div>

**注意：**\
如果按照如上写法，会造成类型不统一的问题\
\
如果一个方法接收MyThirdType类型的参数，\
\
那么不能将一个MyOtherType&lt;int&gt;的实例传递给这个方法\
\
然而一个方法如果接收MyOtherType&lt;int&gt;类型的参数\
\
却可以把MyThirdType类型的实例传递给这个方法\
\
这是CLR内部实现机制造成的\
\
这看起来确实很怪异！\
写成如下方式也不会出错\

<div>

    public class MyThirdType<T> : MyOtherType<T>
        {
            public override string getOneStr()
            {
                return typeof(T).ToString() + " from MyThirdType";
            }
        }

</div>

此中诀窍，只可意会，不可言传\
**六、泛型接口**\
.NET类库里有很多泛型的接口\
\
比如：IEnumerator&lt;T&gt;、IList&lt;T&gt;等\
\
这里不对这些接口做详细描述了\
\
值说说为什么要有泛型接口。\
其实泛型接口出现的原因和泛型出现的原因类似\
\
拿IComparable这个接口来说，\
\
此接口只描述了一个方法：\

<div>

    int CompareTo(object obj);

</div>

大家看到，如果是值类型的参数，势必会导致装箱和拆箱操作\
\
同时，也不是强类型的，不能在编译期确定参数的类型\
\
有了IComparable&lt;T&gt;就解决掉这个问题了\

<div>

    int CompareTo(T other);

</div>

**七、泛型委托**\
委托描述方法，\
\
泛型委托的由来和泛型接口类似\
定义一个泛型委托也比较简单：\

<div>

    public delegate void MyAction<T>(T obj);

</div>

这个委托描述一类方法\
\
这类方法接收T类型的参数，没有返回值\
\
来看看使用这个委托的方法\

<div>

    public delegate void MyAction<T>(T obj);
    static void Main(string[] args)
    {
        var method = new MyAction<int>(printInt);
        method(3);
        Console.ReadKey();
    }
    static void printInt(int i)
    {
        Console.WriteLine(i);
    }

</div>

由于定义委托比较繁琐\
\
.NET类库在System名称空间，下定义了三种比较常用的泛型委托\
Predicate&lt;T&gt;委托：\

<div>

    public delegate bool Predicate<T>(T obj);

</div>

这个委托描述的方法为接收一个T类型的参数，返回一个BOOL类型的值，一般用于比较方法\
Action&lt;T&gt;委托\

<div>

    public delegate void Action<T>(T obj);

</div>

<div>

    public delegate void Action<T1, T2>(T1 arg1, T2 arg2);

</div>

这个委托描述的方法，接收一个或多个T类型的参数（最多16个，我这里只写了两种类型的定义方式），没有返回值\
Func&lt;T&gt;委托\

<div>

    public delegate TResult Func<TResult>();

</div>

<div>

    public delegate TResult Func<T, TResult>(T arg);

</div>

这个委托描述的方法，接收零个或多个T类型的参数（最多16个，我这里只写了两种类型的定义方式），\
\
与Action委托不同的是，它有一个返回值，返回值的类型为TResult类型的\
关于委托的描述，您还可以看我这篇文章\
\
[30分钟LINQ教程](http://www.cnblogs.com/liulun/archive/2013/02/26/2909985.html)\
**八、泛型方法**\
泛型类型中的T可以用在这个类型的任何地方\
\
然而有些时候，我们不希望在使用类型的时候就指定T的类型\
\
我们希望在使用这个类型的方法时，再指定T的类型\
\
来看看如下代码：\

<div>

    public class MyClass
        {
            public TParam CompareTo<TParam>(TParam other)
            {
                Console.WriteLine(other.ToString());
                return other;
            }
        }

</div>

上面的代码中MyClass并不是一个泛型类型\
\
但这个类型中的CompareTo&lt;TParam&gt;()却是一个泛型方法\
\
TParam可以用在这个方法中的任何地方。\
使用泛型方法一般用如下代码就可以了：\

<div>

    obj.CompareTo<int>(4);
    obj.CompareTo<string>("ddd");

</div>

然而，你可以写的更简单一些，写成如下的方式\

<div>

    obj.CompareTo(2);
    obj.CompareTo("123");

</div>

有人会问：“这不可能，没有指定CompareTo方法的TParam类型，肯定会编译出错的”\
\
我告诉你：不会的，编译器可以帮你完成**类型推断**的工作。\
**注意：**\
\
如果你为一个方法指定了两个泛型参数，而且这两个参数的类型都是T，\
\
那么如果你想使用类型推断，你必须传递两个相同类型的参数给这个方法\
\
不能一个参数用string类型，另一个用object类型，这会导致编译错误。\
**九、泛型约束**\
我们设计了一个泛型类型\
\
很多时候，我们不希望使用者传入任意类型的参数\
\
也就是说，我们希望“约束”一下T的类型\
\
来看看如下代码：\

<div>

    public class MyClass<T> where T : IComparable<T>
        {
            public int CompareTo(T other)
            {
                return 0;
            }
        }

</div>

上面的代码要求T类型必须实现了IComparable&lt;T&gt;接口\
\
如你所见：泛型的约束通过关键字where来实现。\
泛型方法当然也可以通过类似的方式对泛型参数进行约束\
\
请看如下代码\

<div>

    public class MyClass
    {
        public TParam CompareTo<TParam>(TParam other) where TParam:class
        {
            Console.WriteLine(other.ToString());
            return other;
        }
    }

</div>

上面代码中用了class关键字约束泛型参数TParam；具体稍后解释。\
**注意1：**\
\
如果我有一个类型也定义为MyClass&lt;T&gt;但没有做约束，\
\
那么这个时候，做过约束的MyClass&lt;T&gt;将与没做约束的MyClass&lt;T&gt;冲突，编译无法通过****\
注意2：\
\
当你重写一个泛型方法时，如果这个方法指定了约束\
\
在重写这个方法时，不能再指定约束了****\
注意3：\
\
虽然我上面的例子写的是接口约束，但你完全可以写一个类型，比如说BaseClass\
\
而且，只要是继承自BaseClass的类型都可以当作T类型使用，你不要试图约束T为Object类型，编译不会通过的。（傻子才这么干）****\
注意4：\
\
有两个特殊的约束：class和struct。\
\
where T : class   约束T类型必须为引用类型\
\
where T : struct  约束T类型必须为值类型****\
注意5：\
\
如果你没有对T进行class约束，\
\
那么你不能写这样的代码：T obj = null;
 这无法通过编译，因为T有可能是值类型的。\
\
如果你没有对T进行struct约束，也没有对T进行new约束\
\
那么你不能写这样的代码：T obj = new T();
 这无法通过编译，因为值类型肯定有无参数构造器，而引用类型就不一定了。\
\
如果你对T进行了new约束：where T : new();  那么new
T()就是正确的，因为new约束要求T类型有一个公共无参构造器。\
**注意6：\
\
**就算没有对T进行任何约束，也有一个办法来处理值类型和引用类型的问题\
\
T temp = default(T);\
\
如果T为引用类型，那么temp就是null；如果T为值类型，那么temp就是0；\
**注意7：\
\
**试图对T类型的变量进行强制转化，一般情况下会报编译期错误。\
\
但你可以先把T转化成object再把object转化成你要的类型（一般不推荐这么做，你应该考虑把T转化成一个约束兼容的类型）\
\
你也可以考虑用as操作符进行类型转化，这一般不会报错，但只能转化成引用类型。\
关于泛型约束的内容，我在这篇文章里也有提到\
\
[30分钟linq教程](http://www.cnblogs.com/liulun/archive/2013/02/26/2909985.html)\
**十、逆变和协变**\
一般情况下，我们使用泛型时，由T标记的泛型类型是不能更改的\
\
也就是说,如下两种写法都是错误的\

<div>

    var a = new List<object>();
    List<string> b = a;
    var c = new List<string>();
    List<object> d = c;

</div>

注意：这里没有写强制转换，即使写了强制转换也是错误的，编译就无法通过\
然而泛型提供了逆变和协变的特性，\
\
有了这两种特性，这种转换就成为了可能。\
**逆变：**\
\
泛型类型T可以从基类型更改为该类的派生类型，\
\
用in关键字标记逆变形式的类型参数，\
\
而且这个参数一般作输入参数。\
**协变：**\
\
泛型类型T可以从派生类型更改为它的基类型，\
\
用out关键字来标记协变形式的类型参数，\
\
而且这个参数一般作为返回值\
如果我们定义了一个这样的委托：\

<div>

    public delegate TResult MyAction<in T,out TResult>(T obj);

</div>

那么，就可以让如下代码通过编译（不用强制转换）\

<div>

    var a = new MyAction<object, ArgumentException>(o => new ArgumentException(o.ToString()));
    MyAction<string, Exception> b = a;

</div>

这就是逆变和协变的威力。\
**参考资料**\
[Mgen的博客](http://www.cnblogs.com/mgen/archive/2012/03/15/2397191.html)\
\
CLR VIA C\#(第三版)\
**修改记录：**\
2013.4.21完成了一半的内容\
2013.4.28完成了全部内容，修改了一些错别字\
2013.4.29增加了一大部分内容，修改了排版样式\
\

#### 相关文章

-   [![Java对象初始化详解](http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg)](http://blog.jobbole.com/23939/)[Java对象初始化详解](http://blog.jobbole.com/23939/)
-   [![Java多线程发展简史](http://blog.jobbole.com/wp-content/uploads/2012/09/image_thumb10-150x150.png){width="150"
    height="150"}](http://blog.jobbole.com/28297/)[Java多线程发展简史](http://blog.jobbole.com/28297/)
-   [![你可能不知道的陷阱：C\#委托和事件的困惑](http://blog.jobbole.com/wp-content/uploads/2013/03/96-150x150.jpg){width="150"
    height="150"}](http://blog.jobbole.com/36088/)[你可能不知道的陷阱：C\#委托和事件的困惑](http://blog.jobbole.com/36088/)
-   [![对几个软件开发传统观点的质疑和反驳](http://blog.jobbole.com/wp-content/uploads/2012/11/traditional-software-development-150x150.jpg){width="150"
    height="150"}](http://blog.jobbole.com/30596/)[对几个软件开发传统观点的质疑和反驳](http://blog.jobbole.com/30596/)
-   [![Java 8
    的新特性和改进总览](http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg)](http://blog.jobbole.com/39006/)[Java
    8 的新特性和改进总览](http://blog.jobbole.com/39006/)
-   [![github 404
    page](http://blog.jobbole.com/wp-content/uploads/2012/09/github-404-page-150x150.jpg){width="150"
    height="150"}](http://blog.jobbole.com/22288/)[从测试300万个超链接接学到的](http://blog.jobbole.com/22288/)
-   [![理解ThreadLocal](http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg)](http://blog.jobbole.com/20400/)[理解ThreadLocal](http://blog.jobbole.com/20400/)
-   [![Java程序员面试中的多线程问题](http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg)](http://blog.jobbole.com/18571/)[Java程序员面试中的多线程问题](http://blog.jobbole.com/18571/)
-   [![异常的代价](http://blog.jobbole.com/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/14.jpg)](http://blog.jobbole.com/844/)[异常的代价](http://blog.jobbole.com/844/)
-   [![如何编码实现内存泄露](http://blog.jobbole.com/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/6.jpg)](http://blog.jobbole.com/38718/)[如何编码实现内存泄露](http://blog.jobbole.com/38718/)

[30分钟泛型教程](http://blog.jobbole.com/39125/)，首发于[博客 -
伯乐在线](http://blog.jobbole.com/)。
