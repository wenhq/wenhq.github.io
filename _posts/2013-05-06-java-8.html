---
layout: post
title: Java 8 的新特性和改进总览
date: '2013-05-06T18:32:00.001+08:00'
author: Wenh Q
tags: 
modified_time: '2013-05-06T18:32:09.489+08:00'
blogger_id: tag:blogger.com,1999:blog-4961947611491238191.post-623687384811102418
blogger_orig_url: http://binaryware.blogspot.com/2013/05/java-8.html
---

<a href="http://blog.jobbole.com/39006/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=java-8-%25e7%259a%2584%25e6%2596%25b0%25e7%2589%25b9%25e6%2580%25a7%25e5%2592%258c%25e6%2594%25b9%25e8%25bf%259b%25e6%2580%25bb%25e8%25a7%2588">Java 8 的新特性和改进总览</a>: <br />英文原文：<a href="http://www.techempower.com/blog/2013/03/26/everything-about-java-8/">Everything about Java 8</a> 编译：<a href="http://www.oschina.net/translate/everything-about-java-8?p=2#comments">oschina</a><br />这篇文章是对Java 8中即将到来的改进做一个面向开发者的综合性的总结，JDK的这一特性将会在<a href="http://openjdk.java.net/projects/jdk8/" rel="nofollow">2013年9月</a>份发布。<br />在写这篇文章的时候，Java 8的开发工作仍然在紧张有序的进行中，语言特新和API仍然有可能改变，我会尽我最大的努力保持这份文档跟得到Java 8的改动。<br />Java 8的预览版，也就是 “Project Lambda”，现在可以从<a href="http://jdk8.java.net/lambda/" rel="nofollow">java.net</a>下载到。<br />我使用了IntelliJ的预览版做我的IDE，在我看来他是目前支持java 8特性最好的一个IDE，你可以从<a href="http://confluence.jetbrains.com/display/IDEADEV/EAP" rel="nofollow">这里</a>下载到.<br />由于我没有找到Oracle发布的Java 8的官方文档，所以目前Java 8的文档还只有本地版本，等Oracle公开文档的时候，我将会重新链接到官方文档。<br /><b>接口改善</b><br />现在接口里已经完全可以定义静态方法了. 举一个比较普遍的例子就是在java类库中, 对于一些接口如Foo, 都会有一个有静态方法的工具类Foos&nbsp;来生成或者配合Foo对象实例来使用. 既然静态方法可以存在于接口当中, 那么大多数情况下 Foos工具类完全可以使用接口中的公共方法来代理 (或者将Foos置成package-private).<br />除此之外更重要的就是, Java 8中接口可以定义默认的方法了.举个例子,一个for-each循环的方法就可以加入到java.lang.Iterable中:<br /><pre>public default void forEach(Consumer&lt;? super T&gt; action) {<br />    Objects.requireNonNull(action); for (T t : this) {<br />        action.accept(t);<br />    }<br />}</pre>在过去,java类库的接口中添加方法基本上是不可能的. 在接口中添加方法意味着破坏了实现了这个接口的代码. 但是现在, 只要能够提供一个正确明智的默认的方法的实现, java类库的维护者就可以在接口中添加方法.<br />Java 8中, 大量的默认方法已经被添加到核心的JDK接口中了. 稍候我会详细介绍它们.<br /><b>为什么不能用默认方法来重载equals，hashCode和toString？</b><br />接口不能提供对Object类的任何方法的默认实现。特别是，这意味着从接口里不能提供对equals，hashCode或toString的默认实现。<br />这刚看起来挺奇怪的，但考虑到一些接口实际上是在文档里定义他们的equals行为的。List接口就是一个例子了。因此，为什么不允许这样呢？<br />Brian Goetz在这个问题上的冗长的回复里给出了4个原因。我这里只说其中一个，因为那个已经足够说服我了：<br />它会变得更困难来推导什么时候该调用默认的方法。现在它变得很简单了：如果一个类实现了一个方法，那总是优先于默认的实现的。一旦所有接口的实例都是Object的子类，所有接口实例都已经有对equals/hashCode/toString的非默认实现。因此，一个在接口上这些的默认版本都是没用的，它也不会被编译。<br />要看更多的话，看下由Brian Goetz写的解释:&nbsp;<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008435.html" rel="nofollow">对“允许默认方法来重载Object的方法”的回复</a><br /><b>函数式接口</b><br />Java 8 引入的一个核心概念是函数式接口。如果一个接口定义个唯一一个抽象方法，那么这个接口就成为函数式接口。比如，java.lang.Runnable就是一个函数式接口，因为它只顶一个一个抽象方法:<br /><pre>public abstract void run();</pre>留意到“abstract”修饰词在这里是隐含的，因为这个方法缺少方法体。为了表示一个函数式接口，并非想这段代码一样一定需要“abstract”关键字。<br />默认方法不是abstract的，所以一个函数式接口里可以定义任意多的默认方法，这取决于你。<br />同时，引入了一个新的Annotation：<a href="http://javadocs.techempower.com/jdk18/api/java/lang/FunctionalInterface.html" rel="nofollow">@FunctionalInterface</a>。可以把他它放在一个接口前，表示这个接口是一个函数式接口。加上它的接口不会被编译，除非你设法把它变成一个函数式接口。它有点像<a href="http://javadocs.techempower.com/jdk18/api/java/lang/Override.html" rel="nofollow">@Override</a>，都是声明了一种使用意图，避免你把它用错。<br /><b>Lambdas</b><br />一个函数式接口非常有价值的属性就是他们能够用lambdas来实例化。这里有一些lambdas的例子：<br />左边是指定类型的逗号分割的输入列表，右边是带有return的代码块：<br /><pre>(int x, int y) -&gt; { return x + y; }</pre>左边是推导类型的逗号分割的输入列表，右边是返回值：<br /><pre>(x, y) -&gt; x + y</pre>左边是推导类型的单一参数，右边是一个返回值：<br /><pre>x -&gt; x * x</pre>左边没有输入 (官方名称:&nbsp;<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2012-September/005767.html" rel="nofollow">“burger arrow”</a>)，在右边返回一个值：<br /><pre>() -&gt; x</pre>左边是推导类型的单一参数，右边是没返回值的代码块（返回void）：<br /><pre>x -&gt; { System.out.println(x); }</pre>静态方法引用：<br /><pre>String::valueOf</pre>非静态方法引用：<br /><pre>Object::toString</pre>继承的函数引用：<br /><pre>x::toString</pre>构造函数引用：<br /><pre>ArrayList::new</pre>你可以想出一些函数引用格式作为其他lambda格式的简写。<br /><table border="1"><tbody><tr> <th>方法引用</th> <th>&nbsp;等价的lambda表达式</th> <th></th> </tr></tbody> <tbody><tr> <td>String::valueOf</td> <td></td> <td>x -&gt; String.valueOf(x)</td> </tr><tr> <td>Object::toString</td> <td></td> <td>x -&gt; x.toString()</td> </tr><tr> <td>x::toString</td> <td></td> <td>() -&gt; x.toString()</td> </tr><tr> <td>ArrayList::new</td> <td></td> <td>() -&gt;&nbsp;new&nbsp;ArrayList&lt;&gt;()</td> </tr></tbody> </table>当然，在Java里方法能被重载。类可以有多个同名但不同参数的方法。这同样对构造方法有效。ArrayList::new能够指向它的3个构造方法中任何一个。决定使用哪个方法是根据在使用的函数式接口。<br />一个lambda和给定的函数式接口在“外型”匹配的时候兼容。通过“外型”，我指向输入、输出的类型和声明检查异常。<br />给出两个具体有效的例子：<br /><pre>Comparator&lt;String&gt; c = (a, b) -&gt; Integer.compare(a.length(),<br />                                                 b.length());</pre>一个Comparator&lt;String&gt;的compare方法需要输入两个阐述，然后返回一个int。这和lambda右侧的一致，因此这个任务是有效的。<br /><pre>Runnable r = () -&gt; { System.out.println("Running!"); }</pre>一个Runnable的run方法不需要参数也不会返回值。这和lambda右侧一致，所以任务有效。<br />在抽象方法的签名里的受检查异常（如果存在）也很重要。如果函数式接口在它的签名里声明了异常，lambda只能抛出受检查异常。<br /><b>捕获和非捕获的Lambda表达式</b><br />当Lambda表达式访问一个定义在Lambda表达式体外的非静态变量或者对象时，这个Lambda表达式称为“捕获的”。比如，下面这个lambda表达式捕捉了变量x：<br /><pre>int x = 5; return y -&gt; x + y;</pre>为了保证这个lambda表达式声明是正确的，被它捕获的变量必须是“有效final”的。所以要么它们需要用final修饰符号标记，要么保证它们在赋值后不能被改变。<br />Lambda表达式是否是捕获的和性能悄然相关。一个非不捕获的lambda通常比捕获的更高效，虽然这一点没有书面的规范说明（据我所知），而且也不能为了程序的正确性指望它做什么，<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2012-November/006867.html" rel="nofollow">非捕获的lambda只需要计算一次</a>. 然后每次使用到它都会返回一个唯一的实例。而捕获的lambda表达式每次使用时都需要重新计算一次，而且从目前实现来看，它很像实例化一个匿名内部类的实例。<br /><b>lambdas不做的事</b><br />你应该记住，有一些lambdas不提供的特性。为了Java 8它们被考虑到了，但是没有被包括进去，由于简化以及时间限制的原因。<br /><b>Non-final<sup><b>*</b></sup>&nbsp;变量捕获</b>&nbsp;- 如果一个变量被赋予新的数值，它将不能被用于lambda之中。”final”关键字不是必需的，但变量必须是“有效final”的（前面讨论过）。这个代码不会被编译：<br /><pre>int count = 0;<br />List&lt;String&gt; strings = Arrays.asList("a", "b", "c");<br />strings.forEach(s -&gt; {<br />    count++; // error: can't modify the value of count });</pre><b>例外的透明度</b>&nbsp;- 如果一个已检测的例外可能从lambda内部抛出，功能性的接口也必须声明已检测例外可以被抛出。这种例外不会散布到其包含的方法。这个代码不会被编译：<br /><pre>void appendAll(Iterable&lt;String&gt; values, Appendable out) throws IOException { // doesn't help with the error values.forEach(s -&gt; {<br />        out.append(s); // error: can't throw IOException here // Consumer.accept(T) doesn't allow it });<br />}</pre>有绕过这个的办法，你能定义自己的功能性接口，扩展Consumer的同时通过像RuntimeException之类抛出&nbsp;IOException。我试图用代码写出来，但发现它令人困惑是否值得。<br /><b>控制流程 (break, early return)</b>&nbsp;-在上面的 forEach例子中，传统的继续方式有可能通过在lambda之内放置&nbsp;”return;”来实现。但是，没有办法中断循环或者从lambda中通过包含方法的结果返回一个数值。例如：<br /><pre>final String secret = "foo"; boolean containsSecret(Iterable&lt;String&gt; values) {<br />    values.forEach(s -&gt; { if (secret.equals(s)) {<br />            ??? // want to end the loop and return true, but can't }<br />    });<br />}</pre>进一步阅读关于这些问题的资料，看看这篇Brian Goetz写的说明：<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2013-January/007662.html" rel="nofollow">在&nbsp;Block&lt;T&gt;中响应“已验证例外”</a><br /><b>为什么抽象类不能通过利用lambda实例化</b><br />抽象类，哪怕只声明了一个抽象方法，也不能使用lambda来实例化。<br />下面有两个类&nbsp;<a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/collect/Ordering.html" rel="nofollow">Ordering</a>&nbsp;和&nbsp;<a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/cache/CacheLoader.html" rel="nofollow">CacheLoader</a>的例子，都带有一个抽象方法，摘自于Guava 库。那岂不是很高兴能够声明它们的实例，像这样使用lambda表达式？<br /><pre>Ordering&lt;String&gt; order = (a, b) -&gt; ...;<br /><br />CacheLoader&lt;String, String&gt; loader = (key) -&gt; ...;</pre>这样做引发的最常见的争论就是会增加阅读lambda的难度。以这种方式实例化一段抽象类将导致隐藏代码的执行：抽象类的构造方法。<br />另一个原因是，它抛出了lambda表达式可能的优化。在未来，它可能是这种情况，lambda表达式<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2012-November/006875.html" rel="nofollow">都不会计算到对象实例</a>。放任用户用lambda来声明抽象类将妨碍像这样的优化。<br />此外，有一个简单地解决方法。事实上，上述两个摘自Guava 库的实例类已经证明了这种方法。增加工厂方法将lambda转换成实例。<br /><pre>Ordering&lt;String&gt; order = Ordering.from((a, b) -&gt; ...);<br />CacheLoader&lt;String, String&gt; loader = CacheLoader.from((key) -&gt; ...);</pre>要深入阅读，请参看由&nbsp;Brian Goetz所做的说明：&nbsp;<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2013-March/008441.html" rel="nofollow">response to “Allow lambdas to implement abstract classes”</a>。<br /><b>java.util.function</b><br />包概要：<a href="http://javadocs.techempower.com/jdk18/api/java/util/function/package-summary.html" rel="nofollow">java.util.function</a><br />作为Comparator 和Runnable早期的证明，在JDK中已经定义的接口恰巧作为函数接口而与lambdas表达式兼容。同样方式可以在你自己的代码中定义任何函数接口或第三方库。<br />但有特定形式的函数接口，且广泛的，通用的，在之前的JD卡中并不存在。大量的接口被添加到新的java.util.function 包中。下面是其中的一些：<br /><ul><li>Function&lt;T, R&gt;&nbsp;-T作为输入，返回的R作为输出</li><li>Predicate&lt;T&gt;&nbsp;-T作为输入，返回的boolean值作为输出</li><li>Consumer&lt;T&gt;&nbsp;- T作为输入，执行某种动作但没有返回值</li><li>Supplier&lt;T&gt;&nbsp;- 没有任何输入，返回T</li><li>BinaryOperator&lt;T&gt;&nbsp;-两个T作为输入，返回一个T作为输出，对于“reduce”操作很有用</li></ul>这些最原始的特征同样存在。他们以int，long和double的方式提供。例如：<br /><ul><li>IntConsumer&nbsp;-以int作为输入，执行某种动作，没有返回值</li></ul>这里存在性能上的一些原因，主要释在输入或输出的时候避免装箱和拆箱操作。<br /><b>java.util.stream</b><br />包汇总:&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/package-summary.html" rel="nofollow">java.util.stream</a><br />新的java.util.stream包提供了“支持在流上的函数式风格的值操作”（引用javadoc）的工具。可能活动一个流的最常见方法是从一个collection获取：<br /><pre>Stream&lt;T&gt; stream = collection.stream();</pre>一个流就像一个地带器。这些值“流过”（模拟水流）然后他们离开。一个流可以只被遍历一次，然后被丢弃。流也可以无限使用。<br />流能够是&nbsp;<b>串行的</b>&nbsp;或者&nbsp;<b>并行的</b>。 它们可以使用其中一种方式开始，然后切换到另外的一种方式，使用stream.<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#sequential%28%29" rel="nofollow">sequential()</a>或stream.<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#parallel%28%29" rel="nofollow">parallel()</a>来达到这种切换。串行流在一个线程上连续操作。而并行流就可能一次出现在多个线程上。<br />所以，你想用一个流来干什么？这里是在javadoc包里给出的例子：<br /><pre>int sumOfWeights = blocks.stream().filter(b -&gt; b.getColor() == RED)<br />                                  .mapToInt(b -&gt; b.getWeight())<br />                                  .sum();</pre>注意：上面的代码使用了一个原始的流，以及一个只能用在原始流上的sum()方法。下面马上就会有更多关于原始流的细节。<br />流提供了流畅的API，可以进行数据转换和对结果执行某些操作。流操作既可以是“中间的”也可以是“末端的”。<br /><ul><li><b>中</b><b>间</b><b>的</b>&nbsp;-中间的操作保持流打开状态，并允许后续的操作。上面例子中的filter和map方法就是中间的操作。这些操作的返回数据类型是流；它们返回当前的流以便串联更多的操作。</li><li><b>末端的</b>&nbsp;- 末端的操作必须是对流的最终操作。当一个末端操作被调用，流被“消耗”并且不再可用。上面例子中的sum方法就是一个末端的操作。</li></ul>通常，处理一个流涉及了这些步骤：<br /><ol><li>从某个源头获得一个流。</li><li>执行一个或更多的中间的操作。</li><li>执行一个末端的操作。</li></ol>可能你想在一个方法中执行所有那些步骤。那样的话，你就要知道源头和流的属性，而且要可以保证它被正确的使用。你可能不想接受任意的Stream&lt;T&gt;实例作为你的方法的输入，因为它们可能具有你难以处理的特性，比如并行的或无限的。<br />有几个更普通的关于流操作的特性需要考虑：<br /><ul><li><b>有状态的</b>&nbsp;- 有状态的操作给流增加了一些新的属性，比如元素的唯一性，或者元素的最大数量，或者保证元素以排序的方式被处理。这些典型的要比无状态的中间操作代价大。</li><li><b>短路</b>&nbsp;- 短路操作潜在的允许对流的操作尽早停止，而不去检查所有的元素。这是对无限流的一个特殊设计的属性；如果对流的操作没有短路，那么代码可能永远也不会终止。</li></ul>对每个Sttream方法这里有一些简短的，一般的描述。查阅javadoc获取更详尽的解释。下面给出了每个操作的重载形式的链接。<br />中间的操作：<br /><ul><li><b>filter</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#filter%28java.util.function.Predicate%29" rel="nofollow">1</a>&nbsp;- 排除所有与断言不匹配的元素。</li><li><b>map</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#map%28java.util.function.Function%29" rel="nofollow">1</a>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#mapToInt%28java.util.function.ToIntFunction%29" rel="nofollow">2</a>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#mapToLong%28java.util.function.ToLongFunction%29" rel="nofollow">3</a>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#mapToDouble%28java.util.function.ToDoubleFunction%29" rel="nofollow">4</a>&nbsp;- 通过Function对元素执行一对一的转换。</li><li><b>flatMap</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#flatMap%28java.util.stream.FlatMapper%29" rel="nofollow">1</a>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#flatMapToInt%28java.util.stream.FlatMapper.ToInt%29" rel="nofollow">2</a>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#flatMapToLong%28java.util.stream.FlatMapper.ToLong%29" rel="nofollow">3</a>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#flatMapToDouble%28java.util.stream.FlatMapper.ToDouble%29" rel="nofollow">4</a>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#flatMap%28java.util.function.Function%29" rel="nofollow">5</a>&nbsp;- 通过FlatMapper将每个元素转变为无或更多的元素。</li><li><b>peek</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#peek%28java.util.function.Consumer%29" rel="nofollow">1</a>&nbsp;- 对每个遇到的元素执行一些操作。主要对调试很有用。</li><li><b>distinct</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#distinct%28%29" rel="nofollow">1</a>&nbsp;- 根据.equals行为排除所有重复的元素。这是一个有状态的操作。</li><li><b>sorted</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#sorted%28%29" rel="nofollow">1</a>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#sorted%28java.util.Comparator%29" rel="nofollow">2</a>&nbsp;- 确保流中的元素在后续的操作中，按照比较器（Comparator）决定的顺序访问。这是一个有状态的操作。</li><li><b>limit</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#limit%28long%29" rel="nofollow">1</a>&nbsp;- 保证后续的操作所能看到的最大数量的元素。这是一个有状态的短路的操作。</li><li><b>substream</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#substream%28long%29" rel="nofollow">1</a>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#substream%28long,%20long%29" rel="nofollow">2</a>&nbsp;- 确保后续的操作只能看到一个范围的（根据index）元素。像不能用于流的String.substring一样。也有两种形式，一种有一个开始索引，一种有一个结束索引。二者都是有状态的操作，有一个结束索引的形式也是一个短路的操作。</li></ul>末端的操作：<br /><ul><li><b>forEach</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#forEach%28java.util.function.Consumer%29" rel="nofollow">1</a>&nbsp;- 对流中的每个元素执行一些操作。</li><li><b>toArray</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#toArray%28%29" rel="nofollow">1</a>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#toArray%28java.util.function.IntFunction%29" rel="nofollow">2</a>&nbsp;- 将流中的元素倾倒入一个数组。</li><li><b>reduce</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#reduce%28java.util.function.BinaryOperator%29" rel="nofollow">1</a>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#reduce%28T,%20java.util.function.BinaryOperator%29" rel="nofollow">2</a>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#reduce%28U,%20java.util.function.BiFunction,%20java.util.function.BinaryOperator%29" rel="nofollow">3</a>&nbsp;- 通过一个二进制操作将流中的元素合并到一起。</li><li><b>collect</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#collect%28java.util.stream.Collector%29" rel="nofollow">1</a>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#collect%28java.util.function.Supplier,%20java.util.function.BiConsumer,%20java.util.function.BiConsumer%29" rel="nofollow">2</a>&nbsp;- 将流中的元素倾倒入某些容器，例如一个Collection或Map.</li><li><b>min</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#min%28java.util.Comparator%29" rel="nofollow">1</a>&nbsp;- 根据一个比较器找到流中元素的最小值。</li><li><b>max</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#max%28java.util.Comparator%29" rel="nofollow">1</a>&nbsp;-根据一个比较器找到流中元素的最大值。</li><li><b>count</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#count%28%29" rel="nofollow">1</a>&nbsp;- 计算流中元素的数量。</li><li><b>anyMatch</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#anyMatch%28java.util.function.Predicate%29" rel="nofollow">1</a>&nbsp;- 判断流中是否至少有一个元素匹配断言。这是一个短路的操作。</li><li><b>allMatch</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#allMatch%28java.util.function.Predicate%29" rel="nofollow">1</a>&nbsp;- 判断流中是否每一个元素都匹配断言。这是一个短路的操作。</li><li><b>noneMatch</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#noneMatch%28java.util.function.Predicate%29" rel="nofollow">1</a>&nbsp;- 判断流中是否没有一个元素匹配断言。这是一个短路的操作。</li><li><b>findFirst</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#findFirst%28%29" rel="nofollow">1</a>&nbsp;- 查找流中的第一个元素。这是一个短路的操作。</li><li><b>findAny</b>&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Stream.html#findAny%28%29" rel="nofollow">1</a>&nbsp;- 查找流中的任意元素，可能对某些流要比findFirst代价低。这是一个短路的操作。</li></ul>如&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/package-summary.html" rel="nofollow">javadocs中提到的</a>&nbsp;, 中间的操作是延迟的（lazy）。只有末端的操作会立即开始流中元素的处理。在那个时刻，不管包含了多少中间的操作，元素会在一个传递中处理（通常，但并不总是）。（有状态的操作如sorted() 和distinct()可能需要对元素的二次传送。）<br />流试图尽可能做很少的工作。有一些细微优化，如当可以判定元素已经有序的时候，省略一个sorted()操作。在包含limit(x) 或 substream(x,y)的操作中，有些时候对一些不会决定结果的元素，流可以避免执行中间的map操作。在这里我不准备实现公平判断；它通过许多细微的但却很重要的方法表现得很聪明，而且它仍在进步。<br />回到并行流的概念，重要的是要意识到并行不是毫无代价的。从性能的立场它不是无代价的，你不能简单的将顺序流替换为并行流，且不做进一步思考就期望得到相同的结果。在你能（或者应该）并行化一个流以前，需要考虑很多特性，关于流、它的操作以及数据的目标方面。例如：访问顺序确实对我有影响吗？我的函数是无状态的吗？我的流有足够大，并且我的操作有足够复杂，这些能使得并行化是值得的吗？<br />有针对int,long和double的专业原始的Stream版本：<br /><ul><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/IntStream.html" rel="nofollow">IntStream</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/LongStream.html" rel="nofollow">LongStream</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/DoubleStream.html" rel="nofollow">DoubleStream</a></li></ul>可以在众多函数中，通过专业原始的map和flatMap函数，在一个stream对象与一个原始stream对象之间来回转换。给几个虚设例子：<br /><pre>List&lt;String&gt; strings = Arrays.asList("a", "b", "c");<br />strings.stream() // <br />Stream&lt;String&gt; .mapToInt(String::length) // IntStream .longs() // <br />LongStream .mapToDouble(x -&gt; x / 10.0) // DoubleStream .boxed() // <br />Stream&lt;Double&gt; .mapToLong(x -&gt; 1L) // LongStream .mapToObj(x -&gt; "") // <br />Stream&lt;String&gt; ...</pre>原始的stream也为获得关于stream的基础数据统计提供方法，那些stream是指作为数据结构的。你可以发现count, sum, min, max, 以及元素平均值全部是来自于一个终端的操作。<br />原始类型的剩余部分没有原始版本，因为这需要一个不可接受的JDK数量的膨胀。IntStream, LongStream, 和 DoubleStream被认为非常有用应当被包含进去，其他的数字型原始stream可以由这三个通过扩展的原始转换来表示。<br />在flatMap操作中使用的&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/FlatMapper.html" rel="nofollow">FlatMapper</a>&nbsp;接口是具有一个抽象方法的功能性接口：<br /><pre>void flattenInto(T element, Consumer&lt;U&gt; sink);</pre>在一个flatMap操作的上下文中，stream为你提供element和 sink，然后你定义该用element 和 sink做什么。element是指在stream中的当前元素，而sink代表当flatMap操作结束之后在stream中应该显示些什么。例如：<br /><pre>Set&lt;Color&gt; colors = ...;<br />List&lt;Person&gt; people = ...;<br />Stream&lt;Color&gt; stream = people.stream().flatMap(<br />    (Person person, Consumer&lt;Color&gt; sink) -&gt; { // Map each person to the colors they like. for (Color color : colors) { if (person.likesColor(color)) {<br />                sink.accept(color);<br />            }<br />        }<br />    });</pre>注意上面lambda中的参数类型是指定的。在大多数其它上下文中，你可以不需要指定类型，但这里由于FlatMapper的自然特性，编译器需要你帮助判定类型。如果你在使用flatMap又迷惑于它为什么不编译，可能是因为你没有指定类型。<br />最令人感到困惑，复杂而且有用的终端stream操作之一是collect。它引入了一个称为<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Collector.html" rel="nofollow">Collector</a>的新的非功能性接口。这个接口有些难理解，但幸运的是有一个<a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/Collectors.html" rel="nofollow">Collectors</a>工具类可用来产生所有类型的有用的Collectors。例如：<br /><pre>List&lt;String&gt; strings = values.stream()<br />                             .filter(...)<br />                             .map(...)<br />                             .collect(Collectors.toList());</pre>如果你想将你的stream元素放进一个Collection,Map或String，那么Collectors可能具有你需要的。在javadoc中浏览那个类绝对是值得的。<br /><b>泛型接口改进</b><br />建议摘要：<a href="http://openjdk.java.net/jeps/101" rel="nofollow">JEP 101: 通用化目标-Type 接口</a><br />这是一个以前不能做到的，对编译器判定泛型能力的努力改进。在以前版本的Java中有许多情形编译器不能给某个方法计算出泛型，当方法处于嵌套的或串联方法调用这样的上下文的时候，即使有时候对<a href="http://blog.jobbole.com/821/" title="程序员的本质">程序员</a>来说它看起来“很明显”。那些情况需要程序员明确的指定一个“类型见证”（type witness）。它是一种通用的特性，但吃惊的是很少有Java程序员知道（我这么说是基于私下的交流并且阅读了一些StackOverflow的问题）。它看起来像这样：<br /><pre>// In Java 7: foo(Utility.&lt;Type&gt;bar());<br />Utility.&lt;Type&gt;foo().bar();</pre>如果没有类型见证，编译器可能会将&lt;Object&gt;替代为泛型，而且如果需要的是一个更具体的类型，代码将编译失败。<br />Java 8 极大的改进了这个状况。在更多的案例中，它可以基于上下文计算出更多的特定的泛型类型。<br /><pre>// In Java 8: foo(Utility.bar());<br />Utility.foo().bar();</pre>这项工作仍在发展中，所以我不确定建议中列出的例子有多少能真正包含进Java 8。希望是它们全部。<br /><b>java.time</b><br />包概要：&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/time/package-summary.html" rel="nofollow">java.time</a><br />在Java8中新的&nbsp;date/timeAPI存在于&nbsp;java.time包中。如果你熟悉Joda Time，它将很容易掌握。事实上，我认为如此好的设计，以至于从未听说过&nbsp;Joda Time的人也能很容易的掌握。<br />几乎在API中的任何东西都是永恒的，包括值类型和格式化 。对于Date域或者处理或处理本地线程日期格式化不必太过担心。<br />与传统的date/timeAPI的交叉是最小的。有一个清晰的分段：<br /><ul><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Date.html#toInstant%28%29" rel="nofollow">Date.toInstant()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Date.html#from%28java.time.Instant%29" rel="nofollow">Date.from(Instant)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Calendar.html#toInstant%28%29" rel="nofollow">Calendar.toInstant()</a></li></ul>新API对于像月份和每周的天数，喜欢枚举类型更胜过整形常量。<br />那么，那是什么呢？包级别的javadocs 对额外类型的做出了非常好的阐述。我将对一些值得注意的部分做一些简短的纲要。<br />非常有用的值类型：<br /><ul><li><a href="http://javadocs.techempower.com/jdk18/api/java/time/Instant.html" rel="nofollow">Instant</a>&nbsp;- 与java.util.Date相似</li><li><a href="http://javadocs.techempower.com/jdk18/api/java/time/ZonedDateTime.html" rel="nofollow">ZonedDateTime</a>,&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/time/ZoneId.html" rel="nofollow">ZoneId</a>&nbsp;-时区很重要的时候使用</li><li><a href="http://javadocs.techempower.com/jdk18/api/java/time/OffsetDateTime.html" rel="nofollow">OffsetDateTime</a>,&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/time/OffsetTime.html" rel="nofollow">OffsetTime</a>,&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/time/ZoneOffset.html" rel="nofollow">ZoneOffset</a>&nbsp;-对UTC的偏移处理</li><li><a href="http://javadocs.techempower.com/jdk18/api/java/time/Duration.html" rel="nofollow">Duration</a>,&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/time/Period.html" rel="nofollow">Period</a>&nbsp;-&nbsp;但如果你想找到两个日期之间的时间量，你可能会寻找ChronoUnit代替（见下文）</li></ul>其他有用的类型：<br /><ul><li><a href="http://javadocs.techempower.com/jdk18/api/java/time/format/DateTimeFormatter.html" rel="nofollow">DateTimeFormatter</a>&nbsp;- 将日期类型转换成字符串类型</li><li><a href="http://javadocs.techempower.com/jdk18/api/java/time/temporal/ChronoUnit.html" rel="nofollow">ChronoUnit</a>&nbsp;- 计算出两点之间的时间量，例如ChronoUnit.DAYS.between(t1, t2)</li><li><a href="http://javadocs.techempower.com/jdk18/api/java/time/temporal/TemporalAdjuster.html" rel="nofollow">TemporalAdjuster</a>&nbsp;- 例如date.with(TemporalAdjuster.firstDayOfMonth())</li></ul>大多数情况下，新的值类型由JDBC提供支持。有一小部分异常，如ZonedDateTime在SQL中没有对应的（类型）。<br /><b>集合API附件</b><br />实际上接口能够定义默认方法允许了JDK作者加入大量的附件到集合API接口中。默认实现在核心接口里提供，而其他更有效或更好的重载实现被加入到可适用的具体类中。<br />这里是新方法的列表：<br /><ul><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Iterable.html#forEach%28java.util.function.Consumer%29" rel="nofollow">Iterable.forEach(Consumer)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Iterator.html#forEach%28java.util.function.Consumer%29" rel="nofollow">Iterator.forEach(Consumer)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Collection.html#removeAll%28java.util.function.Predicate%29" rel="nofollow">Collection.removeAll(Predicate)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Collection.html#spliterator%28%29" rel="nofollow">Collection.spliterator()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Collection.html#stream%28%29" rel="nofollow">Collection.stream()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Collection.html#parallelStream%28%29" rel="nofollow">Collection.parallelStream()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/List.html#sort%28java.util.Comparator%29" rel="nofollow">List.sort(Comparator)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Map.html#forEach%28java.util.function.BiConsumer%29" rel="nofollow">Map.forEach(BiConsumer)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Map.html#replaceAll%28java.util.function.BiFunction%29" rel="nofollow">Map.replaceAll(BiFunction)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Map.html#putIfAbsent%28K,%20V%29" rel="nofollow">Map.putIfAbsent(K, V)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Map.html#remove%28java.lang.Object,%20java.lang.Object%29" rel="nofollow">Map.remove(Object, Object)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Map.html#replace%28K,%20V,%20V%29" rel="nofollow">Map.replace(K, V, V)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Map.html#replace%28K,%20V%29" rel="nofollow">Map.replace(K, V)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Map.html#computeIfAbsent%28K,%20java.util.function.Function%29" rel="nofollow">Map.computeIfAbsent(K, Function)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Map.html#computeIfPresent%28K,%20java.util.function.BiFunction%29" rel="nofollow">Map.computeIfPresent(K, BiFunction)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Map.html#compute%28K,%20java.util.function.BiFunction%29" rel="nofollow">Map.compute(K, BiFunction)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Map.html#merge%28K,%20V,%20java.util.function.BiFunction%29" rel="nofollow">Map.merge(K, V, BiFunction)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Map.html#getOrDefault%28Object,%20V%29" rel="nofollow">Map.getOrDefault(Object, V)</a></li></ul>同样，&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/Iterator.html#remove%28%29" rel="nofollow">Iterator.remove()</a>&nbsp;现在有一个默认的, 会抛出异常的实现，使得它稍微容易地去定义不可修改的迭代器。<br />Collection.stream()和Collection.parallelStream()是流API的主要门户。有其他方法去生成流，但这些在以后会更为长用。<br />List.sort(Comparator)的附件有点怪异。以前排序一个ArrayList的方法是：<br /><pre>Collections.sort(list, comparator);</pre>这代码是你在Java7里唯一可选的，非常低效。它会复制list到一个数组里，排序这个数组，然后使用ListIterator来把数组插入到新list的新位置上。<br />List.sort(比较器)的默认实现仍然会做这个，但是具体的实现类可以自由的优化。例如，ArrayList.sort在ArrayList内部数组上调用了Arrays.sort。CopyOnWriteArrayList做了同样的事情。<br />从这些新方法中获得的不仅仅是性能。它们也具有更多的令人满意的语义。例如， 对Collections.synchronizedList()排序是一个使用了list.sort的原子操作。你可以使用list.forEach对它的所有元素进行迭代，使之成为原子操作。<br />Map.computeIfAbsent使得操作类似多重映射的结构变得容易了：<br /><pre>// Index strings by length: <br />Map&lt;Integer, List&lt;String&gt;&gt; map = new HashMap&lt;&gt;(); for (String s : strings) {<br />    map.computeIfAbsent(s.length(),<br />                        key -&gt; new ArrayList&lt;String&gt;())<br />       .add(s);<br />} // Although in this case the stream API may be a better choice:<br />&nbsp;Map&lt;Integer, List&lt;String&gt;&gt; map = strings.stream()<br />    .collect(Collectors.groupingBy(String::length));</pre><b>增加并发API</b><br /><ul><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/ForkJoinPool.html#commonPool%28%29" rel="nofollow">ForkJoinPool.commonPool()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/ConcurrentHashMap.html" rel="nofollow">ConcurrentHashMap(v8)</a></li><li>下面的形式有并行，顺序，对象，整型，长整型和double型。</li></ul>有太多的链接可以点击，因此参看<a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/ConcurrentHashMap.html" rel="nofollow">ConcurrentHashMap&nbsp;</a>javadocs文档以获得更多信息。<br /><ul><li>ConcurrentHashMap.reduce…</li><li>ConcurrentHashMap.search…</li><li>ConcurrentHashMap.forEach…</li></ul><ul><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/ConcurrentHashMap.html#newKeySet%28%29" rel="nofollow">ConcurrentHashMap.newKeySet()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/ConcurrentHashMap.html#newKeySet%28int%29" rel="nofollow">ConcurrentHashMap.newKeySet(int)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/CompletableFuture.html" rel="nofollow">CompletableFuture</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/locks/StampedLock.html" rel="nofollow">StampedLock</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/atomic/LongAdder.html" rel="nofollow">LongAdder</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/atomic/LongAccumulator.html" rel="nofollow">LongAccumulator</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/atomic/DoubleAdder.html" rel="nofollow">DoubleAdder</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/atomic/DoubleAccumulator.html" rel="nofollow">DoubleAccumulator</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/CountedCompleter.html" rel="nofollow">CountedCompleter</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/Executors.html#newWorkStealingPool%28%29" rel="nofollow">Executors.newWorkStealingPool()</a></li></ul><ul><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/Executors.html#newWorkStealingPool%28int%29" rel="nofollow">Executors.newWorkStealingPool(int)</a></li><li>下面的形式有AtomicReference, AtomicInteger, AtomicLong, 和每一个原子数组的版本。</li></ul><ul><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/atomic/AtomicReference.html#getAndUpdate%28java.util.function.UnaryOperator%29" rel="nofollow">AtomicReference.getAndUpdate(UnaryOperator)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/atomic/AtomicReference.html#updateAndGet%28java.util.function.UnaryOperator%29" rel="nofollow">AtomicReference.updateAndGet(UnaryOperator)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/atomic/AtomicReference.html#getAndAccumulate%28V,%20java.util.function.BinaryOperator%29" rel="nofollow">AtomicReference.getAndAccumulate(V, UnaryOperator)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/atomic/AtomicReference.html#accumulateAndGet%28V,%20java.util.function.BinaryOperator%29" rel="nofollow">AtomicReference.accumulateAndGet(V, UnaryOperator)</a></li></ul>ForkJoinPool.commonPool()是处理所有并行流操作的结构。当你&nbsp;需要的时候，它是一个好而简单的方式去获得一个ForkJoinPool/ExecutorService/Executor对象。ConcurrentHashMap&lt;K, V&gt;完全重写。内部看起来它一点不像是Java7版本。从外部来看几乎相同，除了它有大量批量操作方法：多种形式的减少搜索和forEach。<br /><br />ConcurrentHashMap.newKeySet()提供了一个并发的java.util.Set实现。它基本上是Collections.newSetFromMap(new ConcurrentHashMap&lt;T, Boolean&gt;())的另一种方式的重写。<br />StampedLock是一种新型锁的实现，很可能在大多数场景都可以替代<a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/locks/ReentrantReadWriteLock.html" rel="nofollow">ReentrantReadWriteLock</a>。当作为一个简单的读写锁的时候，它比RRWL的性能要好。它也为“读优化”提供了API，通过它你获得了一个功能有点弱，但代价很小的读操作锁的版本，执行读操作，然后检查锁是否被一个写操作设定为无效。在Heinz Kabutz汇总的一系列幻灯片中，有更多关于这个类及其性能的细节（在这个系列幻灯片大约一半的地方开始的）：<a href="http://javaspecialists.eu/talks/jfokus13/PhaserAndStampedLock.pdf" rel="nofollow">“移相器和</a><a href="http://javaspecialists.eu/talks/jfokus13/PhaserAndStampedLock.pdf" rel="nofollow">StampedLock演示</a>“<br />CompletableFuture&lt;T&gt;是<a href="http://javadocs.techempower.com/jdk18/api/java/util/concurrent/Future.html" rel="nofollow">Future</a>接口的一个非常棒的实现，它提供了无数执行（和串接）异步任务的方法。它特别依赖功能性的接口；lambdas是值得增加这个类的一个重要原因。如果你正在使用Guava的 Future工具，例如<a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/Futures.html" rel="nofollow">Futures</a>,&nbsp;<a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/ListenableFuture.html" rel="nofollow">ListenableFuture</a>, 和&nbsp;<a href="http://docs.guava-libraries.googlecode.com/git-history/release/javadoc/com/google/common/util/concurrent/SettableFuture.html" rel="nofollow">SettableFuture</a>，那么你可能会希望校验CompletableFuture能否作为潜在的替代选择。<br /><b>IO/NIO API的新增内容</b><br /><ul><li><a href="http://javadocs.techempower.com/jdk18/api/java/io/BufferedReader.html#lines%28%29" rel="nofollow">BufferedReader.lines()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/nio/file/Files.html#list%28java.nio.file.Path%29" rel="nofollow">Files.list(Path)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/nio/file/Files.html#walk%28java.nio.file.Path,%20int,%20java.nio.file.FileVisitOption...%29" rel="nofollow">Files.walk(Path, int, FileVisitOption…)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/nio/file/Files.html#walk%28java.nio.file.Path,%20java.nio.file.FileVisitOption...%29" rel="nofollow">Files.walk(Path, FileVisitOption…)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/nio/file/Files.html#find%28java.nio.file.Path,%20int,%20java.util.function.BiPredicate,%20java.nio.file.FileVisitOption...%29" rel="nofollow">Files.find(Path, int, BiPredicate, FileVisitOption…)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/nio/file/Files.html#lines%28java.nio.file.Path,%20java.nio.charset.Charset%29" rel="nofollow">Files.lines(Path, Charset)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/nio/file/DirectoryStream.html#entries%28%29" rel="nofollow">DirectoryStream.entries()</a></li></ul>简单的说，这些API用于从文件和InputStreams获取java.util.stream.Stream对象。不过它们与直接从常规的collection得到的流有些不同，它们引入了两个概念：<br /><ul><li><a href="http://javadocs.techempower.com/jdk18/api/java/io/UncheckedIOException.html" rel="nofollow">UncheckedIOException</a>&nbsp;- 当有IO错误时抛出这个异常，不过由于Iterator/Stream的签名中不允许有IOException，所以它只能借助于unchecked异常。</li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/stream/CloseableStream.html" rel="nofollow">CloseableStream</a>&nbsp;- 可以（并且应该）定义在 try-with-resources 语句里面的流。</li></ul><b>反射和annotation的改动</b><br /><ul><li>类型annotation (JSR 308)</li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/reflect/AnnotatedType.html" rel="nofollow">AnnotatedType</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/annotation/Repeatable.html" rel="nofollow">Repeatable</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/reflect/Method.html#getAnnotatedReturnType%28%29" rel="nofollow">Method.getAnnotatedReturnType()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/reflect/Field.html#getAnnotationsByType%28java.lang.Class%29" rel="nofollow">Field.getAnnotationsByType(Class)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/reflect/Field.html#getAnnotatedType%28%29" rel="nofollow">Field.getAnnotatedType()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/reflect/Constructor.html#getAnnotatedReturnType%28%29" rel="nofollow">Constructor.getAnnotatedReturnType()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/reflect/Parameter.html" rel="nofollow">Parameter</a>&nbsp;- 支持&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/lang/reflect/Parameter.html#getName%28%29" rel="nofollow">parameter.getName()</a>，等等。</li></ul>Annotation允许在更多的地方被使用，例如List&lt;@Nullable&nbsp;String&gt;。受此影响最大的可能是那些静态分析工具，如Sonar和FindBugs。<br />JSR 308的网站解释了增加这些改动的动机，介绍的不错：&nbsp;<a href="http://types.cs.washington.edu/jsr308/" rel="nofollow">“类型Annotation (JSR 308) 和 Checker框架”</a><br /><b>Nashorn JavaScript 引擎</b><br />提案的摘要：&nbsp;<a href="http://openjdk.java.net/jeps/174" rel="nofollow">JEP 174: Nashorn JavaScript 引擎</a><br />我对Nashorn没什么经验，因而我对上面提案所描述的所知甚少。简单的说，它是&nbsp;<a href="https://developer.mozilla.org/en-US/docs/Rhino" rel="nofollow">Rhino</a>&nbsp;的接替者。Rhino 显得有些老了，并且有点慢，开发者决定最好还是从头做一个。<br /><b>其他新增，涉及java.lang，java.util，和java.sql</b><br /><ul><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/ThreadLocal.html#withInitial%28java.util.function.Supplier%29" rel="nofollow">ThreadLocal.withInitial(Supplier)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/String.html#join%28java.lang.CharSequence,%20java.lang.CharSequence...%29" rel="nofollow">String.join(CharSequence, Charsequence…)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/String.html#join%28java.lang.CharSequence,%20java.lang.Iterable%29" rel="nofollow">String.join(CharSequence, Iterable)</a></li><li>下面的方法适用于所有数字的原语类型，并且作为这些类型的包装（wrapper）类的三个方法。hashCode方法除外，它们的作用是作为BinaryOperatorin的reduce操作的参数。关于这些方法还有很多的链接，更多的内容，参考&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/lang/Integer.html" rel="nofollow">Integer</a>,&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/lang/Long.html" rel="nofollow">Long</a>,&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/lang/Double.html" rel="nofollow">Double</a>,&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/lang/Float.html" rel="nofollow">Float</a>,&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/lang/Byte.html" rel="nofollow">Byte</a>,&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/lang/Short.html" rel="nofollow">Short</a>, 和&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/lang/Character.html" rel="nofollow">Character</a>&nbsp;的javadoc。<br /><ul><li>Primitive.min(primitive, primitive);</li><li>Primitive.max(primitive, primitive);</li><li>Primitive.sum(primitive, primitive);</li><li>Primitive.hashCode(primitive)</li></ul></li><li>同样，下面新增的&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/lang/Boolean.html" rel="nofollow">Boolean</a>&nbsp;的方法可用于BinaryOperator&lt;Boolean&gt;：<br /><ul><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Boolean.html#logicalAnd%28boolean,%20boolean%29" rel="nofollow">Boolean.logicalAnd(boolean, boolean)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Boolean.html#logicalOr%28boolean,%20boolean%29" rel="nofollow">Boolean.logicalOr(boolean, boolean)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Boolean.html#logicalXor%28boolean,%20boolean%29" rel="nofollow">Boolean.logicalXor(boolean, boolean)</a></li></ul></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Optional.html" rel="nofollow">Optional</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/OptionalInt.html" rel="nofollow">OptionalInt</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/OptionalLong.html" rel="nofollow">OptionalLong</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/OptionalDouble.html" rel="nofollow">OptionalDouble</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Base64.html" rel="nofollow">Base64</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/StringJoiner.html" rel="nofollow">StringJoiner</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Spliterator.html" rel="nofollow">Spliterator</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Spliterators.html" rel="nofollow">Spliterators</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Comparator.html#reverseOrder%28%29" rel="nofollow">Comparator.reverseOrder()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Comparator.html#thenComparing%28java.util.Comparator%29" rel="nofollow">Comparator.thenComparing(Comparator)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Comparator.html#thenComparing%28java.util.function.Function,%20java.util.Comparator%29" rel="nofollow">Comparator.thenComparing(Function, Comparator)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Comparator.html#thenComparing%28java.util.function.Function%29" rel="nofollow">Comparator.thenComparing(Function)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Comparator.html#thenComparing%28java.util.function.ToIntFunction%29" rel="nofollow">Comparator.thenComparing(ToIntFunction)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Comparator.html#thenComparing%28java.util.function.ToLongFunction%29" rel="nofollow">Comparator.thenComparing(ToLongFunction)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Comparator.html#thenComparing%28java.util.function.ToDoubleFunction%29" rel="nofollow">Comparator.thenComparing(ToDoubleFunction)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Comparators.html" rel="nofollow">Comparators</a></li><li>下面的方法适用于数组，支持T[], int[], long[], double[]。关于这些方法有很多链接，更多信息参考&nbsp;<a href="http://javadocs.techempower.com/jdk18/api/java/util/Arrays.html" rel="nofollow">Arrays</a>&nbsp;的javadoc。<br /><ul><li>Arrays.spliterator(array)</li><li>Arrays.spliterator(array, int, int)</li><li>Arrays.stream(array)</li><li>Arrays.stream(array, int, int);</li><li>Arrays.parallelStream(array)</li><li>Arrays.parallelStream(array, int, int);</li><li>Arrays.setAll(array, IntFunction)</li><li>Arrays.parallelSetAll(array, IntFunction)</li></ul></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Math.html#toIntExact%28long%29" rel="nofollow">Math.toIntExact(long)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Math.html#addExact%28int,%20int%29" rel="nofollow">Math.addExact(int, int)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Math.html#subtractExact%28int,%20int%29" rel="nofollow">Math.subtractExact(int, int)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Math.html#multiplyExact%28int,%20int%29" rel="nofollow">Math.multiplyExact(int, int)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Math.html#floorDiv%28int,%20int%29" rel="nofollow">Math.floorDiv(int, int)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Math.html#floorMod%28int,%20int%29" rel="nofollow">Math.floorMod(int, int)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Math.html#addExact%28long,%20long%29" rel="nofollow">Math.addExact(long, long)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Math.html#subtractExact%28long,%20long%29" rel="nofollow">Math.subtractExact(long, long)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Math.html#multiplyExact%28long,%20long%29" rel="nofollow">Math.multiplyExact(long, long)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Math.html#floorDiv%28long,%20long%29" rel="nofollow">Math.floorDiv(long, long)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Math.html#floorMod%28long,%20long%29" rel="nofollow">Math.floorMod(long, long)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Integer.html#toUnsignedLong%28int%29" rel="nofollow">Integer.toUnsignedLong(int)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Integer.html#toUnsignedString%28int%29" rel="nofollow">Integer.toUnsignedString(int)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Integer.html#toUnsignedString%28int,%20int%29" rel="nofollow">Integer.toUnsignedString(int, int)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Integer.html#parseUnsignedInt%28java.lang.String%29" rel="nofollow">Integer.parseUnsignedInt(String)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Integer.html#parseUnsignedInt%28java.lang.String,%20int%29" rel="nofollow">Integer.parseUnsignedInt(String, int)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Integer.html#compareUnsigned%28int,%20int%29" rel="nofollow">Integer.compareUnsigned(int, int)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Long.html#toUnsignedString%28long,%20int%29" rel="nofollow">Long.toUnsignedString(long, int)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Long.html#toUnsignedString%28long%29" rel="nofollow">Long.toUnsignedString(long)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Long.html#parseUnsignedLong%28java.lang.String,%20int%29" rel="nofollow">Long.parseUnsignedLong(String, int)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Long.html#parseUnsignedLong%28java.lang.String%29" rel="nofollow">Long.parseUnsignedLong(String)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Long.html#compareUnsigned%28long,%20long%29" rel="nofollow">Long.compareUnsigned(long, long)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Long.html#divideUnsigned%28long,%20long%29" rel="nofollow">Long.divideUnsigned(long, long)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/lang/Long.html#remainderUnsigned%28long,%20long%29" rel="nofollow">Long.remainderUnsigned(long, long)</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/math/BigInteger.html#longValueExact%28%29" rel="nofollow">BigInteger.longValueExact()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/math/BigInteger.html#intValueExact%28%29" rel="nofollow">BigInteger.intValueExact()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/math/BigInteger.html#shortValueExact%28%29" rel="nofollow">BigInteger.shortValueExact()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/math/BigInteger.html#byteValueExact%28%29" rel="nofollow">BigInteger.byteValueExact()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Objects.html#isNull%28T%29" rel="nofollow">Objects.isNull(Object)</a>&nbsp;- 可用作谓词，例如stream.anyMatch(Objects::isNull)</li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Objects.html#nonNull%28T%29" rel="nofollow">Objects.nonNull(Object)</a>&nbsp;- 可用作谓词，stream.filter(Objects::nonNull)</li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Random.html#ints%28%29" rel="nofollow">Random.ints()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Random.html#longs%28%29" rel="nofollow">Random.longs()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Random.html#doubles%28%29" rel="nofollow">Random.doubles()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Random.html#gaussians%28%29" rel="nofollow">Random.gaussians()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/BitSet.html#stream%28%29" rel="nofollow">BitSet.stream()</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/IntSummaryStatistics.html" rel="nofollow">IntSummaryStatistics</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/LongSummaryStatistics.html" rel="nofollow">LongSummaryStatistics</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/DoubleSummaryStatistics.html" rel="nofollow">DoubleSummaryStatistics</a></li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/logging/Logger.html" rel="nofollow">Logger</a>的杂项新增</li><li><a href="http://javadocs.techempower.com/jdk18/api/java/util/Locale.html" rel="nofollow">Locale</a>的杂项新增</li><li><a href="http://javadocs.techempower.com/jdk18/api/java/sql/ResultSet.html" rel="nofollow">ResultSet</a>的杂项新增</li></ul>这里可以介绍的太多了，只能挑一些最需要注意的项目。<br />ThreadLocal.withInitial(Supplier&lt;T&gt;) 可以在定义thread-local变量时更好的进行初始化。之前你初始化变量时是这样的：<br /><pre>ThreadLocal&lt;List&lt;String&gt;&gt; strings = new ThreadLocal&lt;List&lt;String&gt;&gt;() { @Override protected List&lt;String&gt; initialValue() { return new ArrayList&lt;&gt;();<br />        }<br />    };</pre>现在则是这样：<br /><pre>ThreadLocal&lt;List&lt;String&gt;&gt; strings =<br />    ThreadLocal.withInital(ArrayList::new);</pre>stream的API的返回值有一个可选的&lt;T&gt;，就像min/max， findFirst/Any， 以及reduce的某些形式。这样做是因为stream中可能没有任何元素，但是它要提供一个一致的API，既可以处理“一些结果”，也可以处理“没有结果”。你可以提供默认值，抛异常，或者只在有结果的时候执行一些动作。<br />它与Guava’s Optional类非常非常的相似。它一点都不像是在 Scala里的操作，也不会试图成为之一，有相似的地方纯属巧合。<br />旁白：Java 8′s Optional和Guava’s Optional最终如此的相似是很有趣的事，尽管荒谬的辩论发生在这两个库。<br /><blockquote>“FYI…. Optional was the cause of possibly the single greatest conflagration on the internal Java libraries discussion lists ever.”</blockquote>Kevin Bourrillion在&nbsp;<a href="https://groups.google.com/forum/#%21msg/guava-discuss/JVgYWq6VU4c/GbdqVcvr610J" rel="nofollow">response to “Some new Guava classes targeted for release 10″</a>如实写到：<br /><blockquote>“On a purely practical note, the discussions surrounding Optional have exceeded its design budget by several orders of magnitude.”</blockquote>Brian Goetz 在&nbsp;&nbsp;<a href="http://mail.openjdk.java.net/pipermail/lambda-dev/2012-October/006365.html" rel="nofollow">response to “Optional require(s) NonNull”</a>写到。<br />StringJoinerandString.join(…)来得太晚了。他们来得如此之晚以至于大多数Java开发者已经为字符串联合编写或发现了有用的工具，但这对JDK本身来说很每秒，因为最终自己实现这一点。每个人都会遇到要求字符串连接的情形，我们现在能够通过每个Java开发者（事实上的）即将知道的标准的API来阐明，这也算是一件好事。<br /><br />ComparatorsandComparator.thenComparing(…)提供了非常优秀的工具，基于链的比较和基于域的比较。像这样：<br /><pre>people.sort(Comparators.comparing(Person::getLastName)<br />                       .thenComparing(Person::getFirstName));</pre>这些新增功能提供了良好的，复杂的各种可读的简写。大多数用例由JDK里增加的 ComparisonChain和Ordering工具类来提供服务。对于什么是有价值的，我认为JDK版本比在Guava-ese里功能等效的版本的可读性好了很多。<br /><b>更多？</b><br />其实，还有很多的小问题的修正和一些性能的改进在这篇文章中没有提及，但是那些也是非常的重要的。<br />写这篇文章主要是想全面的介绍到Java 8的每个语言层面和API层面的改进，如果有遗漏，那就是个错误。如果你发现了这样的错误请告诉我，你可以通过<a href="http://www.oschina.net/translate/dev@techempower.com" rel="nofollow">e-mail</a>联系我或者是在<a href="https://news.ycombinator.com/item?id=5449525" rel="nofollow">黑客咨询</a>上发布评论。<br /><br /><h4>相关文章</h4><ul><li><a href="http://blog.jobbole.com/23939/"><img alt="Java对象初始化详解" src="http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg" /></a><a href="http://blog.jobbole.com/23939/">Java对象初始化详解</a></li><li><a href="http://blog.jobbole.com/22433/"><img alt="Java 8 中的 lambda 表达式" src="http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg" /></a><a href="http://blog.jobbole.com/22433/">Java 8 中的 lambda 表达式</a></li><li><a href="http://blog.jobbole.com/30257/"><img alt="《深入理解JAVA虚拟机》笔记" height="150" src="http://blog.jobbole.com/wp-content/uploads/2012/11/deep_into_JVM_001-150x150.jpg" width="150" /></a><a href="http://blog.jobbole.com/30257/">《深入理解JAVA虚拟机》笔记</a></li><li><a href="http://blog.jobbole.com/26540/"><img alt="Java编码易疏忽的十个问题" src="http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg" /></a><a href="http://blog.jobbole.com/26540/">Java编码易疏忽的十个问题</a></li><li><a href="http://blog.jobbole.com/28297/"><img alt="Java多线程发展简史" height="150" src="http://blog.jobbole.com/wp-content/uploads/2012/09/image_thumb10-150x150.png" width="150" /></a><a href="http://blog.jobbole.com/28297/">Java多线程发展简史</a></li><li><a href="http://blog.jobbole.com/1455/"><img alt="Java语言设计人员笔记: 首先不要造成伤害" src="http://blog.jobbole.com/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/28.jpg" /></a><a href="http://blog.jobbole.com/1455/">Java语言设计人员笔记: 首先不要造成伤害</a></li><li><a href="http://blog.jobbole.com/18935/"><img alt="for 循环为何可恨？" src="http://blog.jobbole.com/wp-content/uploads/2011/11/Java-programming-language-logo.jpg" /></a><a href="http://blog.jobbole.com/18935/">for 循环为何可恨？</a></li><li><a href="http://blog.jobbole.com/989/"><img alt="余昭辉：做Java开发的这一年" src="http://blog.jobbole.com/wp-content/plugins/wordpress-23-related-posts-plugin/static/thumbs/28.jpg" /></a><a href="http://blog.jobbole.com/989/">余昭辉：做Java开发的这一年</a></li><li><a href="http://blog.jobbole.com/21190/"><img alt="oracle-v-google-1308942960" height="150" src="http://blog.jobbole.com/wp-content/uploads/2012/06/oracle-v-google-1308942960-150x150.jpg" width="150" /></a><a href="http://blog.jobbole.com/21190/">亲爱的Oracle: Java API不是艺术品</a></li><li><a href="http://blog.jobbole.com/31860/"><img alt="探索Java语言与JVM中的Lambda表达式" src="http://blog.jobbole.com/wp-content/uploads/2013/02/Java-programming-language-logo3-150x150.jpg" /></a><a href="http://blog.jobbole.com/31860/">探索Java语言与JVM中的Lambda表达式</a></li></ul><a href="http://blog.jobbole.com/39006/">Java 8 的新特性和改进总览</a>，首发于<a href="http://blog.jobbole.com/">博客 - 伯乐在线</a>。