---
layout: post
title: "加速你的Python代码"
date: '2013-03-25T12:39:00.001+08:00'
author: Wenh Q
tags:
- tech.python
modified_time: '2013-11-30T12:24:13.764+08:00'
blogger_id: tag:blogger.com,1999:blog-4961947611491238191.post-4286674948424077543
blogger_orig_url: http://binaryware.blogspot.com/2013/03/python.html
---

<a href="http://blog.jobbole.com/36701/?utm_source=rss&amp;utm_medium=rss&amp;utm_campaign=%25e5%258a%25a0%25e9%2580%259f%25e4%25bd%25a0%25e7%259a%2584python%25e4%25bb%25a3%25e7%25a0%2581">加速你的Python代码</a>: <br />来源：<a href="http://www.oschina.net/translate/speeding-up-your-python-code" rel="nofollow">oschina</a>,英文原文：<a href="http://maxburstein.com/blog/speeding-up-your-python-code/" title="Speeding Up Your Python Code">Speeding Up Your Python Code</a><br />在我看来，python社区分为了三个流派，分别是python 2.x组织，3.x组织和PyPy组织。这个分类基本上可以归根于类库的兼容性和速度。这篇文章将聚焦于一些通用代码的优化技巧以及编译成C后性能的显著提升，当然我也会给出三大主要python流派运行时间。我的目的不是为了证明一个比另一个强，只是为了让你知道如何在不同的环境下使用这些具体例子作比较。<br /><b>使用生成器</b><br />一个普遍被忽略的内存优化是生成器的使用。生成器让我们创建一个函数一次只返回一条记录，而不是一次返回所有的记录，如果你正在使用python2.x，这就是你为啥使用xrange替代range或者使用ifilter替代filter的原因。一个很好地例子就是创建一个很大的列表并将它们拼合在一起。<br /><pre>import timeit<br />import random<br /><br />def generate(num):<br />while num:<br />yield random.randrange(10)<br />num -= 1<br /><br />def create_list(num):<br />numbers = []<br />while num:<br />numbers.append(random.randrange(10))<br />num -= 1<br />return numbers<br />print(timeit.timeit("sum(generate(999))", setup="from __main__ import generate", number=1000))<br />&gt;&gt;&gt; 0.88098192215 #Python 2.7<br />&gt;&gt;&gt; 1.416813850402832 #Python 3.2<br />print(timeit.timeit("sum(create_list(999))", setup="from __main__ import create_list", number=1000))<br />&gt;&gt;&gt; 0.924163103104 #Python 2.7<br />&gt;&gt;&gt; 1.5026731491088867 #Python 3.2</pre>这不仅是快了一点，也避免了你在内存中存储全部的列表!<br /><b>Ctypes的介绍</b><br />对于关键性的性能代码python本身也提供给我们一个API来调用C方法，主要通过&nbsp;<a href="http://docs.python.org/3/library/ctypes.html" rel="nofollow">ctypes</a>来实现，你可以不写任何C代码来利用ctypes。默认情况下python提供了预编译的标准c库，我们再回到生成器的例子，看看使用ctypes实现花费多少时间。<br /><pre>import timeit<br />from ctypes import cdll<br /><br />def generate_c(num):<br />#Load standard C library<br />libc = cdll.LoadLibrary("libc.so.6") #Linux<br />#libc = cdll.msvcrt #Windows<br />while num:<br />yield libc.rand() % 10<br />num -= 1<br /><br />print(timeit.timeit("sum(generate_c(999))", setup="from __main__ import generate_c", number=1000))<br />&gt;&gt;&gt; 0.434374809265 #Python 2.7<br />&gt;&gt;&gt; 0.7084300518035889 #Python 3.2</pre>仅仅换成了c的随机函数，运行时间减了大半！现在如果我告诉你我们还能做得更好，你信吗?<br /><b>Cython的介绍</b><br /><a href="http://www.cython.org/" rel="nofollow">Cython</a>&nbsp;是python的一个超集，允许我们调用C函数以及声明变量来提高性能。尝试使用之前我们需要先安装Cython.<br /><pre>sudo pip install cython</pre>Cython 本质上是另一个不再开发的类似类库Pyrex的分支，它将我们的类Python代码编译成C库，我们可以在一个python文件中调用。对于你的python文件使用.pyx后缀替代.py后缀，让我们看一下使用Cython如何来运行我们的生成器代码。<br /><pre>#cython_generator.pyx<br />import random<br /><br />def generate(num):<br />while num:<br />yield random.randrange(10)<br />num -= 1</pre>我们需要创建个setup.py以便我们能获取到Cython来编译我们的函数。<br /><pre>from distutils.core import setup<br />from distutils.extension import Extension<br />from Cython.Distutils import build_ext<br /><br />setup(<br />cmdclass = {'build_ext': build_ext},<br />ext_modules = [Extension("generator", ["cython_generator.pyx"])]<br />)</pre>编译使用:<br /><pre>python setup.py build_ext --inplace</pre>你应该可以看到两个文件cython_generator.c&nbsp;文件 和 generator.so文件，我们使用下面方法测试我们的程序:<br /><pre>import timeit<br />print(timeit.timeit("sum(generator.generate(999))", setup="import generator", number=1000))<br />&gt;&gt;&gt; 0.835658073425</pre>还不赖，让我们看看是否还有可以改进的地方。我们可以先声明“num”为整形，接着我们可以导入标准的C库来负责我们的随机函数。<br /><pre>#cython_generator.pyx<br />cdef extern from "stdlib.h":<br />int c_libc_rand "rand"()<br /><br />def generate(int num):<br />while num:<br />yield c_libc_rand() % 10<br />num -= 1</pre>如果我们再次编译运行我们会看到这一串惊人的数字。<br /><pre>&gt;&gt;&gt; 0.033586025238</pre>仅仅的几个改变带来了不赖的结果。然而，有时这个改变很乏味，因此让我们来看看如何使用规则的python来实现吧。<br /><br /><b>PyPy的介绍</b><a href="http://pypy.org/index.html" rel="nofollow">PyPy</a>&nbsp;是一个Python2.7.3的<a href="http://en.wikipedia.org/wiki/Just-in-time_compilation" rel="nofollow">即时编译器</a>，通俗地说这意味着让你的代码运行的更快。<a href="http://www.quora.com/Alex-Gaynor/Posts/Quora-is-now-running-on-PyPy" rel="nofollow">Quora</a>在生产环境中使用了PyPy。PyPy在它们的下载页面有一些安装说明，但是如果你使用的Ubuntu系统，你可以通过apt-get来安装。它的运行方式是立即可用的，因此没有疯狂的bash或者运行脚本，只需下载然后运行即可。让我们看看我们原始的生成器代码在PyPy下的性能如何。<br /><pre>import timeit<br />import random<br /><br />def generate(num):<br />while num:<br />yield random.randrange(10)<br />num -= 1<br /><br />def create_list(num):<br />numbers = []<br />while num:<br />numbers.append(random.randrange(10))<br />num -= 1<br />return numbers<br />print(timeit.timeit("sum(generate(999))", setup="from __main__ import generate", number=1000))<br />&gt;&gt;&gt; 0.115154981613 #PyPy 1.9<br />&gt;&gt;&gt; 0.118431091309 #PyPy 2.0b1<br />print(timeit.timeit("sum(create_list(999))", setup="from __main__ import create_list", number=1000))<br />&gt;&gt;&gt; 0.140175104141 #PyPy 1.9<br />&gt;&gt;&gt; 0.140514850616 #PyPy 2.0b1</pre>哇！没有修改一行代码运行速度是纯python实现的8倍。<br /><b>进一步测试</b>为什么还要进一步研究？PyPy是冠军！并不全对。虽然大多数程序可以运行在PyPy上，但是还是有一些库没有被完全支持。而且，为你的项目写C的扩展相比换一个编译器更加容易。让我们更加深入一些，看看ctypes如何让我们使用C来写库。我们来测试一下归并排序和计算斐波那契数列的速度。下面是我们要用到的C代码（functions.c）：<br /><pre>/* functions.c */<br />#include &lt;stdio.h&gt;<br />#include &lt;stdlib.h&gt;<br />#include &lt;string.h&gt;<br /><br />/* http://rosettacode.org/wiki/Sorting_algorithms/Merge_sort#C */<br />inline void<br />merge (int *left, int l_len, int *right, int r_len, int *out)<br />{<br />int i, j, k;<br />for (i = j = k = 0; i &lt; l_len &amp;&amp; j &lt; r_len;)<br />out[k++] = left[i] &lt; right[j] ? left[i++] : right[j++];<br />while (i &lt; l_len)<br />out[k++] = left[i++];<br />while (j &lt; r_len)<br />out[k++] = right[j++];<br />}<br /><br />/* inner recursion of merge sort */<br />void<br />recur (int *buf, int *tmp, int len)<br />{<br />int l = len / 2;<br />if (len &lt;= 1)<br />return;<br />/* note that buf and tmp are swapped */<br />recur (tmp, buf, l);<br />recur (tmp + l, buf + l, len - l);<br />merge (tmp, l, tmp + l, len - l, buf);<br />}<br /><br />/* preparation work before recursion */<br />void<br />merge_sort (int *buf, int len)<br />{<br />/* call alloc, copy and free only once */<br />int *tmp = malloc (sizeof (int) * len);<br />memcpy (tmp, buf, sizeof (int) * len);<br />recur (buf, tmp, len);<br />free (tmp);<br />}<br /><br />int<br />fibRec (int n)<br />{<br />if (n &lt; 2)<br />return n;<br />else<br />return fibRec (n - 1) + fibRec (n - 2);<br />}</pre>在Linux平台，我们可以用下面的方法把它编译成一个共享库：<br /><pre>gcc -Wall -fPIC -c functions.c<br />gcc -shared -o libfunctions.so functions.o</pre>使用ctypes， 通过加载”libfunctions.so”这个共享库，就像我们前边对标准C库所作的那样，就可以使用这个库了。这里我们将要比较Python实现和C实现。现在我们开始计算斐波那契数列：<br /><pre># functions.py<br /><br />from ctypes import *<br />import time<br /><br />libfunctions = cdll.LoadLibrary("./libfunctions.so")<br /><br />def fibRec(n):<br />if n &lt; 2:<br />return n<br />else:<br />return fibRec(n-1) + fibRec(n-2)<br /><br />start = time.time()<br />fibRec(32)<br />finish = time.time()<br />print("Python: " + str(finish - start))<br /><br /># C Fibonacci<br />start = time.time()<br />x = libfunctions.fibRec(32)<br />finish = time.time()<br />print("C: " + str(finish - start))</pre>正如我们预料的那样，C比Python和PyPy更快。我们也可以用同样的方式比较归并排序。<br />我们还没有深挖Cypes库，所以这些例子并没有反映python强大的一面，Cypes库只有少量的标准类型限制，比如int型，char数组，float型，字节（bytes）等等。默认情况下，没有整形数组，然而通过与c_int相乘（ctype为int类型）我们可以间接获得这样的数组。这也是代码第7行所要呈现的。我们创建了一个c_int数组，有关我们数字的数组并分解打包到c_int数组中<br />主要的是c语言不能这样做，而且你也不想。我们用指针来修改函数体。为了通过我们的c_numbers的数列，我们必须通过引用传递merge_sort功能。运行merge_sort后，我们利用c_numbers数组进行排序，我已经把下面的代码加到我的functions.py文件中了。<br /><pre>#Python Merge Sort<br />from random import shuffle, sample<br /><br />#Generate 9999 random numbers between 0 and 100000<br />numbers = sample(range(100000), 9999)<br />shuffle(numbers)<br />c_numbers = (c_int * len(numbers))(*numbers)<br /><br />from heapq import merge<br />def merge_sort(m):<br />if len(m) &lt;= 1:<br />return m<br />middle = len(m) // 2<br />left = m[:middle]<br />right = m[middle:]<br />left = merge_sort(left)<br />right = merge_sort(right)<br />return list(merge(left, right))<br /><br />start = time.time()<br />numbers = merge_sort(numbers)<br />finish = time.time()<br />print("Python: " + str(finish - start))<br /><br />#C Merge Sort<br />start = time.time()<br />libfunctions.merge_sort(byref(c_numbers), len(numbers))<br />finish = time.time()<br />print("C: " + str(finish - start))</pre><pre>Python: 0.190635919571 #Python 2.7<br />Python: 0.11785483360290527 #Python 3.2<br />Python: 0.266992092133 #PyPy 1.9<br />Python: 0.265724897385 #PyPy 2.0b1<br />C: 0.00201296806335 #Python 2.7 + ctypes<br />C: 0.0019741058349609375 #Python 3.2 + ctypes<br />C: 0.0029308795929 #PyPy 1.9 + ctypes<br />C: 0.00287103652954 #PyPy 2.0b1 + ctypes</pre>这儿通过表格和图标来比较不同的结果。<br /><a href="http://blog.jobbole.com/wp-content/uploads/2013/03/speeding-up-your-python-code.jpg" rel="lightbox[36701]" title="加速你的Python代码"><img alt="加速你的Python代码" src="http://blog.jobbole.com/wp-content/uploads/2013/03/speeding-up-your-python-code.jpg" title="加速你的Python代码" /></a><br /><table border="1"><tbody><tr> <th></th> <th>Merge Sort</th> <th>Fibonacci</th> </tr><tr> <th>Python 2.7</th> <td>0.191</td> <td>1.187</td> </tr><tr> <th>Python 2.7 + ctypes</th> <td>0.002</td> <td>0.044</td> </tr><tr> <th>Python 3.2</th> <td>0.118</td> <td>1.272</td> </tr><tr> <th>Python 3.2 + ctypes</th> <td>0.002</td> <td>0.046</td> </tr><tr> <th>PyPy 1.9</th> <td>0.267</td> <td>0.564</td> </tr><tr> <th>PyPy 1.9 + ctypes</th> <td>0.003</td> <td>0.048</td> </tr><tr> <th>PyPy 2.0b1</th> <td>0.266</td> <td>0.567</td> </tr><tr> <th>PyPy 2.0b1 + ctypes</th> <td>0.003</td> <td>0.046</td> </tr></tbody> </table>希望你利用C和PyPy优化你的python代码并以此为敲门砖找到一个好职位。像往常一样如果你有任何意见或问题，请随时把评论下载下面或者在我的网页上与我取得联系。感谢您的阅读！<br />附：如果您的公司正在寻求聘请即将毕业的优秀大学生（2013年5月），让我知道！<br /><h4>相关文章</h4><ul><li><a href="http://blog.jobbole.com/28506/"><img alt="Python关键字yield详解" src="http://blog.jobbole.com/wp-content/uploads/2012/02/python-logo.png" /></a><a href="http://blog.jobbole.com/28506/">Python关键字yield详解</a></li><li><a href="http://blog.jobbole.com/18159/"><img alt="一行 Python 代码搞定一棵树" src="http://blog.jobbole.com/wp-content/uploads/2012/02/python-logo.png" /></a><a href="http://blog.jobbole.com/18159/">一行 Python 代码搞定一棵树</a></li><li><a href="http://blog.jobbole.com/23425/"><img alt="Python十分钟入门" src="http://blog.jobbole.com/wp-content/uploads/2012/02/python-logo.png" /></a><a href="http://blog.jobbole.com/23425/">Python十分钟入门</a></li><li><a href="http://blog.jobbole.com/25037/"><img alt="curiosity rover" src="http://blog.jobbole.com/wp-content/uploads/2012/08/curiosity-rover-in-desert-150x150.jpg" height="150" width="150" /></a><a href="http://blog.jobbole.com/25037/">好奇号火星车的一些计算机软硬件信息</a></li><li><a href="http://blog.jobbole.com/15555/"><img alt="10个实用的Django建议" src="http://blog.jobbole.com/wp-content/uploads/2012/02/python-logo.png" /></a><a href="http://blog.jobbole.com/15555/">10个实用的Django建议</a></li><li><a href="http://blog.jobbole.com/21351/"><img alt="python-icon" src="http://blog.jobbole.com/wp-content/uploads/2012/06/python-icon-150x150.jpg" height="150" width="150" /></a><a href="http://blog.jobbole.com/21351/">深刻理解Python中的元类(metaclass)</a></li><li><a href="http://blog.jobbole.com/19835/"><img alt="import_python" src="http://blog.jobbole.com/wp-content/uploads/2012/05/import_python-150x150.jpg" height="150" width="150" /></a><a href="http://blog.jobbole.com/19835/">Python编程中需要注意的一些事</a></li><li><a href="http://blog.jobbole.com/17295/"><img alt="孩子们为什么要学Python编程" src="http://blog.jobbole.com/wp-content/uploads/2012/04/languages-of-live-projects-150x150.jpg" height="150" width="150" /></a><a href="http://blog.jobbole.com/17295/">孩子们为什么要学Python编程</a></li><li><a href="http://blog.jobbole.com/14174/"><img alt="Google App Engine正式支持Python 2.7 " src="http://blog.jobbole.com/wp-content/uploads/2012/02/python-logo.png" /></a><a href="http://blog.jobbole.com/14174/">Google App Engine正式支持Python 2.7 </a></li><li><a href="http://blog.jobbole.com/23773/"><img alt="陈皓：代码执行的效率" src="http://blog.jobbole.com/wp-content/uploads/2012/07/Code-execution-efficiency4.jpg" /></a><a href="http://blog.jobbole.com/23773/">陈皓：代码执行的效率</a></li></ul><a href="http://blog.jobbole.com/36701/">加速你的Python代码</a>，首发于<a href="http://blog.jobbole.com/">博客 - 伯乐在线</a>。