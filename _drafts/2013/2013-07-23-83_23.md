--- layout: post title: "程序员必知8大排序3大查找（二）" date:
'2013-07-23T15:50:00.002+08:00' author: Wenh Q tags: modified\_time:
'2013-07-23T15:50:25.655+08:00' thumbnail:
https://lh5.googleusercontent.com/6C4Rr90Ft6UynTSTOqxrg2RZ2EUIfgAYKnf\_H6YyAHoJnKIticeDzQiL3OBr04ocBlHnxsxCt7tsXtN7MYqb2wEg6oj6RQU2xMPSV8NI0VB5ZXqwgmo=s72-c
blogger\_id:
tag:blogger.com,1999:blog-4961947611491238191.post-3747923869846916165
blogger\_orig\_url: http://binaryware.blogspot.com/2013/07/83\_23.html
---
[\
程序员必知8大排序3大查找（二）](http://blog.csdn.net/shan9liang/article/details/7540928)
于 12-5-7 通过
[CSDN博客推荐文章](http://blog.csdn.net/) 作者：shan9liang
[接上篇《程序员必知](http://blog.csdn.net/shan9liang/article/details/7533466)[8](http://blog.csdn.net/shan9liang/article/details/7533466)[大排序](http://blog.csdn.net/shan9liang/article/details/7533466)[3](http://blog.csdn.net/shan9liang/article/details/7533466)[大查找（一）》](http://blog.csdn.net/shan9liang/article/details/7533466)
\
本文我们先把剩余的三大排序说完，然后讨论一下排序的稳定性问题，最后再总结一下排序的时间复杂度和空间复杂度。
（1到5见上篇）
6、快速排序
\
（1）基本思想：选择一个基准元素,通常选择第一个元素或者最后一个元素,通过一趟扫描，将待排序列分成两部分,一部分比基准元素小,一部分大于等于基准元素,此时基准元素在其排好序后的正确位置,然后再用同样的方法递归地排序划分的两部分。
（2）实例：
![](https://lh5.googleusercontent.com/6C4Rr90Ft6UynTSTOqxrg2RZ2EUIfgAYKnf_H6YyAHoJnKIticeDzQiL3OBr04ocBlHnxsxCt7tsXtN7MYqb2wEg6oj6RQU2xMPSV8NI0VB5ZXqwgmo)
上图中将待排序列分成两部分,一部分比基准元素小,一部分大于基准元素,然后对这两部分重复上图的求解过程。
（这只是快速排序的一种实现方式，个人认为比较容易理解）
7、归并排序
（1）基本排序：归并（Merge）排序法是将两个（或两个以上）有序表合并成一个新的有序表，即把待排序序列分为若干个子序列，每个子序列是有序的。然后再把有序子序列合并为整体有序序列。
（2）实例：
![](https://lh3.googleusercontent.com/4--LTaIeTpU0zVYStInmeJZ-jBAALETOZpZvezUbiKYkKsdWwJKluflcfA1G1SwJDVCgFo_Du0fWailXi6A7IAwLQVKbyjU5vMKJiLlR4FYf1aMSJSQ)
8、基数排序
（1）基本思想：将所有待比较数值（正整数）统一为同样的数位长度，数位较短的数前面补零。然后，从最低位开始，依次进行一次排序。这样从最低位排序一直到最高位排序完成以后,数列就变成一个有序序列。
（2）实例：
![](https://lh5.googleusercontent.com/N2G5fOYANwvzk2BxqE3pRp1PmOElRkeBgc7W_KN3eekhwnK-rHrs-jQAAmi-SDjZCd35dGMx_jwv1VDX02TJurupz-O_mebnVJ02rpTB7txKAY4LuG0)
稳定性说明：排序前，2（或者更多）个相等的数在序列的前后位置顺序和排序后它们在序列中的前后位置顺序一样。
实例：
待排序数列：5,4,8,6,1,8,7,9
排序结果：1,4,5,6,7,8,8,9
稳定：1,4,5,6,7,8,8,9
不稳定：1,4,5,6,7,8,8,9
说明：对比红色的8和紫色的8，看他们排序前后的位置。排序前，红8在紫8前面，如果排序后红8仍然在紫8前面，则排序算法稳定，否则不稳定。 
现在我们分析一下8种排序算法的稳定性。
\
（请网友结合前面的排序基本思想来理解排序的稳定性（8种排序的基本思想已经在前面说过，这里不再赘述）不然可能有些模糊）
\
（1）直接插入排序：一般插入排序，比较是从有序序列的最后一个元素开始，如果比它大则直接插入在其后面，否则一直往前比。如果找到一个和插入元素相等的，那么就插入到这个相等元素的后面。插入排序是稳定的。
\
（2）希尔排序：希尔排序是按照不同步长对元素进行插入排序，一次插入排序是稳定的，不会改变相同元素的相对顺序，但在不同的插入排序过程中，相同的元素可能在各自的插入排序中移动，稳定性就会被破坏，所以希尔排序不稳定。
\
（3）简单选择排序：在一趟选择，如果当前元素比一个元素小，而该小的元素又出现在一个和当前元素相等的元素后面，那么交换后稳定性就被破坏了。光说可能有点模糊，来看个小实例：858410，第一遍扫描，第1个元素8会和4交换，那么原序列中2个8的相对前后顺序和原序列不一致了，所以选择排序不稳定。
\
（4）堆排序：堆排序的过程是从第n/2开始和其子节点共3个值选择最大(大顶堆)或者最小(小顶堆),这3个元素之间的选择当然不会破坏稳定性。但当为n/2-1,
n/2-2,
...这些父节点选择元素时，有可能第n/2个父节点交换把后面一个元素交换过去了，而第n/2-1个父节点把后面一个相同的元素没有交换，所以堆排序并不稳定。
\
（5）冒泡排序：由前面的内容可知，冒泡排序是相邻的两个元素比较，交换也发生在这两个元素之间，如果两个元素相等，不用交换。所以冒泡排序稳定。
\
（6）快速排序：在中枢元素和序列中一个元素交换的时候，很有可能把前面的元素的稳定性打乱。还是看一个小实例：6
4 4 5 4 7 8
 9，第一趟排序，中枢元素6和第三个4交换就会把元素4的原序列破坏，所以快速排序不稳定。
\
（7）归并排序：在分解的子列中，有1个或2个元素时，1个元素不会交换，2个元素如果大小相等也不会交换。在序列合并的过程中，如果两个当前元素相等时，我们把处在前面的序列的元素保存在结果序列的前面，所以，归并排序也是稳定的。
\
（8）基数排序：是按照低位先排序，然后收集；再按照高位排序，然后再收集；依次类推，直到最高位。有时候有些属性是有优先级顺序的，先按低优先级排序，再按高优先级排序，最后的次序就是高优先级高的在前，高优先级相同的低优先级高的在前。基数排序基于分别排序，分别收集，所以是稳定的。
\
8种排序的分类，稳定性，时间复杂度和空间复杂度总结：
![](https://lh6.googleusercontent.com/EAc_xiFMePwVnknVceDgVCQB273dNJGHT4rJ82tZ-QuSIIWEZBBFZ-5qKVxtzejfdKy-0bjaHxZVV6x_WCSWMH5U_sIyRPYP6KCZsfgGrkh23gVb_wc)
未完待续，下一篇将主要介绍三大查找，敬请期待！
作者：shan9liang 发表于2012-5-7 7:45:28
[原文链接](http://blog.csdn.net/shan9liang/article/details/7540928)
阅读：91 评论：2
[查看评论](http://blog.csdn.net/shan9liang/article/details/7540928#comments)
